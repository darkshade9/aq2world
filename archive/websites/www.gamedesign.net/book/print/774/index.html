<html><head><title>Quake III Media Editing Tools</title><base href="http://www.gamedesign.net/" /><style type="text/css">
@import url(misc/print.css);
</style></head><body><h1 id="774" name="774" class="book-h1">Quake III Media Editing Tools</h1><h3>Media Creation</h3>
<p class="q3bg1"><b>Quake III Arena is a vast game</b>.. Many functions are preformed throughout the course of its creation including modeling, animating, 2d art  &amp; animation creation, sound editing, coding/programming, level editing, shader scripting and more.<br><br>
In this area you'll find linkage to Quake III related editing applications and other useful tools you'll use to make media for Q3. Don't be shy, this is a 
walk in the park.<br><br>
Be sure to view the readmes included with very application you download, install the smart way. The documentation supplied with these apps. are always the best location to learn whatever you'll need to get around. Pay close attention to things like hotkey lists and shortcuts. Every app is different, some like Wings3d will allow you to set any command to whatever key you want.<br><br>
The forums for these applications is listed in each ones box. IF you need help or if you find a link broken contact on of the admins via private message or visit <a href="http://forums.gamedesign.net/viewforum.php?f=40">the General Discussion forum</a>. We'll fix it if it's broken.</p><!--break--><h1 id="903" name="903" class="book-h1">Gensurf - Terrain Mesh Generator</h1><ul><h3>GenSurf - Terrain Generator</h3>
<p class="q3bg1b"><b>Author</b>: David Hyde</p>
<p class="q3bg1b"><a href="http://tarot.telefragged.com/gensurf/downloads.htm">Downloads Page</a><br><a href="http://tarot.telefragged.com/gensurf/">Gensurf Documentation</a><br><a href="http://tarot.telefragged.com/gensurf/">Official Site</a><br><br>
GenSurf produces a .map file consisting of triangular brushes arranged in a uniform grid. There are several advantages to using uniform-sized triangles rather than randomly-placed triangles:<br><br><!--break-->Less brush fragmentation in Q2-engine games than an equivalently complex random arrangement (though the latest version can also produce non-rectangular meshes with the decimation feature). <br><br>Allows you to take advantage of hint brushes with the detail property to eliminate most, if not all, brush fragmentation.<br><br>GenSurf-generated maps contain integer values for all brush coordinates (GenSurf uses integer coordinates by design - it doesn't simply round off floating point values to the nearest integer). This ensures compatibility with the widest variety of map editors, but much more importantly it minimizes the likelihood of roundoff errors causing gaps and/or overlaps between brushes.<br><br>GenSurf has several methods of generating surfaces. You may choose between canned trigonometric functions or a fractal surface, then lock specific vertices at a given value and specify the range away from that vertex that other vertices are effected. You can also import a bitmap image representing contour values. If you own Microsoft Excel 5.0, the latest version of GenSurf allows you to describe a surface with a mathematical function.<br><br>With the executable version you can use the "add skybox" option and append one surface to another, building a complete, ready-to-compile outdoor area with ground surface and surrounding cliff walls without opening a map editor.</p></ul><h1 id="896" name="896" class="book-h1">GMAX & Tempest Q3 GamePack</h1><ul><h3>GMax 3D Modeller and Tempest Q3 Game Pack</h3>
<p class="q3bg1b"><b>Author</b>: Discreet Software</p>
<p class="q3bg1b"><a href="http://www.turbosquid.com/gmax">Download Page</a><br><a href="http://www4.discreet.com/gmax/gmax.php?id=906">FAQ's</a><br><a href="http://www4.discreet.com/gmax">Official Site</a><br><a href="http://www4.discreet.com/gmax/gmax.php?id=907">Tempest Quake III Tutorial</a><br><br>
gmax®  is a free 3D modeling and animation tool based on Discreet's award-winning 3ds max® software. Built for gamers to create their own in-game content for gmax ready games, a gamer can produce everything from characters and vehicles to landscapes and props. Not only do you get to customize your games, you also learn 3D design within a professional-level tool. <br><br>Intended to be a fully capable 3D level editing, modeling, animation, and texture mapping tool, gmax ships with a full suite of professional 3D content and animation features. Discreet approved game developers can publish gmax game packs, which customize the downloadable version of gmax into a fully featured level editor for supported game titles.</p>
</ul><h1 id="907" name="907" class="book-h1">ICE - Item Configuration Editor</h1><ul><h3>ICE  - Item Configuration Editor</h3>
<p class="q3bg1b"><b>Author</b>: Janus, MTE,. JaB, Blakjack, Pusher, Terak</p>
<p class="q3bg1b"><a href="http://www.fileplanet.com/dl.aspx?/planetquake/spitfire/ice-beta1-2.zip">Download Beta1 Revision2</a><br><a href="http://www.planetquake.com/spitfire/ice/manual/manual.htm">Manual</a><br><a href="http://www.planetquake.com/spitfire/ice.htm">Official Site</a><br><br>ICE is a Quake 3 mod that lets the player change the layout of items and other entities in maps. Originally an acronym for Item Configuration Editor, we just call it ICE now that entities other than items are supported.<br><br>ICE introduces a new gametype, the editor, in which players can add, remove, and move around map items to their satisfaction. These new item layouts can be saved to file and then loaded along with existing maps in the actual game. It can be used to give tired maps a new spark, test item layouts in new maps, or enable other mods with different entities to use vanilla maps without recompiling them.</p></ul><h1 id="908" name="908" class="book-h1">MapProp - Shell Ext for Win Explorer</h1><ul><h3>MapProp - Extension for Win Explorer</h3>
<p class="q3bg1b"><b>Author</b>: Bert Peers</p>
<p class="q3bg1b"><a href="http://www.bpeers.com/software/mapprop/mapprop-2-0-msi.zip">Auto Install Download Version 2</a><br><a href="http://www.bpeers.com/software/mapprop/mapprop-2-0.zip">Manual Install Download Version 2</a><br><a href="http://www.bpeers.com/software/mapprop">Official Site</a><br><br>
MapProp is a Shell Extension for the windows File Explorer. When installed, the Properties... dialog you get for .map files will have a new tab labeled "Preview". On it, you can see a top down view of the map without having to compile it or load it in a level viewer. Tesselating and rendering still takes a while, but overall it is probably a time saver. To look comprehensible, any map element that has "common" anywhere in the texturename, is hidden. Version 2.0 now also features Thumbnail / Webcontent-preview support, quake3 icons for .map files, and experimental Doom3 support.</p></ul><h1 id="890" name="890" class="book-h1">PakScape v0.11 PK3 Explorer</h1><ul><h3>PakScape v0.11 PK3 Navigator</h3>
<p class="q3bg1b"><b>Author</b>: Peter 'Riv' Engstr&ouml;m</p>
<p class="q3bg1b"><a href="http://dl.fileplanet.com/dl/dl.asp?maldavria/pakscape/pakscape-011.zip">Download Via GameSpy</a><br><br>
PakScape is a PAK/PK3/VOL explorer/creator. Since PK3 files are really ZIP files it can also be used as a ZIP explorer/creator. The PAK file formats supported are the formats used by games based on the Quake and Quake2 engines, including (but not limited to) Quake, Quake2, Half-Life, Soldier of Fortune and Daikatana. The VOL file format supported is the format used by the Starsiege and Starsiege Tribes games- and only the uncompressed kind.</p>
<!-- break -->
<p class="q3bg1"><b>Features</b><br>* Multiple Document Interface<br>* Explorer-like UI<br>
* Drag &amp; drop (including to and from Explorer)<br>
* Import/export files and directories</p>
<p class="q3bg1"><b>Bugs/Limitations</b><br>
* When moving objects (files and directories) all of the original objects will be deleted unless you cancel the operation in a   'Confirm Replace' dialog. Answering 'No' will only result in that the destination file is not overwritten- the file to be moved will still be deleted!<br>
* File type descriptions may be wrong for non-registered types unless you have used the file open/save dialog. I have no idea why.<br>
* If you decide to view a document (i.e. either double-click the document or choose 'Open' from the context menu) that is registered to open with PakScape the temporary file created will not be deleted when PakScape closes.</p>
<p class="q3bg1"><b>Technical Information</b><br>
Maximum files in a PAK file: 4096<br>Maximum path in a PAK file:  55 bytes<br>
Maximum files in a PK3 file: 65535<br>Maximum path in a PK3 file:  65535 bytes</p>
<p class="q3bg1"><b>Recommended System</b><br>* 686 300MHz<br>* 32MB free memory</p>
<p class="q3bg1"><b>Minimum System</b><br>* 586 200MHz<br>* 8MB free memory</p>
<p class="q3bg1"><b>Tips and Tricks</b><br>
If you don't have a lot of free memory save the archive directly after you've added a few files. If you don't have a fast processor use normal compression when saving zip/pk3 archives. Maximum compression is a lot slower and normally doesn't compress a whole lot more than normal compression.</p></ul><h1 id="894" name="894" class="book-h1">Particle Studio</h1><ul><h3>Particle Studio</h3>
<p class="q3bg1b"><b>Author</b>: The Freebrief Team</p>
<p class="q3bg1b"><a href="http://www.planetmedalofhonor.com/freebrief/q3a/ps/download/">Download Page</a><br><a href="http://www.planetmedalofhonor.com/freebrief/q3a/ps/book-manual/">Manual</a><br><a href="http://www.planetmedalofhonor.com/freebrief/q3a/ps/">Official Site</a><br><br>
Particle Studio is a freeware tool for Quake III Arena. It allows mappers to create particle systems. Some examples of effects possible with Particle studio are steam, fires, sparks and bubbles. Particle Studio automates an otherwise tedious task. It creates shader and prefab files, and all you have to do is to insert it in your map. That's easy! you'll like it! Quake 3 Arena has no support for ‘real’ particle systems. This program emulates them by using shader FX. Therefore the particle systems created by this tool lack many cool features. Things you can't do include curved paths, collision detection on particles and changing the color of the particles (you can change the brightness and opacity though).</p>
</ul><h1 id="891" name="891" class="book-h1">Pk3Man Q3Radiant Plugin</h1><ul><h3>Pk3Man PK3 Explorer Plugin</h3>
<p class="q3bg1b"><b>Author</b>: Mike 'mickey' Jackman and TTimo</p>
<p class="q3bg1b"><a href="http://download.sourceforge.net/pk3man/pk3man_beta3.zip">New Beta 3 Release</a><br><a href="https://sourceforge.net/projects/pk3man">PK3MAN Project Page</a><br><a href="http://pk3man.sourceforge.net">Official Site</a><br><br>
Pk3Man is a simple Plugin for Q3Radiant 199+ to enable the manipulation and browsing of PK3 files from within Q3Radiant. Its my no means a replacement for apps such as WinZip but it is tailored more to the creation of PK3's for the distribution of Quake3 maps and Mods.</p>
<!-- break --></ul><h1 id="800" name="800" class="book-h1">Q3ASE Shader Maker GUI</h1><ul><h3>Q3ASE</h3>
<p class="q3bg3"><img src="/images/q3ase.jpg" width="96" height="96" hspace="10" align="left"><a href="http://www.bpeers.com/software/q3ase" target="_blank">Official 
  Site</a> - Textures in Quake3:Arena are no longer a simple texture combined with a lightmap, but are fully scripted entities which can be used to control practically every option OpenGL exposes when it comes to texture positioning, transformation, blending and whatnot. To facilitate the creation and editing of such scripts, this tool will parse a script
and present it as a Windows GUI which is easier to understand and navigate than the bare C-like text files.</p>
<UL>
<LI><a href="http://www.bpeers.com/software/q3ase/#background">About Q3ASE</A></LI>
<LI><a href="http://www.bpeers.com/software/q3ase/#doc">Documentation</A></LI>
<LI><a href="http://www.bpeers.com/software/q3ase/#releases">Releases <B>(download)</B></A></LI>
<LI><a href="http://www.bpeers.com/software/q3ase/#credits">Credits</A></LI>
<LI><a href="http://www.bpeers.com/software/q3ase/#links">Links</A></LI>
</UL></p>
</ul><h1 id="797" name="797" class="book-h1">Q3Build - GUI Compiler Front End</h1><ul><h3>Q3Build</h3>
<p class="q3bg3"><img src="/images/q3build.jpg" align="left" hspace="10"><a href="http://q3build.sagnor.com/" target="_blank">Official 
  Site</a> - Q3 Build is a compiler front end for helping you compile your Quake 
  III Arena maps. Its a GUI that writes and executes a batch file and can launch 
  Quake3. Program written by Sagnor and Azrknight. This documentation by raYGunn. 
  Development has pretty much come to a grinding halt on any versions for q3build 
  as I've pretty much had taken a big step away from gaming and designing over 
  the last couple of years. Who knows though maybe someday I'll pick back up on 
  it. Anyways thats all for now. </p>
<p class="q3bg1b">For Q3A and GTKRadiant<br>
  <a href="http://q3build.sagnor.com/get_file.asp?FileID=1" target="_blank">GTKBuild</a> 
  <small>v2.0 Full install</small><br>
  <a href="http://q3build.sagnor.com/get_file.asp?FileID=2" target="_blank">GTKBuild</a> 
  <small>v2.0 Update Minimum files (zipped, Requires VB6 runtimes)</small><br>
  <br>
  For Q3A and Q3Radiant<br>
  <a href="http://q3build.sagnor.com/get_file.asp?FileID=3">Q3Build</a><small> v1.4 Full 
  install </small><br>
  <a href="http://q3build.sagnor.com/get_file.asp?FileID=4">Q3Build</a><small> v1.4 Update 
  Minimum files (zipped, Requires VB6 runtimes)</small><br>
  <br>
  <a href="http://q3build.sagnor.com/readme.txt" target="_blank">readme</a> - 
  <a href="http://q3build.sagnor.com/tool_options.txt" target="_blank">tool_options.txt</a> 
  - <a href="http://www.microsoft.com/downloads/release.asp?releaseid=12704" target="_blank">updated 
  ms runtimes</a></p>
</ul><h1 id="798" name="798" class="book-h1">Q3MAP2 BSP Compiler</h1><ul><h3>Q3Map2</h3>
<p class="q3bg3"><img src="/images/q3map2.jpg" width="96" height="96" hspace="10" align="left"><a href="http://shaderlab.com" target="_blank">Official 
  Site</a> - Q3Map2 is a BSP compiler for Quake 3 engined games. It currently 
  fully supports Quake 3 Arena/Team Arena, Return to Castle Wolfenstien, Star 
  Trek Elite Force, and has partial support for Jedi Knight II and Soldier of 
  Fortune 2.<br>
  <br>
It is designed to replace the Q3Map.exe that comes with QERadiant, GtkRadiant
and GMAX Tempest. However, there are significant enhancements that require
a little twiddling to use, such as faster lighting and enhanced surface
production.</p>
<p class="q3bg1b">Download: <a href="http://shaderlab.com/q3map2/2.5/q3map_2.5.16_win32_x86.zip" target="_blank">Win32 
  x86</a> - <a href="http://shaderlab.com/q3map2/2.5/q3map_2.5.16_linux_x86.tar.gz" target="_blank">Linux 
  x86</a> - <a href="http://shaderlab.com/q3map2/2.3/q3map_2.3.36_darwin_ppc.tar.gz" target="_blank">Darwin/OS 
  X PPC (2.3.36)</a> <br>
  <a href="http://shaderlab.com/q3map2/shader_manual" target="_blank">Q3MAP2 Shader 
  Manual</a> - Obsidian and ydnar <br>
  <a href="http://splashdamage.com" target="_blank">Official Q3MAP2 Forum</a> 
  - Splash Damage<br>
  <a href="http://en.wikibooks.org/wiki/Q3Map2" target="_blank">Q3MAP2 Compiler 
  Wiki</a> - Community<br>
  <a href="http://shaderlab.com/q3map2/2.5/readme.txt" target="_blank">Q3MAP2 
  readme</a></p>
</ul><h1 id="577" name="577" class="book-h2">Compiling</h1><ul><h3>Compiling with Q3MAP2 for Quake 3</h3>
<p class="q3bg1"><b>The first thing you should know</b> about compiling a map into a bsp for quake III arena is that theres another application involved. It's called Q3MAP2 by ydnar. It's a cmd window program that's run using either a command line, a batch file, a GUI or through the bsp menu in GTKRadiant.</p>
<center>- Places of Note -</center>
<p class="q3bg2"><a href="http://www.splashdamage.com/index.php?name=pnPHPbb2&file=viewforum&f=8">SplashDamage - Official Q3Map2 Forum</a><br>
<a href="http://shaderlab.com">Official Q3Map2 Download Location</a> -Shaderlab<br>
<a href="http://en.wikibooks.org/wiki/Q3Map2">Q3MAP2 Compiler Wiki</a><br>
<a href="http://www.shaderlab.com/q3map2/shader_manual">Q3MAP2 Shader Manual</a></p>
<p class="q3bg1"><b>If you're a beginner,</b> there's a few things you should now, before you start. This are important information as it will help keep you from askin silly questions later on. Turning a .map file into a .bsp file for use in Quake III Arena involves two to four stages. The BSP, VIS, LIGHT, and BSPC or BSP2AAS.<br><br>The following sections will break each of these stages down in depth and give you a better grasp of compiling for Quake III. Please be sure to read them carefully, and check the urls above for additional information before posting questions in the <a href="http://forums.gamedesign.net/viewforum.php?f=15&sid=fb58bca8604292b6fa98513d94211d5b">Rust Q3W Forum</a></p>
</ul><h1 id="696" name="696" class="book-h3">The BSP Compile Stage</h1><ul><center>BSP info by William 'SmallPileofGibs' Joseph<br>
edited and added to by skinmaster<br><br>
The Q3 compile process has four stages: BSP, VIS, LIGHT, BSPC.</center><br><br><p class="q3bg2">Stage 1. "BSP" (q3map mapname.map)<br>
mapname.bsp is the format that compiled Q3 levels are stored as. The important part of this process is the actual creation of the BSP Tree from the brushes of a map.</p>
<h3>What does the BSP stage do?</h3>
<p class="q3bg1">The player-navigable space inside the World is split into convex volumes bounded by planes. These convex volumes are called Leaf Nodes. The Leaf Nodes are stored in a binary tree called a BSP Tree.<br><br>Note: The "player-navigable space" inside the World means: everywhere in the game World that isn't a brush which is both solid and structural. The area the player can navigate around in the World using noclip, without passing through a Solid structural Brush. All World Brushes are Solid and structural unless they have a different content property set.<br><br>Non-structural content properties are detail, playerclip, trans. Non-Solid properties are water, lava, nonsolid Detail brushes are set by surfaceparm detail, or by making the brush detail in Radiant (viewing detail brushes is toggled by ctrl+d, viewing structural ctrl+shift+d). Some of the common/ shaders are structural, but not visible, including: common/caulk, common/hint, common/nodrawnonsolid, common/areaportal. The rest are either non-structural, are only used on Entities, or are not commonly used in maps.</p>
<h3>How and why is the BSP created?</h3>
<p class="q3bg2">A map is a 3-dimensional volume of space extending +/- 4096 units from the origin in X Y and Z, containing smaller solid convex volumes bounded by planes (structural brushes). The goal is to use the fewest splits possible to split the space of the map into convex volumes, each of which do not contain any structural brushes.
A simple cube room is a convex volume bounded by six planes. Convex volumes are important for visibility, because it is simple and fast to determine whether two convex volumes can see one another.<br><br>These convex volumes are stored as Leaf Nodes in a binary tree, making it easy to determine which Leaf Node the viewpoint or objects (entities, tris, patches) are in. This is called a Binary Space Partitioning Tree, or BSP Tree.<br><br>A BSP tree is produced using a recursive operation. A recursive operation is one that causes itself to repeat within itself. The operation is performed on a Volume, starting with the entire map as a single Volume: If the Volume contains structural Brushes... Then split the volume along the Plane of the Face of one structural Brush. Continue to the first child Volume produced and repeat the operation.<br><br>Else, if the Volume does not contain structural Brushes, it contains no Planes for splitting, and a Leaf Node is created for the volume. Then return to the next child Volume up the tree and repeat the operation. If there is no child Volume, end the operation.<br><br>Note: Each split-plane does not always divide the volume exactly in half. Axial split-planes are chosen before non-axial split-planes.<br><br>The split-plane which cuts through the maximum number of brushes is chosen. It is important to split the tree roughly in half each time in order that each Leaf Node is roughly the same distance from the tree's root, balancing the branches of the tree.</p>
<h3>How can I control the BSP splits?</h3>
(a way to use detail and Hint brushes)<br><br>
<p class="q3bg2">ALL structural brush face-planes, Including completely hidden or nodraw faces, are possible candidates to split the BSP and create extra Leaf Nodes. Leaf Nodes are currently NEVER merged, even if the result of the merge would be a new convex leaf. The ideal situation is to have all structural brush faces axial and perpendicular to the grid lines every 128 units. Any more complex brushes can be made detail, and all hidden structural or detail Brush faces can be made nodraw as well, by applying the common/caulk shader. The effect is similar to using Bezier Patch surfaces, which also do not block vis or have any other visible faces than the front surface.<br><br>Hint Brushes are structural, trans, and nonsolid. This means they are totally invisible in a compiled Quake 3 level, but their Face-Planes are used to split the BSP like other structural Brush Face. A large Axial Hint brush face will be an ideal candidate to be used for a BSP Split. Adding Hints with Axial faces (perpendicular to the 128-unit grid lines) aligned with other Axial Planes from structural Brush faces, minimises the number of extra split-Planes and Leaf Nodes.<br><br>Basing a map on the 128-unit grid allows you to hugely simplify the visibility process. If the leaf nodes are all 128-unit cubes, its very easy for the designer to predict whether one area can see into another, and place simple axial hint brushes to reduce visibility with minimal increase in vis pre-processing time. As Detail brushes and bezier patch surfaces do not affect the shape of nodes they can be used to build up complex architecture in front of simple axial structural nodraw brushes</p>
<h3>What is a leak?</h3>
<p class="q3bg1">A quake3 map is a hollow space made up from a number of convex volumes (Leaf Nodes) contained within a solid outer hull. The Leaf Nodes "outside" the map are discarded (pruned =) after the BSP Tree is created. There is a "leak" if you cannot separate the Entities on the inside from the "void" outside the radiant grid. If there is a leak q3map generates a detailed error message (seen if you use q3map -v) and records the path of the leak to the Pointfile "mapname.lin". Usually a leak will be displayed in Radiant as a path from the origin of an entity to a Leaf Node touching the area outside the radiant grid without passing through a solid brush.</p>
<h3>What is the .prt file?</h3>
<p class="q3bg2">The Leaf Nodes remaining in the BSP Tree after the outside Leaf Nodes are removed are bounded either by other nodes or by structural brush faces. A Portal is created for every face of a Leaf Node that is bounded by another Leaf Node. Each Portal is like a window from one node looking outwards into another. The Portal information is not needed in the BSP, but it is essential to VIS, so it is stored in the portal file "mapname.prt". </p>
<h3>How are the brushes/patches turned into triangles?</h3>
<p class="q3bg1">All faces that are "outside" the map (facing the void) are discarded. Hidden areas of brush-faces are discarded. The remaining area of a brush-face must always be a convex polygon, so if only an area in the middle of the face is hidden then no part of the face will be discarded. If two areas separated by a wall are sharing the same brush for a floor, the floor Face will not be split and will be shared between the two rooms.<br><br>
Note: Part of a face is considered hidden if it is covered completely by a brush flush/overlapping with it. Hidden areas are discarded ONLY if they are part of a structural brush-face. Faces hidden on detail brushes are NOT discarded.<br><br>Every remaining face is divided into a separate Triangle Strip to minimise the number of Vertices needed. In order to avoid cracks where T-junctions occur between edges and vertices, edges are split when they touch another triangle vertex. If a vertex lies on an edge that cannot be split, creating a T-junction, there will be a tiny crack in the hull of the map (along the bar of the "T"), known as "sparklies" when something brighter is drawn behind the crack and shows through. <br><br>Bezier Patch Surfaces are treated as a collection of points during the BSP compile, and are turned into triangles when the map is loaded.<br><br>Note: Edges of Brush faces touching a green Patch control-point will be split to avoid a t-junction, creating a vertex.<br><br>Texture coordinates are generated for each vertex. Texture coordinates are two values U and V (UV Coordinates) which specify the location of the vertex on the texture image. These coordinates are normalized decimal values (values between 0 and 1), so the image size in pixels will not affect the shape or size that it appears to be in Q3. Note: each brush-face or patch-surface is a separate mesh with its own vertices, enabling it to have different set of Texture Coordinates and Shader properties.</ul><h1 id="697" name="697" class="book-h3">The BSP Compile Switch List</h1><ul><h3>The BSP Compile Switches</h3>
<p><i>This information is drawn from the Q3MAP2 WIKI</i></p>
.-<strong>custinfoparms</strong><br>
Enables custom surfaceparms for game mods without the need to recompile Q3Map2 itself.<br><br>Custom surfaceparms are stored in custinfoparms.txt, in the "scripts" directory. Custom surfaceparms follow the format: <br>
<p class="q3bg2">{ <br>
surfaceparmName 0x0000 //whatever bitflag is used by your mod for said surfaceparm <br>
}</p><br>
-<strong>debuginset</strong><br>
Enables debugging of surface triangle insetting. //I'm totally not sure what this is? <br><br>

-<strong>debugportals</strong><br>
Draws the portals into the bsp as translucent polygons. Omit -vis and -light for best -debugportals results. <br><br>

-<strong>debugsurfaces</strong><br>
Colors every surface a different color (very trippy). Omit -vis and -light for best -debugsurfaces results. <br><br>

-<strong>fakemap</strong><br>
Creates a new .map file with a blank worldspawn entity and all the world brushes from your original .map file. //Don't know much about this one. <br><br>

-<strong>flares</strong><br>
Used in Raven games to generate coronas on light sources. //Another one that I've never been able to get working. <br><br>

-<strong>flat</strong><br>
Forces all texture coordinates for a given surface to the pixel that best fits the average color of the assigned texture. <br><br>

-<strong>fulldetail</strong><br>
Will cause all detail brushes to be handled as if they were structural. <br><br>

-<strong>leaktest</strong><br>
Will cause Q3Map2 to abort compile if a leak is encountered. <br><br>

-<strong>meta</strong><br>
At one time, there was a clear definition as to what, exactly, the -meta switch did. Now, it has become the "magic" switch that is required for most of Q3Map2's advanced features. Always -meta, and always -v. <br><br>

-<strong>mi</strong> (N)<br>
Sets the maximum per-surface index count to N. <br><br>

-<strong>mv</strong> (N)<br>
Sets the maximum per-surface vertex count to N.<br><br>

-<strong>nocurves</strong><br>
Will not compile patch meshes into the .bsp.<br><br>

-<strong>nodetail</strong><br>
Will not compile detail brushes into the .bsp. <br><br>

-<strong>nofog</strong><br>
Will not compile fog brushes into the .bsp. <br><br>

-<strong>nohint</strong><br>
Will not compile hint brushes into the .bsp. <br><br>

-<strong>nosubdivide</strong><br>
Visible surfaces will not be split. TessSize is ignored. <br><br>

-<strong>notjunc</strong><br>
Will not fix T-Junctions (can cause sparklies and LOD cracks). <br><br>

-<strong>nowater</strong><br>
Will not compile liquid brushes into .bsp. <br><br>

-<strong>np</strong> (shadeangle (1 through 179))<br>
Forces all planar shaders to become nonplanar with the shadeangle specified. <br><br>

-<strong>onlyents</strong><br>
Only changes the entities in the compiled .bsp. Needs a compiled .bsp (as well as a .map) to act as a file-filter. <br><br>

-<strong>patchmeta</strong><br>
Creates meta surfaces from patch meshes. This "bakes" a set LOD into patches in your .bsp. <br><br>

-<strong>samplesize</strong> (N)<br>
Writes the prescribed samplesize argument to the .srf surface file. The .srf file (and thus -samplesize) affects the -light phase of compile. A lower -samplesize value produces more sharply defined lightmaps. The default samplesize is 16; a samplesize value of 4 produces a very high quality compile, suitable to call "final." A samplesize value of 1 would be total overkill, resulting in epochal compile times and immensely bloated .bsp filesize. <br><br>

-<strong>skyfix</strong><br>
Enables fix for buggy ATI GL_CLAMP behavior. Always use this. <br><br>

-<strong>snap</strong><br>
Enables axial bevel plane snapping to reduce clipped model plane count (use with care). <br><br>

-<strong>texrange</strong> (N)<br>
Limits per-surface texel count to N. <br><br>

-<strong>v</strong><br>
Enables verbose mode for the bsp phase. Always use this. <br><br>

-<strong>verboseentities</strong><br>
Outputs more information about compiling entity sub-models into the .bsp.</ul><h1 id="702" name="702" class="book-h3">The BSPC or BSP2AAS Compile Stage</h1><ul><center>BSPC/BSP2AAS info by William 'SmallPileofGibs' Joseph<br>
edited and added to by skinmaster<br><br>
The Q3 compile process has four stages: BSP, VIS, LIGHT, BSPC.</center><br><br><p class="q3bg2">Stage 4. "BSPC" (bspc -bsp2aas mapname.bsp)<br><br>
This stage uses the bspc tool, and generates an Area file mapname.aas. The Area file is used by bots to navigate the map. BSPC is a separate process from the other compile stages, and and it has no effect on and ignores any information created in those stages. BSPC requires only a mapname.bsp which does not leak.</p>

<h3>How does BSPC interpret the map?</h3>
<p class="q3bg1">BSPC uses the Brush Face information in the mapname.bsp to make a list of Faces which clip the bots. Bezier Patches are tessellated into into planar Faces called "curve brushes" and are then treated the same as other Brush Faces. Face content properties which clip bots include: structural (all brushes or curves are structural by default), detail, Trans, playerclip. All Faces which clip the player are considered solid to bots, so they are all treated identically as "solid" and any other content property is forgotten.</p>
<h3>What is the "Brush CSG" stage of BSPC?</h3>
<p class="q3bg1">During this stage unnecessary Brushes are discarded. If any Brush is completely contained within another Brush it will be discarded, by CSG-Subtracting the container brush from the contained brush. The more brushes BSPC ignores the better - use large simple clip brushes to completely contain any complex architecture made from multiple brushes.</p>
<h3>How is the area file created?</h3>
<p class="q3bg1">BSPC splits the bot-navigable space in the map up into convex volumes called Areas, in a process similar to q3map BSP. Each Area must be convex, like the Leaf Nodes in a BSP Tree. BSPC also tries to minimise the number of Areas by merging any two Areas where the result is another convex Area. BSPC stores the Areas in groups called Clusters, in the Area file "mapname.aas". A Cluster is a group of connected Areas, separated from other Clusters by Solid walls or Clusterportals. Without Clusterportals, most maps will have a single large Cluster of Areas.
You can see the Cluster/area info in bspc.log after creating the area file.</p>
<p class="q3bg2">Note: Bot-navigable space in a map is anywhere on the inside that isn't a solid player-clipping brush. Solid player-clipping brush content properties include: solid(default for all brushes unless nonsolid), playerclip. </p>
<h3>How do Bots use the area file?</h3>
<p class="q3bg1">Bots use the Areas in the Area file to navigate between Entities in the map. At any point in time they have to be thinking about all the areas in whichever Cluster they are in. If there are a large number of areas in that Cluster, the bots' cpu usage will be noticeably larger while they are in it. More than 1000 areas in the Cluster gives a very noticable performance hit - below 500 is much better, and the smaller the number of areas in the largest Cluster the better. </p>
<h3>How do I make Clusterportals?</h3>
<p class="q3bg1">Clusterportal Brushes are used to control the way BSPC creates Clusters, by adding potential Clusterportals for BSPC to consider.<br><br>Clusterportal Brushes should not be confused with Areaportal Brushes as there are a few important differences in their use. Clusterportal Brushes should be thin axial brushes, up to 32 units thick. For a Clusterportal brush to be accepted by BSPC as a ClusterPortal it must have two opposite faces touching two separate Clusters. It must be placed in a doorway or a horizontal passage where bots can freely walk through it rather than falling through vertically. The two opposite faces should be identical in shape and size, and the other four faces should be against solid brushes or clip brushes.</p>
<p class="q3bg2">Note: In the same way as Areaportals, Clusterportals must be used to entirely separate parts of the map from each other. If a bot can reach area 2 from area 1 (via any other areas) without passing through a Clusterportal, both areas are connected and will be part of the same Cluster.</p></ul><h1 id="700" name="700" class="book-h3">The LIGHT Compile Stage</h1><ul><center>LIGHT info by William 'SmallPileofGibs' Joseph<br>
edited and added to by skinmaster<br><br>
The Q3 compile process has four stages: BSP, VIS, LIGHT, BSPC.</center><br><br><p class="q3bg2">Stage 3. "LIGHT" (q3map -light mapname.bsp)<br><br>
This is the lighting stage, where lightmaps are generated for every world surface in the map. It has no effect on bsp, hints, vis or r_speeds.</p>

<h3>How do lightmaps work?</h3>
<p class="q3bg1">The Q3map -light algorithm creates a lightmap pixel for every 16 game world units on a brush, and every 20 units on a patch, stored in 128*128 pages.<br><br>The lightmaps are 24bit RGB, and are blended with the textures by multiplying the lightmap RGB values with the RGB values of the texture (see the Shader Manual: blendfunc filter).</p>
<h3>How are lightmaps generated?</h3>
<p class="q3bg1">All lightmap pixels start pure black (RGB 0 0 0). A straight line is traced from the centre of each lightmap pixel towards the origin of each point light source. The distance between the pixel and the light source decides the brightness the light adds to the RGB values of that pixel. If the line is blocked by any visible non-transparent brush, the light source does not have any effect on the lightmap pixel.<br><br>The time taken by the LIGHT stage is proportional the number of lightmap pixels multiplied by the number of point light sources.</p>
<h3>What about surface lights?</h3>
<p class="q3bg1">Surface lights are subdivided using the q3map_lightsubdivide value (default 64), creating a point light source on the surface every 64 units. These are used in the light calculations in the same way as other point light sources.</p>
<h3>What does -extra do?</h3>
<p class="q3bg1">Using the -extra option a straight line is traced from four extra points on each lightmap pixel in addition to the original one. The average of the result is taken, which helps to smooth out jagged shadows. Unfortunately it also makes -light take five times as long.</ul><h1 id="701" name="701" class="book-h3">The LIGHT Compile Switch List</h1><ul><h3>The LIGHT Compile Switches</h3>
<p><i>This information is drawn from the Q3MAP2 WIKI</i></p>
-<strong>areascale</strong> (N.N)<br>
Scales up area (shader) lights by the prescribed factor. Q3Map2 -light -areaScale 0.25 will result in area lights that are only 25% as bright as those in a .bsp compiled with -light -areaScale 1.0. <br><br>
-<strong>approx</strong> (N)<br>
Approximates lightmaps within a byte tolerance of N. Q3Map2 -light -approx forces simple surfaces without much shadow detail to be vertex lit, thus saving lightmaps. The range is from 0-255, 0 being default (no approximation). <br><br>
-<strong>border</strong><br>
Creates a debugging border around each lightmap. <br><br>
-<strong>bounce</strong> (N)<br>
Enables Q3Map2 radiosity, calculating radiosity light through N bounces. <br><br>
-<strong>bouncegrid</strong><br>
Allows bounced light to affect the lightgrid. <br><br>
-<strong>bouncescale</strong> (N.N)<br>
Scales up radiosity lights by the prescribed factor. <br><br>
-<strong>cheap</strong><br>
Stops Q3Map2 from calculating light on a sample after it exceeds (255, 255, 255). This may produce odd artifacts on maps with lots of saturated colored lighting. Also, do not use cheap with radiosity if you want to preserve all the emitted light. <br><br>
-<strong>cheapgrid</strong><br>
Stops Q3Map2 from calculating light on a sample after it exceeds (255, 255, 255), but only for the lightgrid. <br><br>
-<strong>compensate</strong> (N.N)<br>
Scales back lightmap values to adjust for overbrighting when -gamma is used. For Quake III: Arena, a good compensate value is 4, though some experimentation may be needed to find an aesthetic that suits your particular map. <br><br>
-<strong>cpma</strong><br>
Enables brand spanking new asstastic vertexilicious cpma-styled lighting. Use of this switch leads to much pie. <br><br>
-<strong>dark</strong><br>
Enables darkening of lightmaps at brush/lightmap seams. Sort of like a half-assed occlusion pass, ends up looking a bit Unreal 1-ish. Very subtle. <br><br>
-<strong>debug</strong><br>
Enables lightmap debugging. <br><br>
-<strong>debugaxis</strong><br>
Colors lightmaps based on their projection axis. <br><br>
-<strong>debugcluster</strong><br>
Colors lightmaps based on the PVS cluster the luxel falls into. <br><br>
-<strong>debugorigin</strong><br>
Colors lightmaps based on the luxel origin relative to the raw lightmap's bounding box. <br><br>
-<strong>debugunused</strong><br>
Colors unused luxels hot pink. <br><br>
-<strong>dump</strong><br>
Dumps radiosity lights into numbered prefabs. <br><br>
-<strong>fast</strong><br>
Enables light envelopes for area (shader) lights. This includes radiosity lights. Results in a much quicker -light compiles, but darkens all enveloped light sources considerably—this can be compensated for easily by raising your surfacelight values.  Do not be confused by the "fast" nomenclature... -fast is perfectly suitable for "final" compiles. <br><br>
-<strong>fastbounce</strong><br>
Enables -fast style calculations, but only for radiosity lights. <br><br>
-<strong>faster</strong><br>
Enables -faster light calculation.<br><br>
-<strong>fastgrid</strong><br>
Enables -fast style calculations, but only for the lightgrid. <br><br>
-<strong>filter</strong><br>
Applies a gaussian blur to lightmaps, smoothing out shadows. Sounds good in theory, but -filter doesn't play nice with a lot of the more interesting effects... don't use it. Use -samples instead. <br><br>
-<strong>gamma</strong> (N.N)<br>
Creates a more realistic color ramp between "light" and "dark." Good values are in the 1.4-2.2 range. Games that use r_overBrightBits and r_mapOverBrightBits (Quake III: Arena, most notably) will need those cvars disabled unless -compensate is used accordingly. <br><br>
-<strong>lightmapsize</strong> (N)<br>
Limits the lightmap size. <br><br>
-<strong>lomem</strong><br>
Trades increased compile time for decreased memory usage. If you are getting safe_malloc errors (or just running out of RAM), try this switch. <br><br>
-<strong>nocollapse</strong><br>
Disables collapsing of identical lightmaps. This switch is required for Q3Map2 lightstyles. <br><br>
-<strong>nogrid</strong><br>
Disables calculation of the lightgrid. <br><br>
-<strong>normalmap</strong><br>
Colors lightmaps based on the facings of their vertex normals. <br><br>
-<strong>nosurf</strong><br>
Disables the surface tracing of detail brushes and patch meshes for shadow casting. <br><br>
-<strong>notrace</strong><br>
No light tracing is performed. As a result, no shadows will be cast. <br><br>
-<strong>novertex</strong><br>
Disables the calculation of vertex lighting. <br><br>
-<strong>patchshadows</strong><br>
Enables the casting of shadows by patch meshes. <br><br>
-<strong>pointscale</strong> (N.N)<br>
Scales up point (entity) lights by the prescribed factor. <br><br>
-<strong>samples</strong> (N)<br>
Enables intelligent antialiasing of shadow edges in lightmaps. A value of 2 both looks good and compiles quickly, while a value of 3 looks great but compiles somewhat more slowly. <br><br>
-<strong>scale</strong> (N.N)<br>
Scales up all light sources by the precribed factor. <br><br>
-<strong>sky</strong> (N.N)<br>
Scales up all sun/sky light sources by the prescribed factor. In this new era of -gamma -compensate, -sky 3 can allow "old style" sky shaders to be used without manually rewriting them. <br><br>
-<strong>sunonly</strong><br>
Computes sun/sky light only, no other light sources. <br><br>
-<strong>super</strong> (N)<br>
Enables arbitrarily ordered grid supersampling of lightmaps. This is much, much, much slower than -samples, by the way. <br><br>
-<strong>thresh</strong> (N.N)<br>
Sets the recursive triangle subdivision threshhold. The range is 0.0-1.0. //I don't know much about -thresh. <br><br>
-<strong>v</strong><br>
Enables verbose mode. Always use this. </ul><h1 id="698" name="698" class="book-h3">The VIS Compile Stage</h1><ul><center>VIS info by William 'SmallPileofGibs' Joseph<br>
edited and added to by skinmaster<br><br>
The Q3 compile process has four stages: BSP, VIS, LIGHT, BSPC.</center><br><br>
<p class="q3bg2">Stage 2. "VIS" (q3map -vis mapname.bsp) bsp_fullvis<br><br>
VIS is short for Visibility. The relevant part of this process is the creation of the PVS Table for the Portals in the map.
As the player's viewpoint moves around a FULLY vis'ed bsp different areas become visible or hidden, depending on which area the viewpoint is in.</p>
<h3>How is the PVS created? </h3>
<p class="q3bg2">Every Portal in the portal file is checked against every other Portal for visibility. Portal 1 is visible to Portal 2 if a straight line of sight can be drawn between any part of Portal 1 and Portal 2 without passing through a solid structural brush. Every Portal then gets a list of the other Portals that can be seen from it. This information is the Potentially Visible Set and is stored in the PVS Table. </p>
<h3>What does -vis -fast do? </h3>
<p class="q3bg2">Otherwise know as "bsp_fastvis", using the -vis -fast option does not create a PVS, leaving every Portal visible to every other Portal.</p>
<h3>How do Portals affect visibility?</h3>
<p class="q3bg2">Every Leaf Node has one or more Portals (unless there is only one node in the BSP tree). If a Portal belonging to Node 1 can see a Portal belonging to Node 2, Node 1 is visible to Node 2. When the player Viewpoint is anywhere in Node 1, every object in Node 2 is drawn. When the player Viewpoint is in Leaf Node x, every object in every other Leaf Node visible from x will be drawn.<br><br>Objects include Brush Faces, Bezier Patches, Entities. One object can be in more than one Leaf Node at the same time. A Brush Face is drawn when any part of the face is touching a visible Leaf Node. A Bezier patch is drawn when any of its control points are touching a visible Leaf Node.
An entity is drawn when any part of its bounding box is touching a visible Leaf Node.<br><br>
To summarise: Effectively, solid structural brushes block visibility between the contents of Leaf Nodes. Curves, detail brushes and Entities do not block visibility. Visibility between two areas will only be blocked when both areas are completely hidden from each other. Generally, the more Leaf Nodes visible from the Leaf containing the Viewpoint, the more objects will be drawn. The aim when optimising for visibility, is to have the smallest number of other Leaf Nodes visible from any one Leaf Node.<br><br>More of the map will be drawn if the BSP has a small number of large leaf Nodes, or an innefficient arrangement of Leaf Nodes. You can reduce the number of Leaf Nodes created by reducing the number of unique structural Planes in the map, by making all unnecessary structural Face-Planes into detail Brushes. You can control visibility by placing Hints to create the Leaf Nodes and their Portals exactly where you want them to be, splitting the space into more Leaf Nodes only in areas where they are needed.</p>
<h3>How can I make VIS more efficient?</h3>
<p class="q3bg2">The time -vis takes is roughly proportional to the number of Portals in the map. The number of portals is displayed when you start VIS, as "numportals xxxx". The visdatasize is the size the PVS table takes up in the mapname.bsp file - this is limited to around 2MB.<br><br>A lot of Leaf Nodes means a lot of Portals. A lot of Portals means a long vis time. The number of Leaf Nodes depends entirely on the complexity of the BSP.  Solution: detail brushes - Making a brush detail will stop it from affecting the BSP Tree, reducing the number of Leaf Nodes formed.
To make any brush a detail brush, select it and press ctrl+m or Selection > Make detail. Toggle viewing of detail brushes with ctrl+D or use the View > Show menu.<br><br>The drawback of wide use of detail is that over-simplifying the Leaf Nodes can hurt your visibility efficiency (see visibility summary). Solution: HINT brushes - A Hint brush (common/hint) will be invisible in Q3, but is structural, so it will affect the BSP Tree and create more Leaf Nodes. This gives you a lot of control over WHERE the Leaf Nodes are created. Placing a hint brush in an area of open space will force creation of a Leaf Node within the area of that hint brush. Hints can also intersect with other structural solid brushes or Hints, creating multiple Leaf Nodes or isolating groups of Leaf Nodes. Hint brushes use a shader which makes the brushes nonsolid and nodraw, called common/hint.<br><br>Hints are best used to make large axial cuts along planes shared by other structural brushes, to maximise the amount of area hidden by each vis-blocking structural brush, by minimising the number and size of the Leaf Nodes visible. <br><br>Intelligent use of detail and Hint brushes in combination can reduce vis time and r_speeds in almost any map. However the map must be designed from the start with this in mind. Redoing an inneffiently made map is a lot of work. <br><br>Note: Making a brush detail will stop it from blocking visibility, so don't make your vis-blocking walls into detail brushes.</ul><h1 id="699" name="699" class="book-h3">The VIS Compile Switch List</h1><ul><h3>The VIS Compile Switches</h3>
<p><i>This information is drawn from the Q3MAP2 WIKI</i></p>
-<strong>fast</strong><br>
Only calculates rough visibility data. Quick and dirty, not actually useful for VIS purposes. <br><br>

-<strong>hint</strong><br>
Will merge the bsp leaves (except for hint portals) before calculating the visiblity list. <br><br>

-<strong>merge</strong><br>
Will merge the bsp leaves before calculating the visibility list. <br><br>

-<strong>nopassage</strong><br>
Disables the passage visiblity algorithm. Passage VIS is a bit faster and tighter than the old algorithm. <br><br>

-<strong>nosort</strong><br>
Disables the sorting of portals by complexity. Sorting speeds up visiblity calculations. <br><br>

-<strong>passageonly</strong><br>
Will use the passage visibility algorithm only. <br><br>

-<strong>nohint</strong><br>
Omits hint brushes from visibility calculations. <br><br>

-<strong>saveprt</strong><br>
Disables the automatic deletion of the .prt portal file after VIS finishes.<br><br>
-<strong>v</strong><br>
Enables verbose mode. Always use this. </ul><h1 id="906" name="906" class="book-h1">Q3ME - Quake 3 Map Explorer</h1><ul><h3>Q3ME - Map Explorer</h3>
<p class="q3bg1b"><b>Author</b>: Lanzelot</p>
<p class="q3bg1b"><a href="http://www.planetquake.com/hro/webs/files.htm">Download Thanks to HR0</a><br>No Official Site<br><br>
Part of the fun of making maps to Quake III Arena (Q3A) is that the technical aspect of level editing is as smooth as possible. Q3Map Explorer (Q3ME) was built for making it as easy as possible to compile the map file, but still enable advanced mappers the freedom to edit the command lines generated by the program. This program helps you to compile your map, but you still need to understand the compiler process to optimize your map.</p></ul><h1 id="796" name="796" class="book-h1">QERadiant/GTKRadiant Level Editor</h1><ul><h4>Q3Radiant/GTKRadiant Map Editor</h4><p class="q3bg3"><img src="/images/qeradiant.jpg" align="left" hspace="10" alt="QERadiant GTKRadiant Radiant" title="QERadiant GTKRadiant Radiant"><a href="http://www.qeradiant.com">Official Site</a>
-  The latest: (GtkRadiant 1.5.0 beta - build 08-17) this was on August 18th 01:29:25 PM 2004. I personally haven't needed to update my editor from 1.4 but i'm certain the new version is coming along nicely. Here is some useful links for QERadiant related stuff. GTKRadiant is the preferred application for editing Quake III maps. If you're interested in learning mapping, GTKRadiant is the place to start. Be certain however that you have a full install of Quake III Arena on your system and have <a href="/book/view/680">patched Q3</a> up to the version that suits you. <a href="/book/view/602">1.32</a> is the most up-to-date patch and <a href="/book/view/680">OFX Q3Switcher</a> will let you skip Quake III versions at a click if you want to move back and forth between servers with different protocols.</p>
<p class="q3bg1">USEFUL INFO - Any GtkRadiant release has a major and minor number. In GtkRadiant 1.2.9.. the major version is 2 and the minor is 9 (1 is there.. just to complicate things).<br><br>The major version is incremented only when important new features are added to GTKRadiant. It means that the first releases for a new editor major will be beta testing versions, until everything is settled and we declare it 'stable'. You can have several install-ations with different major version working independently on your computer. This allows to have the stable release, and the test version at the same time. <br><br>The minor version is incremented at each new release. In many cases the package is an update over your current installation. You should always be using the latest minor for the current editor major that you have, as those are bringing in bug fixes and small functionality tweaks. <br><br>The difference between a full package and an update: Since we release new versions often, we want to keep the downloads small, so we provide &lt;major&gt;.&lt;minor&gt;-update packages, which require that you have a working installation with the given major already. You can locate updates for your current version easily by using the 'Check for updates' in the Files menu, or by sing the update selector.</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td width="50%" class="q3bg1b"> - <a href="http://www.qeradiant.com/?data=dlselect">Download 
Selector</a><br>- <a href="http://www.qeradiant.com/?data=news">QERadiant News</a><br>-  <a href="http://www.qeradiant.com/?data=news/archives">Archived News</a><br>- <a href="http://www.qeradiant.com/?data=files">Public Files</a><br>- <a href="http://www.qeradiant.com/?data=editors/q3r">Q3Radiant Misc. Info</a><br>- <a href="http://www.qeradiant.com/wikifaq/">Radiant Editing FAQ</a></td><td width="50%" class="q3bg1b">- <a href="http://www.qeradiant.com/?data=editors/gtk">GtkRadiant Main Page</a><br>- <a href="http://www.qeradiant.com/?data=editors/gtk">GTKRadiant</a><br>- <a href="http://www.qeradiant.com/?data=dlupdate">GTKRadiant Update check</a><br>- <a href="http://www.qeradiant.com/manual/">Users Manual</a><br>- <a href="http://www.qeradiant.com/?data=games/quake3">Editing Info For Quake III</a><br>- <a href="http://www.qeradiant.com/?data=bugreport">Submit Editor Bugs</a></td></tr></table></ul><h1 id="760" name="760" class="book-h2">Entities (Function)</h1><ul><h2>Function Entities</h3>
<p class="q3bg1b">The "brush" is the basic building block of Quake engine. A single brush or a linked grouping of brushes can be turned into a brush entity. Brush entities include the mover/moving func entities, push and teleport triggers, and func_statics.<br><br>
Be sure to visit <a href="http://www.qeradiant.com/manual/Q3Rad_Manual/ch08/pg8_1.htm#entitywin">this page of the Radiant editor manual</a> in order to better understand working with entities. After learning the ins and outs of working with Quake III entities, return here and learn more about each entity.</p></ul><h1 id="761" name="761" class="book-h3">func_bobbing</h1><ul><h3>func_bobbing</h3>
<p class="q3bg1b">Bobbing is a solid entity that oscillates back and forth or up and down in a linear motion. By default, it will have an amount of displacement in either direction equal to the dimension of the brush in the axis in which it's bobbing. Entity bobs on the Z axis (up-down) by default. It can also emit sound if the "noise" key is set. Will crush the player when blocked.</p><!--break-->
<h3>Bobbing Entity Keys</h3>
<p class="q3bg2"><b>speed</b> : amount of time in seconds for one complete oscillation cycle (default 4).</p>
<p class="q3bg2"><b>height</b> : sets the amount of travel of the oscillation movement (default 32).</p>
<p class="q3bg2"><b>phase</b> : sets the start offset of the oscillation cycle. Values must be 0 > phase < 1. Any integer phase value is the same as no offset (default 0).</p>
<p class="q3bg2"><b>noise</b> : path/name of .wav file to play. Use looping sounds only (eg. sound/world/drone6.wav - See Notes).</p>
<p class="q3bg2"><b>model2</b> : path/name of model to include (eg: models/mapobjects/jets/jets01.md3).</p>
<p class="q3bg2"><b>origin</b> : alternate method of setting XYZ origin of sound and .md3 model included with entity (See Notes).</p>
<p class="q3bg2"><b>light</b> : constantLight radius of .md3 model included with entity. Has no effect on the entity's brushes (default 0).</p>
<p class="q3bg2"><b>color</b> : constantLight color of .md3 model included with entity. Has no effect on the entity's brushes (default 1 1 1).</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in "Free for all" and "Tournament" modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in "Teamplay" and "CTF" modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<h3>Bobbing Q3MAP2 keys</h3>
<p class="q3bg2"><b>_targetname</b> : Used to attach a misc_model entity to this entity.</p>
<p class="q3bg2"><b>_lightmapscale</b> : Floating point value scaling the resolution of lightmaps on brushes/patches in this entity (default 1.0).</p>
<p class="q3bg2"><b>_cs OR _castshadows</b> : Allows per-entity control over shadow casting. Defaults to 0 on entities, 1 on world. 0 = no shadow casting. 1 = cast shadows on world. > 1 = cast shadows on entities with _rs (or _receiveshadows) with the corresponding value, AND world. Negative values imply same, but DO NOT cast shadows on world.</p>
<p class="q3bg2"><b>_rs OR _receiveshadows</b> : Allows per-entity control over shadow reception. Defaults to 1 on everything (world shadows). 0 = receives NO shadows. > 1 = receive shadows only from corresponding keyed entities (see above) and world. < 1 = receive shadows ONLY from corresponding keyed entities.</p>
<p class="q3bg2"><b>_celshader</b> : Sets the cel shader used for this geometry. Note: omit the "textures/" prefix.</p>
<h3>Bobbing Q3MAP2 Terrain Keys</h3>
<p class="q3bg2"><b>_indexmap OR alphamap</b> : Path/name for the art file used to guide the mapping of textures on the terrain surface.</p>
<p class="q3bg2"><b>_layers OR layers</b> : Integer value is the number unique root shaders that will be use on the terrain.</p>
<p class="q3bg2"><b>_shader OR shader </b>: Path to the metashader used to assign textures to the terrain entity. Note: Omit the "textures/" prefix.</p>
<h3>Bobbing Spawnflags</h3>
<p class="q3bg2"><b>X_AXIS</b> : entity will bob along the X axis.</p>
<p class="q3bg2"><b>Y_AXIS</b> : entity will bob along the Y axis.</p>
<h3>Bobbing Notes</h3>
<p class=q3bg1b>In order for the sound to be emitted from the entity, it is recommended to include a brush with an origin shader at its center, otherwise the sound will not follow the entity as it moves. Setting the origin key is simply an alternate method to using an origin brush. When using the model2 key, the origin point of the model will correspond to the origin point defined by either the origin brush or the origin coordinate value.<br><br>Target this entity with a misc_model to have the model attached to the entity (set the model's "target" key to the same value as this entity's "targetname").</p></ul><h1 id="762" name="762" class="book-h3">func_button</h1><ul><h3>func_button</h3>
<p class="q3bg1b">When a button is touched by a player, it moves in the direction set by the "angle" key, triggers all its targets, stays pressed by an amount of time set by the "wait" key, then returns to it's original position where it can be operated again. </p><!--break-->
<h3>Button Entity Keys</h3>
<p class="q3bg2"><b>angle</b> : determines the direction in which the button will move (up = -1, down = -2).</p>
<p class="q3bg2"><b>target</b> : all entities with a matching targetname will be triggered.</p>
<p class="q3bg2"><b>speed</b> : speed of button's displacement (default 40).</p>
<p class="q3bg2"><b>wait</b> : number of seconds button stays pressed (default 1, -1 = return immediately).</p>
<p class="q3bg2"><b>lip</b> : lip remaining at end of move (default 4 units).</p>
<p class="q3bg2"><b>health</b> : (default 0) if set to any non-zero value, the button must take damage (any amount) to activate.</p>
<p class="q3bg2"><b>light</b> : constantLight radius of .md3 model included with entity. Has no effect on the entity's brushes (default 0).</p>
<p class="q3bg2"><b>color</b> : constantLight color of .md3 model included with entity. Has no effect on the entity's brushes (default 1 1 1). 
<p class="q3bg2"><b>model2</b> : path/name of model to include (eg: models/mapobjects/pipe/pipe02.md3).</p>
<p class="q3bg2"><b>origin</b> : alternate method of setting XYZ origin of .md3 model included with entity (See Notes).</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in "Free for all" and "Tournament" modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in "Teamplay" and "CTF" modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<h3>Button Q3MAP2 Keys</h3>
<p class="q3bg2"><b>_targetname</b> : Used to attach a misc_model entity to this entity.</p>
<p class="q3bg2"><b>_lightmapscale</b> : Floating point value scaling the resolution of lightmaps on brushes/patches in this entity (default 1.0).</p>
<p class="q3bg2"><b>_cs OR _castshadows</b> : Allows per-entity control over shadow casting. Defaults to 0 on entities, 1 on world. 0 = no shadow casting. 1 = cast shadows on world. > 1 = cast shadows on entities with _rs (or _receiveshadows) with the corresponding value, AND world. Negative values imply same, but DO NOT cast shadows on world.</p>
<p class="q3bg2"><b>_rs OR _receiveshadows</b> : Allows per-entity control over shadow reception. Defaults to 1 on everything (world shadows). 0 = receives NO shadows. > 1 = receive shadows only from corresponding keyed entities (see above) and world. < 1 = receive shadows ONLY from corresponding keyed entities.</p>
<p class="q3bg2"><b>_celshader</b> : Sets the cel shader used for this geometry. Note: omit the "textures/" prefix. </p>
<h3>Button Q3MAP2 Terrain Keys</h3>
<p class="q3bg2"><b>_indexmap OR alphamap</b> : Path/name for the art file used to guide the mapping of textures on the terrain surface. </p>
<p class="q3bg2"><b>_layers OR layers</b> : Integer value is the number unique root shaders that will be use on the terrain. </p>
<p class="q3bg2"><b>_shader OR shader</b> : Path to the metashader used to assign textures to the terrain entity. Note: Omit the "textures/" prefix. </p>
<h3>Button Notes</h3>
<p class="q3bg1b">Setting the origin key is simply an alternate method to using an origin brush. When using the model2 key, the origin point of the model will correspond to the origin point defined by either the origin brush or the origin coordinate value.  Target this entity with a misc_model to have the model attached to the entity (set the model's "target" key to the same value as this entity's "targetname").</p></ul><h1 id="763" name="763" class="book-h3">func_door</h1><ul><h3>func_door</h3>
<p class="q3bg1b">Normal sliding door entities. By default, the door entity will activate when player walks close to it or when damage is inflicted to it. Doors can be used in many ways in Q3, not specifically for a "door", they can be used to make traps, popup effects and other very useful things us mappers love so much.</p><!--break-->
<h3>Door Entity Keys</h3>
<p class="q3bg2"><b>angle</b> : determines the opening direction of door (up = -1, down = -2).</p>
<p class="q3bg2"><b>speed</b> : determines how fast the door moves (default 100).</p>
<p class="q3bg2"><b>wait</b> : number of seconds before door returns (default 2, -1 = return immediately).</p>
<p class="q3bg2"><b>lip</b> : lip remaining at end of move (default 8).</p>
<p class="q3bg2"><b>targetname</b> : if set, a func_button or trigger is required to activate the door.</p>
<p class="q3bg2"><b>health</b> : (default 0) if set to any non-zero value, the button must take damage (any amount) to activate.</p>
<p class="q3bg2"><b>dmg</b> : damage to inflict on player when he blocks operation of door (default 4). Door will reverse direction when blocked unless CRUSHER spawnflag is set.</p>
<p class="q3bg2"><b>team</b>: assign the same team name to multiple doors that should operate together (see Notes).</p>
<p class="q3bg2"><b>light</b> : constantLight radius of .md3 model included with entity. Has no effect on the entity's brushes (default 0).</p>
<p class="q3bg2"><b>color</b> : constantLight color of .md3 model included with entity. Has no effect on the entity's brushes (default 1 1 1).</p>
<p class="q3bg2"><b>model2</b> : path/name of model to include (eg: models/mapobjects/pipe/pipe02.md3).</p>
<p class="q3bg2"><b>origin</b> : alternate method of setting XYZ origin of .md3 model included with entity (See Notes).</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in "Free for all" and "Tournament" modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in "Teamplay" and "CTF" modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<h3>Door Q3MAP2 Keys</h3>
<p class="q3bg2"><b>_targetname</b> : Used to attach a misc_model entity to this entity.</p>
<p class="q3bg2"><b>_lightmapscale</b> : Floating point value scaling the resolution of lightmaps on brushes/patches in this entity (default 1.0).</p>
<p class="q3bg2"><b>_cs OR _castshadows</b> : Allows per-entity control over shadow casting. Defaults to 0 on entities, 1 on world. 0 = no shadow casting. 1 = cast shadows on world. > 1 = cast shadows on entities with _rs (or _receiveshadows) with the corresponding value, AND world. Negative values imply same, but DO NOT cast shadows on world.</p>
<p class="q3bg2"><b>_rs OR _receiveshadows</b> : Allows per-entity control over shadow reception. Defaults to 1 on everything (world shadows). 0 = receives NO shadows. > 1 = receive shadows only from corresponding keyed entities (see above) and world. < 1 = receive shadows ONLY from corresponding keyed entities.</p>
<p class="q3bg2"><b>_celshader</b> : Sets the cel shader used for this geometry. Note: omit the "textures/" prefix.</p>
<h3>Door Q3MAP2 Terrain Keys</h3>
<p class="q3bg2"><b>_indexmap OR alphamap</b> : Path/name for the art file used to guide the mapping of textures on the terrain surface.</p>
<p class="q3bg2"><b>_layers OR layers</b> : Integer value is the number unique root shaders that will be use on the terrain.</p>
<p class="q3bg2"><b>_shader OR shader</b> : Path to the metashader used to assign textures to the terrain entity. Note: Omit the "textures/" prefix.</p>
<h3>Door Spawnflags</h3>
<p class="q3bg2"><b>START_OPEN</b> : the door will spawn in the open state and operate in reverse.</p>
<p class="q3bg2"><b>CRUSHER</b> : door will not reverse direction when blocked and will keep damaging player until he dies or gets out of the way.</p>
<h3>Door Notes</h3>
<p class="q3bg1b">Unlike in Quake 2, doors that touch are NOT automatically teamed. If you want doors to operate together, you have to team them manually by assigning the same team name to all of them. Setting the origin key is simply an alternate method to using an origin brush. When using the model2 key, the origin point of the model will correspond to the origin point defined by either the origin brush or the origin coordinate value. Target this entity with a misc_model to have the model attached to the entity (set the model's "target" key to the same value as this entity's "targetname").</p></ul><h1 id="764" name="764" class="book-h3">func_group</h1><ul><h3>func_group</h3>
<p class="q3bg1b">This is not an entity as such. It is strictly an editor utility to group world brushes and patches together for convenience (selecting, moving, copying, etc). You cannot group entities with this.<br><br>Grouping is also useful for light casting more detailed lightmaps or lightstyles on specific groups of brushes and/or patches.</p><!--break-->
<h3>Group Q3MAP2 Keys</h3>
<p class="q3bg2"><b>_lightmapscale</b> : Floating point value scaling the resolution of lightmaps on brushes/patches in this entity (default 1.0).</p>
<p class="q3bg2"><b>_cs OR _castshadows</b> : Allows per-entity control over shadow casting. Defaults to 0 on entities, 1 on world. 0 = no shadow casting. 1 = cast shadows on world. > 1 = cast shadows on entities with _rs (or _receiveshadows) with the corresponding value, AND world. Negative values imply same, but DO NOT cast shadows on world.</p>
<p class="q3bg2"><b>_rs OR _receiveshadows</b> : Allows per-entity control over shadow reception. Defaults to 1 on everything (world shadows). 0 = receives NO shadows. > 1 = receive shadows only from corresponding keyed entities (see above) and world. < 1 = receive shadows ONLY from corresponding keyed entities.</p>
<p class="q3bg2"><b>_celshader</b> : Sets the cel shader used for this geometry. Note: omit the "textures/" prefix.</p>
<h3>Group Q3MAP2 Terrain Keys</h3>
<p class="q3bg2"><b>_indexmap OR alphamap</b> : Path/name for the art file used to guide the mapping of textures on the terrain surface.</p>
<p class="q3bg2"><b>_layers OR layers</b> : Integer value is the number unique root shaders that will be use on the terrain.</p>
<p class="q3bg2"><b>_shader OR shader</b> : Path to the metashader used to assign textures to the terrain entity. Note: Omit the "textures/" prefix.</p>
<h3>Group Notes</h3>
<p class="q3bg1b">The TAB key can be used to flip through the component pieces of a selected func_group entity, isolating individual components. To make a func_group into a terrain entity, refer to the Terrain Construction documentation.</p></ul><h1 id="765" name="765" class="book-h3">func_pendulim</h1><ul><h3>func_pendulim</h3>
<p class="q3bg1b">Solid entity that creates a pendulum back and forth rotation movement. Rotates on the X axis by default. Pendulum frequency is a physical constant based on the length of the beam and gravity. Blocking the pendulum instantly kills a player.</p><!--break-->
<h3>Pendulim Keys</h3>
<p class="q3bg2"><b>angle</b> : angle offset of axis of rotation from default X axis (default 0).</p>
<p class="q3bg2"><b>speed</b> : angle of swing arc in either direction from initial position (default 30).</p>
<p class="q3bg2"><b>phase</b> : sets the start offset of the swinging cycle. Values must be 0 < phase < 1. Any integer phase value is the same as no offset (default 0).</p>
<p class="q3bg2"><b>noise</b> : path/name of .wav file to play. Use looping sounds only (eg. sound/world/drone6.wav).</p>
<p class="q3bg2"><b>model2</b> : path/name of model to include (eg: models/mapobjects/jets/jets01.md3).</p>
<p class="q3bg2"><b>origin</b> : alternate method of setting XYZ origin of entity's rotation axis and .md3 model included with entity (default "0 0 0" - See Notes).</p>
<p class="q3bg2"><b>light</b> : constantLight radius of .md3 model included with entity. Has no effect on the entity's brushes (default 0).</p>
<p class="q3bg2"><b>color</b> : constantLight color of .md3 model included with entity. Has no effect on the entity's brushes (default 1 1 1).</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in "Free for all" and "Tournament" modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in "Teamplay" and "CTF" modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<h3>Pendulim Q3MAP2 Keys</h3>
<p class="q3bg2"><b>_targetname</b> : Used to attach a misc_model entity to this entity.</p>
<p class="q3bg2"><b>_lightmapscale</b> : Floating point value scaling the resolution of lightmaps on brushes/patches in this entity (default 1.0).</p>
<p class="q3bg2"><b>_cs OR _castshadows</b> : Allows per-entity control over shadow casting. Defaults to 0 on entities, 1 on world. 0 = no shadow casting. 1 = cast shadows on world. > 1 = cast shadows on entities with _rs (or _receiveshadows) with the corresponding value, AND world. Negative values imply same, but DO NOT cast shadows on world.</p>
<p class="q3bg2"><b>_rs OR _receiveshadows</b> : Allows per-entity control over shadow reception. Defaults to 1 on everything (world shadows). 0 = receives NO shadows. > 1 = receive shadows only from corresponding keyed entities (see above) and world. < 1 = receive shadows ONLY from corresponding keyed entities.</p>
<p class="q3bg2"><b>_celshader</b> : Sets the cel shader used for this geometry. Note: omit the "textures/" prefix.</p>
<h3>Pendulim Q3MAP2 Terrain Keys</h3>
<p class="q3bg2"><b>_indexmap OR alphamap</b> : Path/name for the art file used to guide the mapping of textures on the terrain surface.</p>
<p class="q3bg2"><b>_layers OR layers</b> : Integer value is the number unique root shaders that will be use on the terrain.</p>
<p class="q3bg2"><b>_shader OR shader</b> : Path to the metashader used to assign textures to the terrain entity. Note: Omit the "textures/" prefix.</p>
<h3>Pendulim Notes</h3>
<p class="q3bg1b">You need to have an origin brush as part of this entity. The center of that brush will be the point through which the rotation axis passes. Setting the origin key is simply an alternate method to using an origin brush. Pendulum will rotate along the X axis by default. Very crude operation: pendulum cannot rotate along Z axis, the speed of swing (frequency) is not adjustable. When using the model2 key, the origin point of the model will correspond to the origin point defined by either the origin brush or the origin coordinate value. Target this entity with a misc_model to have the model attached to the entity (set the model's "target" key to the same value as this entity's "targetname").</p></ul><h1 id="766" name="766" class="book-h3">func_plat</h1><ul><h3>func_plat</h3>
<p class="q3bg1b">Rising platform the player can ride to reach higher places. Plats must always be drawn in the raised position, so they will operate and be lighted correctly but they spawn in the lowered position. The plat will stay in the raised position until the player steps off. There are no proper sounds for this entity, only beep noises. It will spawn in the game and work properly but it sounds silly (see Notes).</p><!--break-->
<h3>Plat Entity Keys</h3>
<p class="q3bg2"><b>speed</b> : determines how fast the plat moves (default 150).</p>
<p class="q3bg2"><b>lip</b> : lip remaining at end of move (default 16). Has no effect if "height" is set.</p>
<p class="q3bg2"><b>height</b> : if set, this will determine the total amount of vertical travel of the plat.</p>
<p class="q3bg2"><b>dmg</b> : damage to inflict on player when he blocks operation of plat (default 4). Plat will reverse direction when blocked.</p>
<p class="q3bg2"><b>targetname</b> : if set, the trigger that points to this will raise the plat each time it fires. The plat raises and comes back down a second later if no player is on it.</p>
<p class="q3bg2"><b>light</b> : constantLight radius of .md3 model included with entity. Has no effect on the entity's brushes (default 0).</p>
<p class="q3bg2"><b>color</b> : constantLight color of .md3 model included with entity. Has no effect on the entity's brushes (default 1 1 1). 
<p class="q3bg2"><b>model2</b> : path/name of model to include (eg: models/mapobjects/pipe/pipe02.md3).</p>
<p class="q3bg2"><b>origin</b> : alternate method of setting XYZ origin of .md3 model included with entity (See Notes).</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in "Free for all" and "Tournament" modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in "Teamplay" and "CTF" modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<h3>Plat Q3MAP2 Keys</h3>
<p class="q3bg2"><b>_targetname</b> : Used to attach a misc_model entity to this entity.</p>
<p class="q3bg2"><b>_lightmapscale</b> : Floating point value scaling the resolution of lightmaps on brushes/patches in this entity (default 1.0).</p>
<p class="q3bg2"><b>_cs OR _castshadows</b> : Allows per-entity control over shadow casting. Defaults to 0 on entities, 1 on world. 0 = no shadow casting. 1 = cast shadows on world. > 1 = cast shadows on entities with _rs (or _receiveshadows) with the corresponding value, AND world. Negative values imply same, but DO NOT cast shadows on world.</p>
<p class="q3bg2"><b>_rs OR _receiveshadows</b> : Allows per-entity control over shadow reception. Defaults to 1 on everything (world shadows). 0 = receives NO shadows. > 1 = receive shadows only from corresponding keyed entities (see above) and world. < 1 = receive shadows ONLY from corresponding keyed entities.</p>
<p class="q3bg2"><b>_celshader</b> : Sets the cel shader used for this geometry. Note: omit the "textures/" prefix.</p>
<h3>Plat Q3MAP2 Terrain Keys</h3>
<p class="q3bg2"><b>_indexmap OR alphamap</b> : Path/name for the art file used to guide the mapping of textures on the terrain surface.</p>
<p class="q3bg2"><b>_layers OR layers</b> : Integer value is the number unique root shaders that will be use on the terrain.</p>
<p class="q3bg2"><b>_shader OR shader</b> : Path to the metashader used to assign textures to the terrain entity. Note: Omit the "textures/" prefix.</p>
<h3>Plat Notes</h3>
<p class="q3bg1b">By default, the total amount of vertical travel of a platform is implicitly determined by the overall vertical size of the brushes of which it's made minus the lip value. But if the "height" key is used, then the total amount of vertical travel of the plat will be exactly that value regardless of the shape and size of the plat and regardless of the value of the "lip" key. Using the "height" key is the best method for any kind of platforms and the only possible one for thin plats which need to travel vertical distances many times their own thickness. Setting the origin key is simply an alternate method to using an origin brush. When using the model2 key, the origin point of the model will correspond to the origin point defined by either the origin brush or the origin coordinate value.<br><br>There is a way to make plats play proper sounds. Just create a sound\movers\plats folder under baseq3 and put 2 sounds named pt1_strt.wav and pt1_end.wav in it. Those can be the renamed sounds from the Q2 plats or renamed copies of the sound\movers\doors sounds you can extract from your pak0.pk3 file or new custom sounds if you're up to it. Thanks to Fragzilla for the tip. Target this entity with a misc_model to have the model attached to the entity (set the model's "target" key to the same value as this entity's "targetname").</p></ul><h1 id="767" name="767" class="book-h3">func_rotating</h1><ul><h3>func_rotating</h3>
<p class="q3bg1b">Solid entity that rotates continuously. Rotates on the Z axis by default and requires an origin brush. It will always start on in the game and is not targetable.  A funny thing is that weapon and item entites are capable of "sticking" to a rotating object, sometimes even if it flips upsidedown.</p><!--break-->
<h3>Rotating Entity Keys</h3>
<p class="q3bg2"><b>speed</b> : determines how fast entity rotates (default 100).</p>
<p class="q3bg2"><b>noise</b> : path/name of .wav file to play. Use looping sounds only (eg. sound/world/drone6.wav).</p>
<p class="q3bg2"><b>model2</b> : path/name of model to include (eg: models/mapobjects/bitch/fembotbig.md3).</p>
<p class="q3bg2"><b>origin</b> : alternate method of setting XYZ origin of entity's rotation axis and .md3 model included with entity (default "0 0 0" - See Notes).</p>
<p class="q3bg2"><b>light</b> : constantLight radius of .md3 model included with entity. Has no effect on the entity's brushes (default 0).</p>
<p class="q3bg2"><b>color</b> : constantLight color of .md3 model included with entity. Has no effect on the entity's brushes (default 1 1 1).</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in "Free for all" and "Tournament" modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in "Teamplay" and "CTF" modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<h3>Rotating Q3MAP2 Keys</h3>
<p class="q3bg2"><b>_targetname</b> : Used to attach a misc_model entity to this entity.</p>
<p class="q3bg2"><b>_lightmapscale</b> : Floating point value scaling the resolution of lightmaps on brushes/patches in this entity (default 1.0).</p>
<p class="q3bg2"><b>_cs OR _castshadows</b> : Allows per-entity control over shadow casting. Defaults to 0 on entities, 1 on world. 0 = no shadow casting. 1 = cast shadows on world. > 1 = cast shadows on entities with _rs (or _receiveshadows) with the corresponding value, AND world. Negative values imply same, but DO NOT cast shadows on world.</p>
<p class="q3bg2"><b>_rs OR _receiveshadows</b> : Allows per-entity control over shadow reception. Defaults to 1 on everything (world shadows). 0 = receives NO shadows. > 1 = receive shadows only from corresponding keyed entities (see above) and world. < 1 = receive shadows ONLY from corresponding keyed entities.</p>
<p class="q3bg2"><b>_celshader</b> : Sets the cel shader used for this geometry. Note: omit the "textures/" prefix.</p>
<h3>Rotating Q3MAP2 Terrain Keys</h3>
<p class="q3bg2"><b>_indexmap OR alphamap</b> : Path/name for the art file used to guide the mapping of textures on the terrain surface.</p>
<p class="q3bg2"><b>_layers OR layers</b> : Integer value is the number unique root shaders that will be use on the terrain.</p>
<p class="q3bg2"><b>_shader OR shader</b> : Path to the metashader used to assign textures to the terrain entity. Note: Omit the "textures/" prefix.</p>
<h3>Rotating SpawnFlags</h3>
<p class="q3bg2"><b>X_AXIS</b> : entity will rotate along the X axis.</p>
<p class="q3bg2"><b>Y_AXIS</b> : entity will rotate along the Y axis.</p>
<h3>Rotating Notes</h3>
<p class="q3bg1b">You need to have an origin brush as part of this entity. The center of that brush will be the point through which the rotation axis passes. Setting the origin key is simply an alternate method to using an origin brush. It will rotate along the Z axis by default. You can check either the X_AXIS or Y_AXIS box to change that. When using the model2 key, the origin point of the model will correspond to the origin point defined by either the origin brush or the origin coordinate value.  Target this entity with a misc_model to have the model attached to the entity (set the model's "target" key to the same value as this entity's "targetname").</p></ul><h1 id="768" name="768" class="book-h3">func_static</h1><ul><h3>func_static</h3>
<p class="q3bg1b">Static non-solid visible or invisible brush or multiple brushes bspmodel. Can be used for conditional walls and models.</p><!--break-->
<h3>Static Entity Keys</h3>
<p class="q3bg2"><b>model2</b> : path/name of model to include (eg: models/mapobjects/bitch/fembotbig.md3).</p>
<p class="q3bg2"><b>origin</b> : alternate method of setting XYZ origin of .md3 model included with entity (See Notes).</p>
<p class="q3bg2"><b>light</b> : constantLight radius of .md3 model included with entity. Has no effect on the entity's brushes (default 0).</p>
<p class="q3bg2"><b>color</b> : constantLight color of .md3 model included with entity. Has no effect on the entity's brushes (default 1 1 1).</p>
<p class="q3bg2"><b>targetname</b> : NOT SUPPORTED BY RENDERER - if set, a func_button or trigger can make entity disappear from the game (See Notes).</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in "Free for all" and "Tournament" modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in "Teamplay" and "CTF" modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<h3>Static Q3MAP2 Keys</h3>
<p class="q3bg2"><b>_targetname</b> : Used to attach a misc_model entity to this entity.</p>
<p class="q3bg2"><b>_lightmapscale</b> : Floating point value scaling the resolution of lightmaps on brushes/patches in this entity (default 1.0).</p>
<p class="q3bg2"><b>_cs OR _castshadows</b> : Allows per-entity control over shadow casting. Defaults to 0 on entities, 1 on world. 0 = no shadow casting. 1 = cast shadows on world. > 1 = cast shadows on entities with _rs (or _receiveshadows) with the corresponding value, AND world. Negative values imply same, but DO NOT cast shadows on world.</p>
<p class="q3bg2"><b>_rs OR _receiveshadows</b> : Allows per-entity control over shadow reception. Defaults to 1 on everything (world shadows). 0 = receives NO shadows. > 1 = receive shadows only from corresponding keyed entities (see above) and world. < 1 = receive shadows ONLY from corresponding keyed entities.</p>
<p class="q3bg2"><b>_celshader</b> : Sets the cel shader used for this geometry. Note: omit the "textures/" prefix.</p>
<h3>Static Q3MAP2 Terrain Keys</h3>
<p class="q3bg2"><b>_indexmap OR alphamap</b> : Path/name for the art file used to guide the mapping of textures on the terrain surface.</p>
<p class="q3bg2"><b>_layers OR layers</b> : Integer value is the number unique root shaders that will be use on the terrain.</p>
<p class="q3bg2"><b>_shader OR shader</b> : Path to the metashader used to assign textures to the terrain entity. Note: Omit the "textures/" prefix.</p>
<h3>Static Notes</h3>
<p class="q3bg1b">When using the model2 key, the origin point of the model will correspond to the origin point defined by either the origin brush or the origin coordinate value. If a model is included with a targeted func_static, the brush(es) of the entity will be removed from the game but the .md3 model won't: it will automatically be moved to the (0 0 0) world origin so you should NOT include an .md3 model to a targeted func_static.<br><br>Because the map has only a single bot navigation file, func_static's cannot be used to make significant changes in game play flow between differing game types. Target this entity with a misc_model to have the model attached to the entity (set the model's "target" key to the same value as this entity's "targetname").</p></ul><h1 id="769" name="769" class="book-h3">func_timer</h1><ul><h3>func_timer</h3>
<p class="q3bg1b">Time delay trigger that will continuously fire its targets after a preset time delay. The time delay can also be randomized. When triggered, the timer will toggle on/off.</p><!--break-->
<h3>Timer Entity Keys</h3>
<p class="q3bg2"><b>wait</b> : delay in seconds between each triggering of its targets (default 1).</p>
<p class="q3bg2"><b>random</b> : random time variance in seconds added or subtracted from "wait" delay (default 0 - see Notes).</p>
<p class="q3bg2"><b>target</b> : this points to the entities to trigger.</p>
<p class="q3bg2"><b>targetname</b> : a func_button or trigger that points to this will toggle the timer on/off when activated.</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in "Free for all" and "Tournament" modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in "Teamplay" and "CTF" modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<h3>Timer Spawnflags</h3>
<p class="q3bg2"><b>START_ON</b> : timer will start on in the game and continuously fire its targets.</p>
<h3>Timer Notes</h3>
<p class="q3bg1b">When the random key is set, its value is used to calculate a minimum and a maximum delay. The final time delay will be a random value anywhere between the minimum and maximum values: (min delay = wait - random) (max delay = wait + random).</p></ul><h1 id="770" name="770" class="book-h3">func_train</h1><ul><h3>func_train</h3>
<p class="q3bg1b">Trains are moving solids that follow a string of path_corner entities. Trains in Q3A are very basic, they also require an origin brush (see Notes).</p><!--break-->
<h3>Train Entity keys</h3>
<p class="q3bg2"><b>speed</b> : speed of displacement of train (default 100 or overridden by speed value of path).</p>
<p class="q3bg2"><b>target</b> : this points to the first path_corner of the path which is also the spawn location of the train's origin.</p>
<p class="q3bg2"><b>model2</b> : path/name of model to include (eg: models/mapobjects/pipe/pipe02.md3).</p>
<p class="q3bg2"><b>origin</b> : alternate method of setting XYZ origin of the train's brush(es) and .md3 model included with entity (See Notes).</p>
<p class="q3bg2"><b>light</b> : constantLight radius of .md3 model included with entity. Has no effect on the entity's brushes (default 0).</p>
<p class="q3bg2"><b>color</b> : constantLight color of .md3 model included with entity. Has no effect on the entity's brushes (default 1 1 1).</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in "Free for all" and "Tournament" modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in "Teamplay" and "CTF" modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<h3>Train Q3MAP2 Keys</h3>
<p class="q3bg2"><b>_targetname</b> : Used to attach a misc_model entity to this entity.</p>
<p class="q3bg2"><b>_lightmapscale</b> : Floating point value scaling the resolution of lightmaps on brushes/patches in this entity (default 1.0).</p>
<p class="q3bg2"><b>_cs OR _castshadows</b> : Allows per-entity control over shadow casting. Defaults to 0 on entities, 1 on world. 0 = no shadow casting. 1 = cast shadows on world. > 1 = cast shadows on entities with _rs (or _receiveshadows) with the corresponding value, AND world. Negative values imply same, but DO NOT cast shadows on world.</p>
<p class="q3bg2"><b>_rs OR _receiveshadows</b> : Allows per-entity control over shadow reception. Defaults to 1 on everything (world shadows). 0 = receives NO shadows. > 1 = receive shadows only from corresponding keyed entities (see above) and world. < 1 = receive shadows ONLY from corresponding keyed entities.</p>
<p class="q3bg2"><b>_celshader</b> : Sets the cel shader used for this geometry. Note: omit the "textures/" prefix.</p>
<h3>Train Q3MAP2 Terrain Keys</h3>
<p class="q3bg2"><b>_indexmap OR alphamap</b> : Path/name for the art file used to guide the mapping of textures on the terrain surface.</p>
<p class="q3bg2"><b>_layers OR layers</b> : Integer value is the number unique root shaders that will be use on the terrain.</p>
<p class="q3bg2"><b>_shader OR shader</b> : Path to the metashader used to assign textures to the terrain entity. Note: Omit the "textures/" prefix.</p>
<h3>Train Notes</h3>
<p class="q3bg1b">1. Trains always start on in the game.<br>
2. Trains do not damage the played when blocked.<br>
3. Trains cannot emit sound.<br>
4. Trains are not triggerable or toggle-able.<br>
5. Trains cannot be block-stopped just by getting in their way, the player must be wedged between the train and another obstacle to block it. <br><br>Setting the origin key is simply an alternate method to using an origin brush. When using the model2 key, the origin point of the model will correspond to the origin point defined by either the origin brush or the origin coordinate value. Target this entity with a misc_model to have the model attached to the entity (set the model's "target" key to the same value as this entity's "targetname").</p></ul><h1 id="863" name="863" class="book-h2">Entities (Holdable)</h1><ul><h3>Holdable Entities</h3>
Coming soon...</ul><h1 id="862" name="862" class="book-h2">Entities (Info)</h1><ul><h3>Info Entities</h3>
Coming soon...</ul><h1 id="864" name="864" class="book-h2">Entities (Item)</h1><ul><h3>Item Entities</h3>
Coming soon...</ul><h1 id="868" name="868" class="book-h2">Entities (Path and Shooter)</h1><ul><h3>Path and Shooter Entities</h3>
Coming soon...</ul><h1 id="866" name="866" class="book-h2">Entities (Target)</h1><ul><h3>Target Entities</h3>
Coming soon...</ul><h1 id="865" name="865" class="book-h2">Entities (Team)</h1><ul><h3>Team Entities</h3>
Coming soon...</ul><h1 id="867" name="867" class="book-h2">Entities (Trigger)</h1><ul><h3>Trigger Entities</h3>
Coming soon...</ul><h1 id="840" name="840" class="book-h2">Entities (Weapon & Ammo)</h1><ul><h2>Weapon And Ammo Entities</h3>
<p class="q3bg1b">Weapon Entities have few parameters you can set. Most mappers will seldom alter the properties of a weapon entity. These entities can be found in the menu available upon right clicking in a profile (non camera) window.<br><br>
Be sure to visit <a href="/book/view/685">this page in the quake III general info handbook</a> in order to better understand the weapons and ammo. After learning the ins and outs of working with Quake III entities, return here and learn more about each entity.</p></ul><h1 id="845" name="845" class="book-h3">weapon_bfg</h1><ul><h3>weapon_bfg</h3>
<p class="q3bg1b">Big Freaking Gun. <br>
<!--break-->
</p>
<h3>weapon_bfg Entity Keys</h3>
<p class="q3bg2"><b>wait</b> : time in seconds before item respawns after being picked up (default 5, -1 = never respawn).</p>
<p class="q3bg2"><b>random</b> : random time variance in seconds added or subtracted from &quot;wait&quot; delay (default 0 - see Notes).</p>
<p class="q3bg2"><b>count</b>: sets the amount of ammo given to the player when weapon is picked up (default 20).</p>
<p class="q3bg2"><b>team</b> : set this to team items. Teamed items will respawn randomly after team master is picked up (see Notes).</p>
<p class="q3bg2"><b>target</b> : picking up the item will trigger the entity this points to.</p>
<p class="q3bg2"><b>targetname</b> : a target_give entity can point to this for respawn freebies.</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in &quot;Free for all&quot; and &quot;Tournament&quot; modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in &quot;Teamplay&quot; and &quot;CTF&quot; modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<p class="q3bg2"><b>notbot</b> : used to make an item invisible for bot attraction.</p>
<h3>weapon_bfg Spawnflags</h3>
<p class="q3bg2"><b>SUSPENDED</b> : item will spawn where it was placed 
in map and won't drop to the floor.</p>
<h3>weapon_bfg Notes</h3>
<p class=q3bg1b>The amount of time it takes for an item in the team to respawn 
is determined by the &quot;wait&quot; value of the item that was picked up previously. 
So if one of the items in the team has it's &quot;wait&quot; key set to -1 (never 
respawn), the random respawning cycle of the teamed items will stop after that 
item is picked up. <br>
<br>
When the random key is set, its value is used to calculate a minimum and a maximum 
delay. The final time delay will be a random value anywhere between the minimum 
and maximum values: (min delay = wait - random) (max delay = wait + random). <br>
----- MODEL FOR RADIANT ONLY - DO NOT SET THIS AS A KEY ----- <br>
model=&quot;models/weapons2/bfg/bfg.md3&quot;</p>
</ul><h1 id="846" name="846" class="book-h3">weapon_gauntlet</h1><ul><h3>weapon_gauntlet</h3>
<p class="q3bg1b">Hand worn armament with spinning blade and light effects. This entity is not needed in the game but it is possible to place a gauntlet if so desired.<br>
<!--break-->
</p>
<h3>weapon_gauntlet Entity Keys</h3>
<p class="q3bg2"><b>wait</b> : time in seconds before item respawns after being picked up (default 5, -1 = never respawn).</p>
<p class="q3bg2"><b>random</b> : random time variance in seconds added or subtracted from &quot;wait&quot; delay (default 0 - see Notes).</p>
<p class="q3bg2"><b>count</b>: sets the amount of ammo given to the player when weapon is picked up (default 20).</p>
<p class="q3bg2"><b>team</b> : set this to team items. Teamed items will respawn randomly after team master is picked up (see Notes).</p>
<p class="q3bg2"><b>target</b> : picking up the item will trigger the entity this points to.</p>
<p class="q3bg2"><b>targetname</b> : a target_give entity can point to this for respawn freebies.</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in &quot;Free for all&quot; and &quot;Tournament&quot; modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in &quot;Teamplay&quot; and &quot;CTF&quot; modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<p class="q3bg2"><b>notbot</b> : used to make an item invisible for bot attraction.</p>
<h3>weapon_gauntlet Spawnflags</h3>
<p class="q3bg2"><b>SUSPENDED</b> : item will spawn where it was placed 
in map and won't drop to the floor.</p>
<h3>weapon_gauntlet Notes</h3>
<p class=q3bg1b>The amount of time it takes for an item in the team to respawn 
is determined by the &quot;wait&quot; value of the item that was picked up previously. 
So if one of the items in the team has it's &quot;wait&quot; key set to -1 (never 
respawn), the random respawning cycle of the teamed items will stop after that 
item is picked up. <br>
<br>
When the random key is set, its value is used to calculate a minimum and a maximum 
delay. The final time delay will be a random value anywhere between the minimum 
and maximum values: (min delay = wait - random) (max delay = wait + random). <br>
----- MODEL FOR RADIANT ONLY - DO NOT SET THIS AS A KEY ----- <br>
model=&quot;models/weapons2/gauntlet/gauntlet.md3&quot;</p>
</ul><h1 id="847" name="847" class="book-h3">weapon_grapplinghook</h1><ul><h3>weapon_grapplinghook</h3>
<p class="q3bg1b">Grappling Hook. Spawns in the game and works but is unskinned.  This is mainly to support the grapple mod.<br>
<!--break-->
</p>
<h3>weapon_grapplinghook Entity Keys</h3>
<p class="q3bg2"><b>wait</b> : time in seconds before item respawns after being picked up (default 5, -1 = never respawn).</p>
<p class="q3bg2"><b>random</b> : random time variance in seconds added or subtracted from &quot;wait&quot; delay (default 0 - see Notes).</p>
<p class="q3bg2"><b>count</b>: sets the amount of ammo given to the player when weapon is picked up (default 20).</p>
<p class="q3bg2"><b>team</b> : set this to team items. Teamed items will respawn randomly after team master is picked up (see Notes).</p>
<p class="q3bg2"><b>target</b> : picking up the item will trigger the entity this points to.</p>
<p class="q3bg2"><b>targetname</b> : a target_give entity can point to this for respawn freebies.</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in &quot;Free for all&quot; and &quot;Tournament&quot; modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in &quot;Teamplay&quot; and &quot;CTF&quot; modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<p class="q3bg2"><b>notbot</b> : used to make an item invisible for bot attraction.</p>
<h3>weapon_grapplinghook Spawnflags</h3>
<p class="q3bg2"><b>SUSPENDED</b> : item will spawn where it was placed 
in map and won't drop to the floor.</p>
<h3>weapon_grapplinghook Notes</h3>
<p class=q3bg1b>The amount of time it takes for an item in the team to respawn 
is determined by the &quot;wait&quot; value of the item that was picked up previously. 
So if one of the items in the team has it's &quot;wait&quot; key set to -1 (never 
respawn), the random respawning cycle of the teamed items will stop after that 
item is picked up. <br>
<br>
When the random key is set, its value is used to calculate a minimum and a maximum 
delay. The final time delay will be a random value anywhere between the minimum 
and maximum values: (min delay = wait - random) (max delay = wait + random). <br>
----- MODEL FOR RADIANT ONLY - DO NOT SET THIS AS A KEY ----- <br>
model=&quot;models/weapons2/grapple/grapple.md3&quot;</p></ul><h1 id="848" name="848" class="book-h3">weapon_grenadelauncher</h1><ul><h3>weapon_grenadelauncher</h3>
<p class="q3bg1b">Grenade Launcher.<br>
<!--break-->
</p>
<h3>weapon_grenadelauncher Entity Keys</h3>
<p class="q3bg2"><b>wait</b> : time in seconds before item respawns after being picked up (default 5, -1 = never respawn).</p>
<p class="q3bg2"><b>random</b> : random time variance in seconds added or subtracted from &quot;wait&quot; delay (default 0 - see Notes).</p>
<p class="q3bg2"><b>count</b>: sets the amount of ammo given to the player when weapon is picked up (default 20).</p>
<p class="q3bg2"><b>team</b> : set this to team items. Teamed items will respawn randomly after team master is picked up (see Notes).</p>
<p class="q3bg2"><b>target</b> : picking up the item will trigger the entity this points to.</p>
<p class="q3bg2"><b>targetname</b> : a target_give entity can point to this for respawn freebies.</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in &quot;Free for all&quot; and &quot;Tournament&quot; modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in &quot;Teamplay&quot; and &quot;CTF&quot; modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<p class="q3bg2"><b>notbot</b> : used to make an item invisible for bot attraction.</p>
<h3>weapon_grenadelauncher Spawnflags</h3>
<p class="q3bg2"><b>SUSPENDED</b> : item will spawn where it was placed 
in map and won't drop to the floor.</p>
<h3>weapon_grenadelauncher Notes</h3>
<p class=q3bg1b>The amount of time it takes for an item in the team to respawn 
is determined by the &quot;wait&quot; value of the item that was picked up previously. 
So if one of the items in the team has it's &quot;wait&quot; key set to -1 (never 
respawn), the random respawning cycle of the teamed items will stop after that 
item is picked up. <br>
<br>
When the random key is set, its value is used to calculate a minimum and a maximum 
delay. The final time delay will be a random value anywhere between the minimum 
and maximum values: (min delay = wait - random) (max delay = wait + random). <br>
----- MODEL FOR RADIANT ONLY - DO NOT SET THIS AS A KEY ----- <br>
model=&quot;models/weapons2/grapple/grenadel.md3&quot;</p></ul><h1 id="849" name="849" class="book-h3">weapon_lightning</h1><ul><h3>weapon_lightning</h3>
<p class="q3bg1b">Lightening Gun.<br>
<!--break-->
</p>
<h3>weapon_lightning Entity Keys</h3>
<p class="q3bg2"><b>wait</b> : time in seconds before item respawns after being picked up (default 5, -1 = never respawn).</p>
<p class="q3bg2"><b>random</b> : random time variance in seconds added or subtracted from &quot;wait&quot; delay (default 0 - see Notes).</p>
<p class="q3bg2"><b>count</b>: sets the amount of ammo given to the player when weapon is picked up (default 20).</p>
<p class="q3bg2"><b>team</b> : set this to team items. Teamed items will respawn randomly after team master is picked up (see Notes).</p>
<p class="q3bg2"><b>target</b> : picking up the item will trigger the entity this points to.</p>
<p class="q3bg2"><b>targetname</b> : a target_give entity can point to this for respawn freebies.</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in &quot;Free for all&quot; and &quot;Tournament&quot; modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in &quot;Teamplay&quot; and &quot;CTF&quot; modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<p class="q3bg2"><b>notbot</b> : used to make an item invisible for bot attraction.</p>
<h3>weapon_lightning Spawnflags</h3>
<p class="q3bg2"><b>SUSPENDED</b> : item will spawn where it was placed 
in map and won't drop to the floor.</p>
<h3>weapon_lightning Notes</h3>
<p class=q3bg1b>The amount of time it takes for an item in the team to respawn 
is determined by the &quot;wait&quot; value of the item that was picked up previously. 
So if one of the items in the team has it's &quot;wait&quot; key set to -1 (never 
respawn), the random respawning cycle of the teamed items will stop after that 
item is picked up. <br>
<br>
When the random key is set, its value is used to calculate a minimum and a maximum 
delay. The final time delay will be a random value anywhere between the minimum 
and maximum values: (min delay = wait - random) (max delay = wait + random). <br>
----- MODEL FOR RADIANT ONLY - DO NOT SET THIS AS A KEY ----- <br>
model=&quot;models/weapons2/grapple/lightning.md3&quot;</p></ul><h1 id="850" name="850" class="book-h3">weapon_machinegun</h1><ul><h3>weapon_machinegun</h3>
<p class="q3bg1b">Machine Gun.<br>
<!--break-->
</p>
<h3>weapon_machinegun Entity Keys</h3>
<p class="q3bg2"><b>wait</b> : time in seconds before item respawns after being picked up (default 5, -1 = never respawn).</p>
<p class="q3bg2"><b>random</b> : random time variance in seconds added or subtracted from &quot;wait&quot; delay (default 0 - see Notes).</p>
<p class="q3bg2"><b>count</b>: sets the amount of ammo given to the player when weapon is picked up (default 20).</p>
<p class="q3bg2"><b>team</b> : set this to team items. Teamed items will respawn randomly after team master is picked up (see Notes).</p>
<p class="q3bg2"><b>target</b> : picking up the item will trigger the entity this points to.</p>
<p class="q3bg2"><b>targetname</b> : a target_give entity can point to this for respawn freebies.</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in &quot;Free for all&quot; and &quot;Tournament&quot; modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in &quot;Teamplay&quot; and &quot;CTF&quot; modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<p class="q3bg2"><b>notbot</b> : used to make an item invisible for bot attraction.</p>
<h3>weapon_machinegun Spawnflags</h3>
<p class="q3bg2"><b>SUSPENDED</b> : item will spawn where it was placed 
in map and won't drop to the floor.</p>
<h3>weapon_machinegun Notes</h3>
<p class=q3bg1b>The amount of time it takes for an item in the team to respawn 
is determined by the &quot;wait&quot; value of the item that was picked up previously. 
So if one of the items in the team has it's &quot;wait&quot; key set to -1 (never 
respawn), the random respawning cycle of the teamed items will stop after that 
item is picked up. <br>
<br>
When the random key is set, its value is used to calculate a minimum and a maximum 
delay. The final time delay will be a random value anywhere between the minimum 
and maximum values: (min delay = wait - random) (max delay = wait + random). <br>
----- MODEL FOR RADIANT ONLY - DO NOT SET THIS AS A KEY ----- <br>
model=&quot;models/weapons2/grapple/machinegun.md3&quot;</p></ul><h1 id="851" name="851" class="book-h3">weapon_plasmagun</h1><ul><h3>weapon_plasmagun</h3>
<p class="q3bg1b">Plasma Gun.<br>
<!--break-->
</p>
<h3>weapon_plasmagun Entity Keys</h3>
<p class="q3bg2"><b>wait</b> : time in seconds before item respawns after being picked up (default 5, -1 = never respawn).</p>
<p class="q3bg2"><b>random</b> : random time variance in seconds added or subtracted from &quot;wait&quot; delay (default 0 - see Notes).</p>
<p class="q3bg2"><b>count</b>: sets the amount of ammo given to the player when weapon is picked up (default 20).</p>
<p class="q3bg2"><b>team</b> : set this to team items. Teamed items will respawn randomly after team master is picked up (see Notes).</p>
<p class="q3bg2"><b>target</b> : picking up the item will trigger the entity this points to.</p>
<p class="q3bg2"><b>targetname</b> : a target_give entity can point to this for respawn freebies.</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in &quot;Free for all&quot; and &quot;Tournament&quot; modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in &quot;Teamplay&quot; and &quot;CTF&quot; modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<p class="q3bg2"><b>notbot</b> : used to make an item invisible for bot attraction.</p>
<h3>weapon_plasmagun Spawnflags</h3>
<p class="q3bg2"><b>SUSPENDED</b> : item will spawn where it was placed 
in map and won't drop to the floor.</p>
<h3>weapon_plasmagun Notes</h3>
<p class=q3bg1b>The amount of time it takes for an item in the team to respawn 
is determined by the &quot;wait&quot; value of the item that was picked up previously. 
So if one of the items in the team has it's &quot;wait&quot; key set to -1 (never 
respawn), the random respawning cycle of the teamed items will stop after that 
item is picked up. <br>
<br>
When the random key is set, its value is used to calculate a minimum and a maximum 
delay. The final time delay will be a random value anywhere between the minimum 
and maximum values: (min delay = wait - random) (max delay = wait + random). <br>
----- MODEL FOR RADIANT ONLY - DO NOT SET THIS AS A KEY ----- <br>
model=&quot;models/weapons2/grapple/plasma.md3&quot;</p></ul><h1 id="852" name="852" class="book-h3">weapon_railgun</h1><ul><h3>weapon_railgun</h3>
<p class="q3bg1b">Rail Gun.<br>
<!--break-->
</p>
<h3>weapon_railgun Entity Keys</h3>
<p class="q3bg2"><b>wait</b> : time in seconds before item respawns after being picked up (default 5, -1 = never respawn).</p>
<p class="q3bg2"><b>random</b> : random time variance in seconds added or subtracted from &quot;wait&quot; delay (default 0 - see Notes).</p>
<p class="q3bg2"><b>count</b>: sets the amount of ammo given to the player when weapon is picked up (default 20).</p>
<p class="q3bg2"><b>team</b> : set this to team items. Teamed items will respawn randomly after team master is picked up (see Notes).</p>
<p class="q3bg2"><b>target</b> : picking up the item will trigger the entity this points to.</p>
<p class="q3bg2"><b>targetname</b> : a target_give entity can point to this for respawn freebies.</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in &quot;Free for all&quot; and &quot;Tournament&quot; modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in &quot;Teamplay&quot; and &quot;CTF&quot; modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<p class="q3bg2"><b>notbot</b> : used to make an item invisible for bot attraction.</p>
<h3>weapon_railgun Spawnflags</h3>
<p class="q3bg2"><b>SUSPENDED</b> : item will spawn where it was placed 
in map and won't drop to the floor.</p>
<h3>weapon_railgun Notes</h3>
<p class=q3bg1b>The amount of time it takes for an item in the team to respawn 
is determined by the &quot;wait&quot; value of the item that was picked up previously. 
So if one of the items in the team has it's &quot;wait&quot; key set to -1 (never 
respawn), the random respawning cycle of the teamed items will stop after that 
item is picked up. <br>
<br>
When the random key is set, its value is used to calculate a minimum and a maximum 
delay. The final time delay will be a random value anywhere between the minimum 
and maximum values: (min delay = wait - random) (max delay = wait + random). <br>
----- MODEL FOR RADIANT ONLY - DO NOT SET THIS AS A KEY ----- <br>
model=&quot;models/weapons2/grapple/railgun.md3&quot;</p></ul><h1 id="853" name="853" class="book-h3">weapon_rocketlauncher</h1><ul><h3>weapon_rocketlauncher</h3>
<p class="q3bg1b">Rocket Launcher.<br>
<!--break-->
</p>
<h3>weapon_rocketlauncher Entity Keys</h3>
<p class="q3bg2"><b>wait</b> : time in seconds before item respawns after being picked up (default 5, -1 = never respawn).</p>
<p class="q3bg2"><b>random</b> : random time variance in seconds added or subtracted from &quot;wait&quot; delay (default 0 - see Notes).</p>
<p class="q3bg2"><b>count</b>: sets the amount of ammo given to the player when weapon is picked up (default 20).</p>
<p class="q3bg2"><b>team</b> : set this to team items. Teamed items will respawn randomly after team master is picked up (see Notes).</p>
<p class="q3bg2"><b>target</b> : picking up the item will trigger the entity this points to.</p>
<p class="q3bg2"><b>targetname</b> : a target_give entity can point to this for respawn freebies.</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in &quot;Free for all&quot; and &quot;Tournament&quot; modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in &quot;Teamplay&quot; and &quot;CTF&quot; modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<p class="q3bg2"><b>notbot</b> : used to make an item invisible for bot attraction.</p>
<h3>weapon_rocketlauncher Spawnflags</h3>
<p class="q3bg2"><b>SUSPENDED</b> : item will spawn where it was placed 
in map and won't drop to the floor.</p>
<h3>weapon_rocketlauncher Notes</h3>
<p class=q3bg1b>The amount of time it takes for an item in the team to respawn 
is determined by the &quot;wait&quot; value of the item that was picked up previously. 
So if one of the items in the team has it's &quot;wait&quot; key set to -1 (never 
respawn), the random respawning cycle of the teamed items will stop after that 
item is picked up. <br>
<br>
When the random key is set, its value is used to calculate a minimum and a maximum 
delay. The final time delay will be a random value anywhere between the minimum 
and maximum values: (min delay = wait - random) (max delay = wait + random). <br>
----- MODEL FOR RADIANT ONLY - DO NOT SET THIS AS A KEY ----- <br>
model=&quot;models/weapons2/rocketl/rocketl.md3&quot;</p>
</ul><h1 id="854" name="854" class="book-h3">weapon_shotgun</h1><ul><h3>weapon_shotgun</h3>
<p class="q3bg1b">Shotgun.<br>
<!--break-->
</p>
<h3>weapon_shotgun Entity Keys</h3>
<p class="q3bg2"><b>wait</b> : time in seconds before item respawns after being picked up (default 5, -1 = never respawn).</p>
<p class="q3bg2"><b>random</b> : random time variance in seconds added or subtracted from &quot;wait&quot; delay (default 0 - see Notes).</p>
<p class="q3bg2"><b>count</b>: sets the amount of ammo given to the player when weapon is picked up (default 20).</p>
<p class="q3bg2"><b>team</b> : set this to team items. Teamed items will respawn randomly after team master is picked up (see Notes).</p>
<p class="q3bg2"><b>target</b> : picking up the item will trigger the entity this points to.</p>
<p class="q3bg2"><b>targetname</b> : a target_give entity can point to this for respawn freebies.</p>
<p class="q3bg2"><b>notfree</b> : when set to 1, entity will not spawn in &quot;Free for all&quot; and &quot;Tournament&quot; modes.</p>
<p class="q3bg2"><b>notteam</b> : when set to 1, entity will not spawn in &quot;Teamplay&quot; and &quot;CTF&quot; modes.</p>
<p class="q3bg2"><b>notsingle</b> : when set to 1, entity will not spawn in Single Player mode (bot play mode).</p>
<p class="q3bg2"><b>notbot</b> : used to make an item invisible for bot attraction.</p>
<h3>weapon_shotgun Spawnflags</h3>
<p class="q3bg2"><b>SUSPENDED</b> : item will spawn where it was placed 
in map and won't drop to the floor.</p>
<h3>weapon_shotgun Notes</h3>
<p class=q3bg1b>The amount of time it takes for an item in the team to respawn 
is determined by the &quot;wait&quot; value of the item that was picked up previously. 
So if one of the items in the team has it's &quot;wait&quot; key set to -1 (never 
respawn), the random respawning cycle of the teamed items will stop after that 
item is picked up. <br>
<br>
When the random key is set, its value is used to calculate a minimum and a maximum 
delay. The final time delay will be a random value anywhere between the minimum 
and maximum values: (min delay = wait - random) (max delay = wait + random). <br>
----- MODEL FOR RADIANT ONLY - DO NOT SET THIS AS A KEY ----- <br>
model=&quot;models/weapons2/shotgun/shotgun.md3&quot;</p></ul><h1 id="576" name="576" class="book-h2">GTKRadiant Tutorials (Level Editing)</h1><ul><p class="q3bg1">Quake III Arena Tutorials<br><br>
Here you'll find an assorted and growing collection of tutorials for Quake III Arena and the editro GTKradiant or QERadiant. These tutorials cover modelling, texturing, entities, advanced entities, sounds and much more.<br><br>
If you have a tutorial you'd like to submit to the collection, or if you have suggestions for revisions to existing tutorials, jump into the <a href="http://forums.gamedesign.net/viewforum.php?f=15">Quake III Arena Game Design Forums!</a></p></ul><h1 id="570" name="570" class="book-h3">Making a mirror</h1><ul><!-- tutorial1 - converted 25/08/04 from q3lab.telefragged.com -->
<h3>Quake III: Arena</h3>
<blockquote>
	<font class="title">
		Making a mirror -
		<a href="mailto:jon80@home.se">Jon Eriksson</a>
	</font>
</blockquote>
<br><br>	
					
 <p>Please note: this resource among other resources here at rust are no longer 
	updated and maintained by the original author any more. If you need to contact
	someone in regards to this, please contact the moderators of the Quake III Arena 
	Forum on the RUST website.

<p><hr width=75% color=black noshade><p>
<br>
<p>First I thought I should make a tutorial how the Curved faces works, but I changed my mind, and made this Mirror tutorial instead. I made this choice basically because the curved faces is tricky to understand, and I think I will make a tutorial about it in Tutorial #5 or #6. So, how do you make a mirror? Just read the stuff below. First, the mirror has one bad thing with it, it will not reflect light, but you wouldn't see it if you don't think about it =). Here comes the tutorial. </p>

<p>Let's open our map, the map I have added upon since tutorial 1. I want to place a mirror at one of the sides in the room where I have my lamp (from tutorial #3). First, do as we always do, load a texture, but this time, you have to load the "common" textures, because that's where the mirror is located. Choose the left of the "Mirror" textures, and make a new object, it might look like this:</p>
<br>
<center>
<img src="./content/quake3/tutorials/tutorial4/mirrortextur.jpg"><br>
</center>
<br>
<p>Now, many of you think you're done, but it's not that simple =). </p>
<ul>
<p><li><i>Now, we're done with the new cube, so push ESC to deselect it. Now we need to put a new entity in front of the mirror. Press your right mouse button in any of the views (except for the 3dview) until you get the small menu, popping up where the mouse cursor is.</i></p>

<p><li><i>Go down on that menu, and choose "misc", and then "misc_portal_surface". A new entity will be shown, place the new entity in front of the mirror. (the entity must be closer than 64 units from the mirror texture). </i></p>
</ul>
<br>

<p>If you compile your map, the mirror will work, but act really strange. It wouldn't work from all angles, and that's because the mirror can only have 1 viewable surface. This mean that we have to cover all surfaces except the one we want as a mirror. I will do this by adding new boxes, that I put around the mirror. So it looks like this: </p>
<br>
<center>
<img src="./content/quake3/tutorials/tutorial4/done.jpg"><br>
</center>
<br>
<p>Now you can compile your map, and you got yourself a nice mirror =). One thing to know is that if you use mirrors, the clients FPS will be completely killed! But I agree that it is a nice effect. Another note is that
the mirror will not effect lights.</p></ul><h1 id="667" name="667" class="book-h3">Making a Spiral Stairway</h1><ul><!-- tutorial1 - converted 25/08/04 from q3lab.telefragged.com -->
<h3>Quake III: Arena</h3>
<blockquote>
	<font class="title">
		Making a Spiral Stairway -
		<a href="mailto:jon80@home.se">Jon Eriksson</a>
	</font>
</blockquote>
<br><br>	

<p>I was asked how to make a wall around a spiral stairway, and since I wasn't able to explain it without pictures (thats definitely hard :) I wrote this tutorial. Enjoy :)</p>
					
<p><hr width=75% color=black noshade><p>
   
<p><b>STEP 1:</b> Lets say weve got a map like this. You should be able to recognize that the wall around the stair consists of brushes. brushes? yeah right. and im gonna tell u how to replace them with a curved patch (that sounds better, looks better and even IS better ;)</p>

<center><img src="content/quake3/tutorials/tutorial28/joe1.jpg"></center>

<p><b>STEP 2:</b> Now delete those ugly boxes and put in a brush into an empty space. Why? Its less chaotic as you will see in the next step.</p>

<center><img src="content/quake3/tutorials/tutorial28/joe2.jpg"></center>

<p><b>STEP 3:</b> We need a patch not a brush, right? Now select "Curve|Simple Patch Mesh". 3x3? no thats not enough...Choose 3x9 and confirm.</p>

<center><img src="content/quake3/tutorials/tutorial28/joe3.jpg"></center>

<p><b>STEP 4:</b> Put the curve onto the place where the wall is gonna begin. You must be absolutely sure that *all* vectors of the patch mesh lay on the grid, or else you cannot edit it.</p>

<p>Now...lets go to the texturing: First make something like this :</p>

<center><img src="content/quake3/tutorials/tutorial28/joe4.jpg"></center>

<p><b>STEP 5:</b> Now press [V] to enter the vector edit mode. build something like this but make **absolute** sure that the vectors are on the grid b4 u start!</p>

<p>You will notice the white mark in this pic. I think its easier for you not to put the starting points of the patch at the same place as the ending points as you will have to seperate them again and thats kinda tricky.</p>

<center><img src="content/quake3/tutorials/tutorial28/joe5.jpg"></center>

<p><b>STEP 6:</b> Now its easy... goto the top view and select 3 points (in the topview u only see a single 1 of course!) and pull them down in one of the other 2D views. Now take another 3 till uve done all of them.</p>

<p>In this pic you see the curved brush as ive done it :] Its not finished yet (just a draft for this tut). but you can align your vectors a bit better (stay on the grid!) and make the wall higher so that it fits this stair.</p>

<center><img src="content/quake3/tutorials/tutorial28/joe6.jpg"></center>

<p>Have fun making spiral stairways =)</p>

</ul><h1 id="665" name="665" class="book-h3">Making Complex Doors</h1><ul><!-- tutorial1 - converted 25/08/04 from q3lab.telefragged.com -->
<h3>Quake III: Arena</h3>
<blockquote>
	<font class="title">
		Making Complex Doors-
		<a href="mailto:jon80@home.se">Jon Eriksson</a>
	</font>
</blockquote>
<br><br>	
					
<p>Now it's time to try to get more out of the func_door! Maybe you have tried to make two door halves, that should open at the same time, and haven't got it work? Then this is the tutorial for you! Read on...</p>

<p><hr width=75% color=black noshade><p>
<br>

<p><b>STEP 1:</b> Make the door.<p> 

<p>Do this by simply add some objects with a nice texture. Maybe you have it look like this:</p>

<center><img src="content/quake3/tutorials/tutorial30/editor1.jpg"></center>

<p>Okay, as you can see I have two door halves.</p>

<p><b>STEP 2:</b> Make the door A "func_door".<p>
 
<p>Now I select one of them, and make it to a "func_door" by pushing the right-mouse-button. I set the Angle of the door (The direction it should open). <i>Note: that each halves should have different angles (first door half + 180 degrees = second door half).</i></p> 

<p><b>STEP 3:</b> Compile the MAP.<p>

<p>Compiling the map will let you see what you have just created, and it is good mapping practise to examine you map -in the game- at regular intervals. <i>Note: that the two door halves will not open at the same time, when you're in game. To get the two door halves to open at the same time, we have to add some more stuff to it.</i></p>

<p><b>STEP 4:</b> Synchronize the doors.<p>

<p>Now we want the doors to be syncronized. Now add a new box about 8 units infront of the door, and apply the "common/nodraw" texture on it. It should now look like this:</p>

<center><img src="content/quake3/tutorials/tutorial30/editor2.jpg"></center>

<p><b>STEP 5:</b> Apply the "trigger_multiple".<p>

<p>Now, apply the "trigger_multiple" on this box. The Trigger_multiple is an entity that will trigger it's targets when you walk-on/touch it. We use the multiple_trigger, also because that it should be possible to open the door many times =). Do this by:</p> 

<list><p>1. Now select one the door halfs, and push "N". Write in the "Key" area "targetname", and then in the value "door1" (push Enter).</p> 

<p>2. Now select the other door half (deselect the first door), and do the same here "targetname" .. "door1". </p>

<p>3. Now, deselect the door half, and select the "trigger_multiple" box that we just created. Push "N", and type in the Key area "Target" and the value "door1". 

<p>4. Now, try to run the map. If you have done this right, the door half should open at the same time when you walk close up to them. <i>Note: that you have to add a brush like this on the other side of the doors too, otherwise you will only be able to open the doors from one way. (You can also make the "Trigger_multiple" object big, so you use the same object on both sides of the door, this will also prevent the door to hurt you when you stand right in the middle of them).</i></p></list>

<p><hr width=75% color=black noshade><p>

<p>Hope this will help some. Note that you can ofcourse use however many door parts as you want. You can make many VERY cool doors with the "trigger_multiple" and the "func_train". Maybe i should do a tutorial on that too?</p>
</ul><h1 id="666" name="666" class="book-h3">Making Custom Textures</h1><ul><!-- tutorial1 - converted 25/08/04 from q3lab.telefragged.com -->
<h3>Quake III: Arena</h3>
<blockquote>
	<font class="title">
		Making Custom Textures -
		<a href="mailto:jon80@home.se">Jon Eriksson</a>
	</font>
</blockquote>
<br><br>	
					
 <p>If you have ever wanted to make and used custom textures for Quake III with Q3radiant, this tutorial will help you. Read on.</p>

<p><hr width=75% color=black noshade><p>

<p>First you need a program that can handle TGA pictures, there's a free program called <a href="http://home.telefragged.com/wally/">Wally</a>, that you can use, but i rather use Photoshop or Paint Shop Pro. Make a Texture, maby it looks like this:</p>

<center><img src="content/quake3/tutorials/tutorial29/pic1.jpg"></center>

<p>Save this texture/picture as a 24bit (or 32bit, depends on what quality you want on it, and also note that the 32bit picture is bigger than the 24bit picture, so use 24bit pictures more often to save on memory in the game.</p>

<p>Now we want the picture to work in Q3radiant. This is very easy. Put the texture in the <b>"quake3dir/baseq3/textures/newtextures"</b><p> 

<p><b>For example:</b> Now load Q3radiant, and push "Textures". Woah, there it is! A new line with the "Newtextures".<p>

<center><img src="content/quake3/tutorials/tutorial29/pic2.jpg"></center>

<p>Yes it is that easy!</p>

<p><i>Note: that the name in Q3radiant is the same as the one in the folder. Now you can use your new texture as much as you want. Don't forgett to include it in the .pk3 file when you give away the maps using the new textures =)</p>
</ul><h1 id="598" name="598" class="book-h3">Making Doors</h1><ul><!-- tutorial1 - converted 25/08/04 from q3lab.telefragged.com -->
<h3>Quake III: Arena</h3>
<blockquote>
	<font class="title">
		Making Doors -
		<a href="mailto:jon80@home.se">Jon Eriksson</a>
	</font>
</blockquote>
<br><br>	
					
 <p>Please note: this resource among other resources here at rust are no longer 
	updated and maintained by the original author any more. If you need to contact
	someone in regards to this, please contact the moderators of the Quake III Arena 
	Forum on the RUST website.

<p><hr width=75% color=black noshade><p>
<br>

<B><U>Making a door</B></U><br>

<p>It's easier than you may think to make a door. I have two rooms, a small corridor between them, and I want a door right in the corridor.</p>

<p>First, load a nice texture for a door. There is nice Wall textures for a door, but there is also specific textures for doors. I will load the Gothic_door textures, for my map. Most of the Door textures are hard to make a good door with, so I will take a more Wall-like texture.</p>

<p>Once I've chosen a texture I make a new box, and this is the box that will be my door, so I form the box so it fits the corridor. To make it even more complicated, I want a door that is 2 parts, one left part, and one right part. The right part should move right, and the left should move left when the door opens. Actually, it's pretty easy =). </p>

<p>The thing is that those doors are actually two doors. One door moves left, and the other right. This makes an illusion that it's one door that moves apart when you run thru it. </p>

<p>Okay, the texture is set, and everything is set to go. Let's select the door (or one half of the door). Now, push the right mousebutton, so the menu appears. Choose "func", and then "func_door". This will set the box to be a door. Push "n" to bring up the "entity list", and here you can enter a few new keys, with values, but we want a simple door, so we don't have to change anything (the keys is listed in the text in the Entety window). </p>

<p>The only thing we have to do here is to push one of the direction buttons. The "Direction buttons" are the buttons that are located in the lower left in the entity window. It says "135", "90", "45" ... This tells the game what direction the door should move to get opened. If you don't know for sure, look in the Top view (upper left in the Q3radiant window). For my door, i had to push the "270" button to get my door right. Now, that door is finished. If you only have one door, you're done. But if you have a two parted door, you have to select the other door-half, and makes the same step as with the first one, except that the direction should be the opposite. That makes my other door half to be in the direction of "90". Now, this is how my door looks like:</p>
<br>
<center>
<img src="./content/quake3/tutorials/tutorial5/door.jpg"><br>
</center>
<br>
<p>I've written a tutoruial about more complexed doors in another tutorial.</p></ul><h1 id="597" name="597" class="book-h3">Making Jumppads</h1><ul><!-- tutorial1 - converted 25/08/04 from q3lab.telefragged.com -->
<h3>Quake III: Arena</h3>
<blockquote>
	<font class="title">
		Making Jumppads -
		<a href="mailto:jon80@home.se">Jon Eriksson</a>
	</font>
</blockquote>
<br><br>	
					
 <p>Please note: this resource among other resources here at rust are no longer 
	updated and maintained by the original author any more. If you need to contact
	someone in regards to this, please contact the moderators of the Quake III Arena 
	Forum on the RUST website.

<p><hr width=75% color=black noshade><p>
<br>
<B><U>Jump pads</b></u><br>

<p>Let's start with how to make a Jump pad. We'll start by making a room that looks something like this (I have finally used the Gothic textures here =):</p>
<br>
<center>
<img src="./content/quake3/tutorials/tutorial5/jumpstart.jpg"><br>
</center>
<br>
<p>If you don't have time to make a room, or just don't understand, download the room (It's the same room as from the screenshot, open up the room, and continue to read =). </p>

<p>Now, we need a new block with the Jump pad in the floor. Open the Textures menu, and choose "sfx". When the loading is finished, push "T" and open up the Textures window. If you scroll in the Textures window you will see that there are many jumppad-textures. This is because the texture should match your floor texture, choose the one that seems to have the same floor texture as in your map. </p>

<p>Then make a new box that is 128x128 units large (and maybe 8 units high). Place the new box with the jumppad texture at the same level as the floor and push the "CSG Subtract" button, as we did when we made a corridor. Now, push "S", and fix the texture so it's located at the right position. Now it might look like this:</p>
<br>
<center>
<img src="./content/quake3/tutorials/tutorial5/padplace.jpg"><br>
</center>
<br>
<p>Okay, now you can deselect the pad, with ESC. Now load a new texture. Load the "Common" textures. Now choose the very small texture called "trigger", it's tricky to find, but it should look like this:</p>
<br>
<center>
<img src="./content/quake3/tutorials/tutorial5/trig.jpg"><br>
</center>
<br>
<p>Now, make a new cube, that is the same size as the pad (128x128 units), but make it 16 units high. Place this new cube right on top of the Jumppad cube. It should look like this if you've done it right:</p>
<br>
<center>
<img src="./content/quake3/tutorials/tutorial5/trigger.jpg"><br>
</center>
<br>
<p>Now push right mouse button, then a small menu will be visible. Go down to "Trigger", and then Choose "Trigger_push". The box with the "trigger" texture will now be a "Trigger_push". </p>

<p>Push ESC to unselect it. <br>

<p>Then click the right mouse button again, go down to "Target", and choose "Target_position". </p>

<p>Push "n" to bring up the Entity window. In the "Key" box, type "targetname". The "Targetname" means the name of the entity, now enter a name for this entity in the value box. I choose the name "jump1", then I just enter "jump1" in the value box, and push <Enter>. It should look like this:</p>
<br>
<center>
<img src="./content/quake3/tutorials/tutorial5/position.jpg"><br>
</center>
<br>
<p>(Ignore the Origin, that's the position of the entity). This entity (the target_position) tells the "trigger box" what direction, and how high the jump should be. It tells the trigger box this, by it's position. But, not yet. First we need to "bind" the "trigger box" to the "target_position" entity. That's why we put a targetname on the entity, because now, you push ESC to unselsect the target_position entity, and select the box with the "trigger" texture. </p>

<p>Once you've selected it, push "N", to bring up the entity list. Now, simply type in the "Key" box "target" and in the value "jump1" (if you had the targetname "testjump1" on the entity, then you simply put the value "testjump1" here). Now, there should be a line from the trigger-box, to the entity This line simply shows the direction of the jump, and the player will reaches the highest point where the "trigger_position" is. To get the player up to the right place, simply move around the "trigger_position" entity Hope you can get it work now. If not, give me a note.</p>
</ul><h1 id="571" name="571" class="book-h3">Making Stairs</h1><ul><!-- tutorial1 - converted 25/08/04 from q3lab.telefragged.com -->
<h3>Quake III: Arena</h3>
<blockquote>
	<font class="title">
		Making Jumppads, Doors and Stairs -
		<a href="mailto:jon80@home.se">Jon Eriksson</a>
	</font>
</blockquote>
<br><br>	
					
 <p>Please note: this resource among other resources here at rust are no longer 
	updated and maintained by the original author any more. If you need to contact
	someone in regards to this, please contact the moderators of the Quake III Arena 
	Forum on the RUST website.

<p><hr width=75% color=black noshade><p>
<br>

<B><U>Stairs</B></U><br>

<p>Since Quake3Arena doesn't support Ladders, we have to make stairs or Jumppads. I'm going to show how to make very easy stairs. We have our map, as before. It should look something like this:</p>
<br>
<center>
<img src="./content/quake3/tutorials/tutorial5/jumpstart.jpg"><br>
</center>
<br>
<p>Now we want to reach the upper level, by making a stair. The first thing I do is to select the floor texture by pushing the middle mouse button on the floor in the 3D view. Then I make a new box that is 128 units long, 16 units wide, and 8 units tall. I copy this new box, by pushing <Ctrl> + C, and then paste a copy of it by pressing <Ctrl> + V (the new copy will be on the same place as the original one, so I move it a little bit. After doing this twice, so I have three boxes, my stairs have started (you don't follow what I mean, do you =), probably not), It should look like this now :</p>
<br>
<center>
<img src="./content/quake3/tutorials/tutorial5/stairstart.jpg"><br>
</center>
<br>
<p>Now, lets continue, by making more steps. Copy the objects till you reach the floor. It should look like this when you have done this :</p>
<br>
<center>
<img src="./content/quake3/tutorials/tutorial5/stairdone.jpg"><br>
</center>
<br>
<p>Tada, the first really basic stairs are done. Now you can change the texture on the top of each step to make it look really good, place two boxes on the side of the stair and so on. If you didn't get what I meant, give me a note.</p>
</ul><h1 id="835" name="835" class="book-h3">Patches 101</h1><ul><link href="themes/rusted/http://assets.aq2world.com/archive/websites/www.gamedesign.net/themes/rusted/rusted.css" rel="stylesheet" type="text/css"> 
<h3 align="center">GTKRadiant Patches 101 for Rusties</h3>
<h5 align="center">Greg (skinmaster) Crockatt</h5>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-patches.jpg" border="5"></center>
<p align="left" class="rustbg4">(<a href="/content/quake3/tutorials/gtk-patches-101/patches-101.zip">MAP FILE HERE</a>) 
  For this tutorial I'll be dealing only with the menu items show in the above 
  image. Thicken and cap are useful in their own ways but are not dealt with here 
  as my methods don't apply them often.</p>
<!--break-->
<p align="left" class="rustbg1">1st you should understand the concept of rows 
  and columns. A row runs horizontally on a patch, even if the orientation of 
  the patch changes a row will always stay a row based on its initial location. 
  A column runs vertically and will also always be a column based on its original 
  location. There's a means to convert rows to columns, reversing the control 
  orientation on a patch but it's unpredictable..<br><br>
<small class="r">NOTE - Using bobtoolz merge patches and split patches(pictured above) can somehow 
  force a row/column orientation change depending on if you've inverted one of 
  the merged patches and which direction the inversion was done on. It's often 
  best to make both sides seperately and distinguish betweeen them for future 
  use, texture application can be really screwed up if you merge a flipped patch 
  with its parent.</small>
<p align="left" class="rustbg1">Second you should know that every square or rectangle 
  surface on a patch will generate 2 triangles, 5 edges, 4 verts. The more faces 
  on a patch surface, the more edges and verts the engine must calculate and thus 
  you must be certain to optimize all your patch shapes down to their least row/column 
  counts.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-tris.jpg" border="5"></center>
<p align="left" class="rustbg1">Lets just start with something like a bent arch for use is a corridor or some such area..</p><br>

<p align="left" class="rustbg3">1. Make a brush and convert it into an endcap and make it like so.. #1 is top view, then a side insert to show height. 2 and 3 are top view also.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-1-2-3.jpg" border="5"></center>
<p align="left" class="rustbg3">2. Copy the endcap and rotate it z once, then  use the patch menu to delete the last two columns.<br>3. Duplicate and flip-x and put the dupe on the left side. You'll arrive at 3 (pictured above)</p><br>

<p align="left" class="rustbg3">4. Duplicate the three patches at once and place it above the originals. (the pics below are all grid 6)<br><br>5. Hit v to enter vertex editing mode while the patches are selected. 
Be sure you are editing all 3 patches at once.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-4-8.jpg" border="5"></center>
<p align="left" class="rustbg3">6. Drag a selection area around the top row of verts and select them. Hit the rotate x button on the toolbar (pictured above) and the verts will end up where 6 shows them to be.<br><br>
7. Drag the verts all together to the position show above, the top of our arch.<br><br>
8. Drag the remaining row verts to their right angle center points. Just hit v twice to turn off vertex editing and turn it back on, then drag a new selection box around the verts on all three patches at once.</p><br>

<p align="left" class="rustbg3">9. Deselect everything, select all the patches at once, duplicate 
and flip-y and move to the other side.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-9.jpg" border="5"></center></p>
<p align="left" class="rustbg4">Now that we've got our basic arch, lets see how we can improve it. This will involve working on one side, deleting the unedited side and replacing it with an updated mirror. I'm going to double arch it.</p>
<p align="left" class="rustbg3">10. Hide the right half, select the top three patches and insert two rows. This will create new vertexes which will of course.. be off the grid. Select all the verts and hit ctrl-g, this will snap them to the grid, then align them the following way.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-10-11.jpg" border="5"></center>
<p align="left" class="rustbg3">11. Delete the first two rows, this is where we can see that our earlier duplication and flip-x of out half endcap led to the inversion of its first and last rows. So we end up with most of what we need anyway.. we'll just compensate for it and work with what we've got.</p><br>
<p align="left" class="rustbg3">12. Duplicate and flip the pieces you need to fill in the holes, then vert edit the top two patches so that they are risen up a bit like so, keeping the right angle position of the middle verts. This ensures better texture application.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-12-13.jpg" border="5"></center>
<p align="left" class="rustbg3">13. Make a brush where i've made it and convert it to a 3x3 simple 
patch mesh.</p><br>
<p align="left" class="rustbg3">14. Move the bottom left vert right one square, then select all the bottom verts.<br><br>
15. Change to front view and move those three verts to the center, one unit left.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-14-16.jpg" border="5"></center>
<p align="left" class="rustbg3">16. Change back to side view and move the left middle vert down to the location of the previous left bottom one.</p><br>
<p align="left" class="rustbg3">17. Move the top left vert down to the bottom.<br><br>
18. Move the top middle vert over to the 90 degree point.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-17-19.jpg" border="5"></center>
<p align="left" class="rustbg3">19. Move the two remaining middle verts down to the bottom, you'll notice in camera view that because we move the other bottom verts to the side, we've created a nice bend on the bottom of this.</p><br>
<p align="left" class="rustbg3">20. Duplicate everything that needs it until you get the following geometry.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-20.jpg" border="5"></center><br>
<p align="left" class="rustbg3">21. The floor could be one brush but i want to trim the frame and this les me save on the overlap. Using three brushes in this manner give us no more or less tris, but it does remove a smll bit of overdraw that we'd get using only one brush. Using patches to avoid overlap completely is possible but it creates more tris than this method.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-21.jpg" border="5"></center><br>
<p align="left" class="rustbg3">22. Making the walls seam up to this door frame is less a problem than you might think, it's going to involve 2 simple patch meshes to do it, but they must meet the same point on the wall. That where the ceiling joins   it, so in order to do this properly, you must first decide how much more wall exists above the frame if any.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-22.jpg" border="5"></center><br><br>
<p align="left" class="rustbg3">23. Next you make a fan like so. Then insert it into the proper place described in the next image. <br><br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/fan.gif"><br>
<br>
<p align="left" class="rustbg3">24. Duplicate the fan, move the associated vertexes to fit it into the remaining hole.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-23-24.jpg" border="5"></center><br>
<p align="left" class="rustbg1">You ought to have something like this now.. I've been making both 
sides of the door at once, since I'm working with the pieces.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-door.jpg" border="5"></center><br>
<p align="left" class="rustbg3">25. This and the next step are merely to fill in the structural holes left by this type of modelling. Press ctrl-p to hide patches and fill in the three selected brushes in #25.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-25-26.jpg" border="5"></center>
<p align="left" class="rustbg3">26. To make the doorframe allow less visibility through it, I've taken steps in 26 to narrow it as close to the confines of its patches as possible. I did this procedure with patches visible, I've hidden them in this illustration so brushwork is clear.</p><br>
<p align="left" class="rustbg3">27. This step is just to show that the patches are moldable still 
if you grab them in the right places you wont create gaps. This step changes the look of the doorframe on one side only.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-27.jpg" border="5"></center><br>
<p align="left" class="rustbg3">28. I now make the surrounding geometry a little more complex. 
This has overlapping brushes for a very good reason. The larger brushes would have a large piece of overlap on the back side if I textured that face, so I leave it caulked and place another caulked brush in the correct areas with texture where the other brush has caulk. This uses two brushes to texture one volume, and does so at a savings.<br>
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-28.jpg" border="5"></center><br>
<p align="left" class="rustbg3">29. Lets make a couple of posts now for these patches that stick out. We'll make a top and a base (from cylinders) since they can be textured seperately, and we'll redisperse the columns of both so that we have the lowest possible number of tris.
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-29.jpg" border="5"></center>
<p align="left" class="rustbg3">Optimize. Finally we add AND insert two rows and two columns before redispersing them to get this geometry. You can see the difference between the optimized left patchwork and unoptimized right.
<center><img src="/content/quake3/tutorials/gtk-patches-101/gtkradiant-optimize.jpg" border="5"></center>
<p align="left" class="rustbg3">Here's how it looks after optimization and some random texturing..
<center><img src="/content/quake3/tutorials/gtk-patches-101/final.jpg" border="5"></center></ul><h1 id="101" name="101" class="book-h3">Perfect Arch Tutorial - Part 1</h1><ul><!-- q3Arch_1.html - converted 27/08/01 from old rust documents -->

<h3>Quake III: Arena</h3>
<blockquote class="title">Perfect Arch Tutorial - Part 1 <script language="JavaScript" type="text/javascript"> <!--
document.write('<a href="&#32;&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#116;&#97;&#116;&#116;&#111;&#111;&#64;&#101;&#110;&#116;&#101;&#114;&#97;&#99;&#116;&#46;&#99;&#111;&#109">tattoo</a>');
// --> </script></blockquote>
 <p>Please note: this resource among other resources here at the new rust are no longer updated and maintained by the original author any more. If you need to contactsomeone in regards to this, please contact the moderators of the Quake III Arena Forum on the RUST website.
<hr width=75% color=black noshade>
<h3>Part One</h3>
This tutorial will demonstrate the procedures that need be taken to make a perfect a arch. Ok, first you'll need to be in the <font color="#ff6600">XY TOP</font> view in the editor.<br><br>
Now make a brush and size it to the length of the arch you want. I went <font color="#ff6600">312 x 64.</font>
<br><br>
Go to the <font color="#ff6600">Curve</font> menu and select <font color="#ff6600">More Cylinders/Square Cylinder</font>.
<br><br>
<div align=center><img src="/content/quake3/tutorials/arch/q3Arch_PIC01.jpg"></div> Next, <b>WITHOUT</b> 
unselecting the Square Cylinder, change to the <font color="#ff6600">YZ SIDE</font> 
view so you can see the rows of the Cylinder. <br>
<br>
You'll notice that there are <font color="#ff6600">6 Rows</font> from top to bottom.
<br><br>
You'll want to add another set of Rows to this Square Cylinder - You'll see why in a minute.
<br><br>
Now go to the <font color="#ff6600">Curve</font> menu again and select <font color="#ff6600">Insert/Insert (2) Rows</font>.
<br><br>
<div align=center><img src="/content/quake3/tutorials/arch/q3Arch_PIC02.jpg"></div>
<br><br>
A little explanation of Rows &amp; Columns is that <i>Rows</i> go the length of the brush and <i>Columns</i> go around the brush, so you'll have <font color="#ff6600">6 Rows</font> and <font color="#ff6600">24 Columns</font> in a default Square Cylinder. You'll see here that there are now <font color="#ff6600">12 Rows</font> now.
<br><br>
Again, without deselecting the Square Cylinder,	go to the <font color="#ff6600">Curve</font> menu and select <font color="#ff6600">Matrix/Re-disperse/Rows</font>.<br><br>
<div align=center><img src="/content/quake3/tutorials/arch/q3Arch_PIC03.jpg"></div>
<br><br>
This is what the Square Cylinder looks like after you select the <font color="#ff6600">Matrix/Re-disperse/Rows</font> from the <font color="#ff6600">Curve</font> menu.
<br><br>
This makes the Square Cylinder have the proper shape when bending.
<br><br>
Now save your map so you don't lose any of this. I've messed up many of these and had to start all over again.
<br><br>
<div align=center><img src="/content/quake3/tutorials/arch/q3Arch_PIC04.jpg"></div>
<br><br>
What I do is after I get this far, before trying to bend it, I'll make a copy of the Square Cylinder so I don't have to redo it all again.<br>
After you get this down, though, you won't have to be so worried about messing up.  Now, stretch the Square Cylinder to make it longer.
<br><br>
Figure out about how long you'll be needing it to make the curve.<br>It doesn't matter a whole lot what length it is right now, it's just easier to use this way.
<br><br>
You can resize it to the correct size later.
<br><br>
Now, from the Button Bar, with the Square Cylinder still highlighted,  select the <font color="#ff6600">Patch Bend Mode</font> button. <font color="Red">The Red Arrow</font>.<br>
After selecting it the Information window will pop up. This tells you what to do.
<br><br>
<div align=center><img src="/content/quake3/tutorials/arch/q3Arch_PIC05.jpg"></div><br><br>
Ok, this is where this gets tricky. Bare with me. This is where you will choose what point the Square Cylinder is bent from. I circled the <font color="#ff6600">Bend Axis</font> dots, this is where the Square Cylinder bends.
<br><br>
You use the Tab button on your keyboard to cycle thru the available <font color="#ff6600">Bend Axis</font>. When you get to the point where you want to bend it from, hit enter to select that point.
<br><br>
You shouldn't have to 'Tab' thru them. The first point should look like the picture with the <font color="#ff6600">Bend Axis</font> at the correct point. If they are not like the picture, 'Tab' thru and get them at the first point that looks like the picture.
<br><br>
When you get the <font color="#ff6600">Bend Axis</font> at the point in the picture, hit enter 'Only once', then change back to the <font color="#ff6600">XY TOP</font> view.Now you should see a blue dot as one of the Bend Axis points.<br>
the picture to the left of the top two shows what you should be looking at.
<br><br>
This blue dot is the another bending point for the Square Cylinder.
<br><br>
From here, you'll use the 'Tab' button again to move the blue dot around to the center dot of the side that will be bent. The picture to the right of the top two shows how it should look.
<br><br>
Now switch to the <font color="#ff6600">XZ FRONT</font> view and change the grid to <font color="#ff6600">Grid1</font>.<br>
Take your mouse and bend the Square Cylinder until the end of it is perfectly squared with the grid lines. This is VERY important.<br>
You'll probably have to zoom in to see this. I have to any ways.
<br><br>
The bottom picture shows what it should look like.
<br><br>
Now, save your work!!
<br><br>
<div align=center><img src="/content/quake3/tutorials/arch/q3Arch_PIC06a.jpg">&nbsp;<img src="/content/quake3/tutorials/arch/q3Arch_PIC06b.jpg"></div><br><br>
<div align=center><img src="/content/quake3/tutorials/arch/q3Arch_PIC06c.jpg"></div><br><br>
Next, hit ESCAPE to unselect the Square Cylinder.<br>
We'll have to go thru the steps to select the Bend Axis again.
<br><br>
Hit the Bend Axis button again and 'Tab' to the next point in the SquareCylinder. The top picture shows what you should be looking at. Hit enter, only once, to lock it in and move the blue dot around again to the same point as in the previous bend.
<br><br>
<div align=center><img src="/content/quake3/tutorials/arch/q3Arch_PIC07.jpg"></div>
<br><br>
<div align=center><img src="/content/quake3/tutorials/arch/q3Arch_PIC08.jpg"></div>
<br><br>
Make certain that your grid is set to <font color="#ff6600">Grid1</font> again.
<br><br>
Now bend this other end until the end of it is perfectly squared with the grid lines. Again this is 'VERY' important.
<br><br>
Your Square Cylinder should look like the bottom picture. Both ends of the Square Cylinder should be perfectly in line on 'ONE' grid line. If it is not, you've done something wrong and will have to correct it before proceeding.<br><br>
Right now, your Square Cylinder should be an arch. Upside down, but this is ok for now. If everything is correct, we can proceed after you save your work, of coarse.
<br><br>
Now on to <a href="/book/view/102">Part Two</a>!
<!-- eof @ 203 --></ul><h1 id="102" name="102" class="book-h3">Perfect Arch Tutorial - Part 2</h1><ul><!-- q3Arch_1.html - converted 27/08/01 from old rust documents -->

<h3>Quake III: Arena</h3>
<blockquote class="title">Perfect Arch Tutorial - Part 2 - <script language="JavaScript" type="text/javascript"> <!--
document.write('<a href="&#32;&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#116;&#97;&#116;&#116;&#111;&#111;&#64;&#101;&#110;&#116;&#101;&#114;&#97;&#99;&#116;&#46;&#99;&#111;&#109">tattoo</a>');
// --> </script></blockquote>

Please note: this resource among other resources here at the new rust are no longer 
	updated and maintained by the original author any more. If you need to contact
	someone in regards to this, please contact the moderators of the Quake III Arena 
	Forum on the RUST website.

<hr width=75% color=black noshade>

 This tutorial will demonstrate the procedures that need be taken to make a perfect a arch. Ok, now, you'll probably want to turn your arch around the proper way. You don't have to right now. It's just the way I've done it. The way it looks now would work, but it's not the way to go if you want perfection.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch2/q3Arch_PIC09.jpg"></div>
<br><br>
You'll notice from the picture that the shape of this isn't correct. The 
			ends and the very top are are not sized correctly with the grid. It 
			doesn't hit both sides of the major grid to make a 64 unit square. It's 
			more like 58 or 59. And in between that it is squeezed a little. This is
			what we're going to fix.
<br><br>
From here, we're going to drag the vertices to get the correct shape.
<br><br>
First you'll need to resize this to a descent grid size. I like to use 
			<font color="#FF6600">Grid16</font>, but you may use what ya like. You'll 
			want to resize it to the size you want it to be when finished. The only
			important thing here is that only the 
			<font color="#FF6600">outer edges</font> of this should be hitting the 
			major grid. This makes it easier on you to get it to where it needs to be 
			with the way I do this. You'll find out later on what I mean by this as 
			you make more of these. Also, I don't know if this is the way the guys at 
			ID Software does their arches, it's just the way I found to do it to look 
			correct.

			Ok, from here, you'll need to make an <font color="#FF6600">End cap</font>. 
			I use the End cap because it the correct shape already and does not need
			to be reshaped. It is the standard shape of all the curves in Quake III 
			Arena.
<br><br>
First draw another brush, any size, and go to the 
			<font color="#FF6600">Curve</font> menu and select
			<font color="#FF6600">End cap</font>. Now turn it and position it by your 
			arch to look like the picture.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch2/q3Arch_PIC10.jpg"></div>
<br><br>
From this you can see where the 
			imperfections are. Make CERTAIN that the End cap is positioned correctly 
			on the major grid lines, as shown. After you've done that, unselect the 
			<font color="#FF6600">End cap</font> and select the arch. you may have to 
			move these around a little so you can select each one when you like. By 
			that, I mean, the <font color="Yellow">End cap</font> should be in front 
			of the arch.
<br><br>
After you have everything in position and the arch selected, go to the 
			<font color="#FF6600">Selection</font> menu and select 
			<font color="#FF6600">Drag/Drag Vertices</font>.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch2/q3Arch_PIC11.jpg"></div>
<br><br>
Here you should see the <font color="#FF6600">Vertices</font> around the 
			arch. These are what we move to reposition the arch so it is the correct 
			shape. Now, this can get a little tricky too. First, save your work. You 
			don't have to unselect anything to so.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch2/q3Arch_PIC12.jpg"></div>
<br><br>
First you'll need to set your grid again to <font color="#FF6600">Grid1</font> 
			and zoom in to see the grid lines. Now, go to the bottom left end of the arch 
			and position your mouse over the right <font color="#FF6600">Vertice</font>.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch2/q3Arch_PIC13.jpg"></div>
<br><br>
Now press and hold the left button and drag the corner right 
			<font color="#FF6600">Vertice</font> to the right so that the corners of 
			both the arch and the <font color="#FF6600">End cap</font> are perfectly 
			in line.
<br><br>
One thing you'll have to be careful about is if you click on a 
			<font color="#FF6600">Vertice</font> and let off and go right back to it 
			and drag it again, you'll notice that there are more 
			<font color="#FF6600">Vertices</font> under the one and/or ones you moved. 
			This can get aggravating. Not to worry though. Just hit escape and move 
			the <font color="#FF6600">Vertice</font> back to where ya started.
<br><br>
There are 5 <font color="#FF6600">Vertices</font> that need to be moved 
			for the bottom. Then 5 for the top and 5 for the middle. There are 15 
			<font color="#FF6600">Vertices</font> all together that need to be 
			moved.
<br><br>
Ok, now go onto the middle bottom <font color="#FF6600">Vertice</font>.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch2/q3Arch_PIC14.jpg"></div>
<br><br>
Now align that to the very top of the 
			<font color="#FF6600">End cap</font>. Now go on to the right end of the 
			arch.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch2/q3Arch_PIC15.jpg"></div>
<br><br>
Align this one up with the corners. Now just move up to the 
			<font color="#FF6600">Vertice</font> between the right end and the middle 
			one.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch2/q3Arch_PIC16.jpg"></div>
<br><br>
This one is a little tricky. The <font color="#FF6600">Vertice</font> 
			isn't at the corner or where the lines meet but up into the arch a 
			little. You can see it in the picture. Just move it down and to the left
			and align the line of both the Arch and the 
			<font color="#FF6600">End cap</font>. Now one more at the other end.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch2/q3Arch_PIC17.jpg"></div>
<br><br>
Same as the last. Line it up the same way. Now zoom out and the next picture is what it should look like all lined up.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch2/q3Arch_PIC18.jpg"></div>
<br><br>
This is the way it looks with the correct shape at the bottom.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch2/q3Arch_PIC19.jpg" width="450"></div>
<br><br>
Now save your work and we'll move onto the top <font color="#FF6600">Vertices</font>.<br>
Which is <a href="/book/view/103">Part Three</a></ul><h1 id="103" name="103" class="book-h3">Perfect Arch Tutorial - Part 3</h1><ul><!-- q3Arch_1.html - converted 27/08/01 from old rust documents -->
<h3>Quake III: Arena</h3>
<blockquote class="title">Perfect Arch Tutorial Part 3 - 
<script language="JavaScript" type="text/javascript"> <!--
document.write('<a href="&#32;&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#116;&#97;&#116;&#116;&#111;&#111;&#64;&#101;&#110;&#116;&#101;&#114;&#97;&#99;&#116;&#46;&#99;&#111;&#109">tattoo</a>');
// --> </script></blockquote>
Please note: this resource among other resources here at the new rust are no longer updated and maintained by the original author any more. If you need to contactsomeone in regards to this, please contact the moderators of the Quake III Arena Forum on the RUST website.
<hr width=75% color=black noshade>
<h3>Part Three</h3>
 This tutorial will demonstrate the procedures that need be taken to make a perfect a arch. Ok, this should be easy for you now and I probably don't need to write the rest of this but I'm going to just for the people that might need it.
<br><br>
What you need to do here is unselect the Arch and select the <font color="#ff6600">End&nbsp;cap</font>. You'll need to resize it to the outer edges of the Arch and you'll see how the top of the Arch is out of shape. After you resize it, you'll have to reposition the <font color="#ff6600">End&nbsp;cap</font> so that you can select the Arch. Now select the Arch again and we'll start.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC20.jpg"></div>
<br><br>
As you can see here there are only two <font color="#ff6600">Vertices</font> that need moving. The two corners and middle are already in line. Now go to the <font color="#ff6600">Selection</font> menu and select <font color="#ff6600">Drag/Drag&nbsp;Vertices</font>. The top left <font color="#ff6600">Vertice</font> is the one that we'll be moving.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC21.jpg"></div>
<br><br>
After you have selected <font color="#ff6600">Drag/Drag&nbsp;Vertices</font>, change your Grid again to <font color="#ff6600">Grid1</font> and zoom in and move the <font color="#ff6600">Vertice</font> to the upper left corner as shown in the picture.
<br><br>
Now for the right side.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC22.jpg" ></div>
<br><br>
Here, you'll do the same thing as the left side. After this one isaligned, unselect it and zoom out and you'll how it looks all lined upped as in the next picture.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC23.jpg" ></div>
<br><br>
Don't forget to save your work.
<br><br>
Now there's only one more thing to do. That's resize the <font color="#ff6600">End&nbsp;cap</font> so that it is aligned with the center of the arch like in the next picture.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC24.jpg" ></div>
<br><br>
You really can't see if it is out of line or not and probably wouldn't even matter but if you zoom in and look closer like in the next picture, you'll see that it isn't correct.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC25.jpg" ></div>
<br><br>
Here you'll see that it 'is' off a little. This probably wouldn't make adifference, but, just for the correct alignment I'm going to go ahead andalign this too.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC26.jpg" ></div>
<br><br>
The <font color="Red">red circle</font> is the <font color="#ff6600">Vertice</font> we will be moving.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC27.jpg" ></div>
<br><br>
This is where it ended up and is aligned. Now go to the right side and move that one.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC28.jpg" ></div>
<br><br>
This is where this one is aligned. Now we'll check the middle to see if it needs to be aligned.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC29.jpg" ></div>
<br><br>
This needed to be aligned as well. Now we'll go to the left end and align that one.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC30.jpg" ></div>
<br><br>
This one needed aligning. Now go to the right end.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC31.jpg"></div>
<br><br>
This needed aligning as well. Ok, now zoom out and you'll see how it looks.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC32.jpg"></div>
<br><br>
Here is the finished arch. I've taken and made three <font color="#ff6600">End&nbsp;caps</font> and put them in, as you can seeof coarse just so you would see how it looks all lined up.
<br><br>
And there ya have it,<br> 
<font color=#6699CC><b>'The&nbsp;Perfect&nbsp;Arch'</b></font>.
<br><br>
<div align="center"><img src="/content/quake3/tutorials/arch3/q3Arch_PIC33.jpg"></div>
<br><br>
Well, that was my good deed for today. I sure hope this helps someone out. I don't want anyone to think that I'm a Q3Radient guru or anything. This is just something I figured out since it's release and wanted to share what I have learned with everyone else that is wanting to make	killer maps for Quake III Arena. I might write another tutorial on other things as I learn them. Just right now, I need to concentrate on the making of my own map.
<br><br>
All the credit I can give for my knowledge 	would be to raYGunn and the rest of the crew at <a href="http://www.gamedesign.net/">RUST</a>.<br> 
They are who I turn to when in need of an answer. Thanks guys...
<br><br>
<script language="JavaScript" type="text/javascript"> <!--
document.write('<a href="&#32;&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#116;&#97;&#116;&#116;&#111;&#111;&#64;&#101;&#110;&#116;&#101;&#114;&#97;&#99;&#116;&#46;&#99;&#111;&#109">tattoo</a>');
// --> </script><br><br>
[Ed. Note: Example map can be found <a href="/content/quake3/tutorials/arch3/Perfect_arch.map">here</a>.]</ul><h1 id="664" name="664" class="book-h3">Prefabricated Prefabs in GTKradiant</h1><ul><h3>Prefabs? Easy.</h3><p class="q3bg3"><b>What's a prefab?</b><br>Answer: It's a collection of brushes and patches that together make some sort of prefabricated object that's something you'd like to use over and over throughout an area in the creation phase of a current and/or future map. A prefab can be a column, an arch, a room, a cabin, a sign, virtually anything.</p><!--break-->
<p class="q3bg3"><b>How do prefabs work?</b><br>Answer: There's two ways to make a prefab:<br><br><i>1.</i> Select the associated brushes and patches, and save them as a map file in a folder like baseq3/prefabs.<br>
<i>2.</i>Or you can possibly (depending on your version) export the selected brushes as .pfb files which is basically the same thing.<br><br>Once you're ready to use the prefab, just import it and place it, then dupe and re-use throughout.</p><span class="r">Pretty simple huh? - skinmaster</span></ul><h1 id="898" name="898" class="book-h2">Tutorials (Modelling)</h1><ul><h3>Modelling Tutorials for Quake III</h3>
<p class="q3bg3">This section covers everything from creating new player models, bots and level objects to creating skins, uv texturemapping and creating md3s. Review each section carefully and if you have any questions refer to the <a href="http://forums.gamedesign.net/viewforum.php?f=15">Quake III Arena</a> forum.</p></ul><h1 id="899" name="899" class="book-h3">Putting New Models in Quake III Arena</h1><ul><h3>Putting new Character Models into Quake III</h3>
<p class="q3bg1">Based on original notes by Paul Steed / Edited by Paul Jaquays / Edited 12/22/99 by ps (QERadiant.com thanks John Hutton for re-formating <a href="http://www.qeradiant.com/manual/Model_Manual/model_manual.htm">this manual</a> into a more web friendly version)</p>
<p class="q3bg3">The purpose of this document is to explain how to set up a model for Quake 3 Arena, create the necessary animation and conversion files, and then export it into the MD3 format required by the game. It is intended to be informative only and not a tutorial on building or animating models.<br><br>The player models for Quake III Arena were built using the commercial modeling software, 3D Studio Max R2.5 (3ds Max) by Kinetix. These models were then animated using Physique and Biped, components of a plugin for 3dsMax called Character Studio (also by Kinetix). The following instructions assume that you will model and animate with 3dsMax and Character Studio.<br><br><a href="http://www.qeradiant.com/manual/Model_Manual/model_manual.htm">This manual</a> includes the following sections:<br><br>Setting up the Files<br>Building and Naming the Mesh<br>Texturing<br>Set Up for Animation<br>Animation<br>Setting up Tags<br>Level of Detail<br>Exporting<br>Animation Config File<br>The Conversion Process<br></p>
<p class="q3bg1b"><a href="http://www.qeradiant.com/manual/Model_Manual/model_manual.htm">Click here to visit this Manual page at QERadiant.com</a></p></ul><h1 id="563" name="563" class="book-h2">Tutorials (Shader and Scripting)</h1><ul><p class="q3bg1">Quake III Arena Shader Tutorials<br><br>
Here you'll find an assorted and growing collection of tutorials for Quake III Arena and the editro GTKradiant or QERadiant. These tutorials cover, texturing, scripting, texture creation, advanced scripting, and much more.<br><br>
If you have a tutorial you'd like to submit to the collection, or if you have suggestions for revisions to existing tutorials, jump into the <a href="http://forums.gamedesign.net/viewforum.php?f=15">Quake III Arena Game Design Forums!</a></p></ul><h1 id="578" name="578" class="book-h3">Alpha Channels and Transparencies</h1><ul><p class="q3bg3"><b>There are 2 methods</b> to make transparencies in Quake 
III. <br><br>
One alpha method works with normal optimized jpgs and one with 24 bit TGAs. The one 
that works with jpgs needs either a 100% black background or a 100% white background 
in order to work(depending on scripting). The one that works with TGAs needs a 
proper 8 bit alpha channel saved in the tga. This involves for some older photoshop 
users a <a href="http://www.adobe.com/support/techdocs/327530.html">plug-in</a> thats available from Adobe. 
(Some older versions have a faulty tga exporter and do not include the alpha channel 
upon export).<br>
<br>
In order to decide what type of alpha you will need, just figure out the difference 
between how the two work. If you want something thats solid, but has the cookie 
cutout edges to it, you'll want to go the TGA route.. If you want a fuzzy flare 
or beams of dusty sunlight.. the jpg is the path to take.. If you're making a 
jump pad you will often combine both tga and jpg in order to achieve an overall 
layered effect.</p>
<h4 align="center">JPG Examples</h4>
<p class="q3bg1b"><small>a)<img src="/content/quake3/tutorials/alphas/blue_flare.jpg"> 
b)<img src="/content/quake3/tutorials/alphas/laserfx.jpg"> 
c)<img src="/content/quake3/tutorials/alphas/light-vert-trim-1.jpg"> 
d)<img src="/content/quake3/tutorials/alphas/light-vert-trim-2.jpg"> 
e)<img src="/content/quake3/tutorials/alphas/red-laser.jpg"><br><br>
a) A 128x128 black bg jpg image of a blue lense flare.<br>
b) A 64x256 black bg up/down scrolling modulating static field blend stage image.<br>
c) A 64x256 black bg up scrolling light/blend stage image.<br>
d) A 64x256 black bg up scrolling light/blend stage image.<br>
e) A 64x256 white bg up/down scrolling modulating energy field blend stage image.</small></p>
<p class="q3bg1">An example jpg script for a light fixture beam/flare sprite.. This is a simple square shaped black background jpg image with an air brushed type of flare effect on it. You can make anything you like and substitute in tcmod effects so that it grows and shrinks or rotates.. <a href="/book/view/798">See the</a> Q3MAP2 Shader manual for info about tcmod..<br><br>//NOTE - comments are preceeded by two forward slashes in Quake III shader files (*.shader) which can be edited by associating .shader with notepad or by using a shader GUI like Q3Ase.</p>
<h4>Example JPG Script</h4>
<pre>textures/foldername/shadername <span class="r">//Shader name</span>
{ <span class="r">//script opening tag</span>
surfaceparm nolightmap <span class="r">//Don't light it</span>
surfaceparm nomarks <span class="r">//Don't let bullets mark it</span>
surfaceparm trans <span class="r">//It's See through</span>
surfaceparm nonsolid <span class="r">//It's not solid</span>
cull disable <span class="r">//It's going to be seen from both sides</span>
deformVertexes autosprite <span class="r">//It's going to always face the player</span>
qer_trans .5 <span class="r">//In the editor it's semi transparent</span>
{ <span class="r">//script mid-opening tag</span>
clampmap textures/ecel/flare.tga 
<span class="r">//This clamps the pixels to the face for rotating</span>
blendFunc add <span class="r">//Adds the value of the sprite pixels</span>
} <span class="r">//script mid-closing tag</span>
} <span class="r">//script closing tag</span></pre>
<p class="q3bg1">An example of a side scrolling 24 bit TGA image of mist with 
an 8 bit alpha channel to define the mist edges. Removing the tcmod information 
will stop the mist from moving.. this could be people or cars or anything really 
moving along at a nice smooth pace..<br><br>
Get the TGA <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/content/quake3/tutorials/alphas/mist.zip">here</a></p>
<h4>Example TGA Script</h4>
<pre>textures/leafland/mist <span class="r">//Shader name</span>
{
surfaceparm nomarks
surfaceparm nonsolid
surfaceparm trans
qer_trans 0.5
qer_nocarve <span class="r">//Exclude this from cutting during compile</span>
cull disable
 {
 map textures/leafland/mist.tga
 tcMod scale 1 4 <span class="r">//1 high and 4 wide</span>
 tcMod scroll 0 .07 <span class="r">//moving left slowly</span>
 blendFunc blend <span class="r">//um.. this ought to be different.. like,</span>
<span class="r">//GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA</span>
<span class="r">//also see shaderlabs shader manual for info on blending</span>
 rgbGen vertex <span class="r">//Lights itself</span>
 }
}</pre></ul><h1 id="564" name="564" class="book-h3">Basic Shaders - Part 1</h1><ul><!-- by old Q3Lab Tutorial -->
<h3>Basic Shaders - Part 1<br><span class="tinytext">Created by Alvar Jansson</span></h3>
<h4>Preface:</h4>
<p>This tutorial tries to resolve the meaning of "shader" and also create some simple ones ourselves. Unfortunately, shaders are a *very* complex subject, one that isn't easily explained in half a minute.<br><br>
You should download the Official <a href="http://www.heppler.com/shader/">Quake 3 Shader Manual</a>, or you will go nuts, when you don't understand something! You should also get the cool program <a href="http://www.jgsoft.com/">Editpad</a>, this is because q3radiant has a routine for editing shaders, based on the use of Editpad.</p>
<hr>
<h4>Basic Shader Concepts</h4>
<b>1: What is a shader?</b><br><br>
<p>A shader is a script, that tells the q3 engine, how to treat the surface. A shader may not only change the way a surface looks, but as well as the actual shape of it, (like water waves). The shader also affects how the surface behaves in the game (if it is non-solid, or a water surface).</p>
<b>2: How do I use shaders?</b><br><br>
<p>You have probably used shaders allready, you see, most of the "textures" in q3 radiant are actually shaders. You can tell the difference by looking at the thumbnail in the texture window, all shaders have a white border. It is not necessarily the texture that shows in the editor, that you will see in the game.</p>
<b>3: How do I make my own?</b><br><br>
<p>This is not as hard as you might think. First, you make a new shaderfile in the baseq3\scripts path, it should have the extension .shader, you may want to call it the same name as your level, like if you made some cool blood shaders for use in your splat.map, you could call your file splat.shader, for this tutorial, create tut.shader. Now, we have to make an entry in the file shaderlist.txt. This is to make q3radiant load our shaders, type tut in the end of the file. To see our shaders in the textures menu, we also have to make a new folder under the textures folder, call it the same as your shaderfile (baseq3\textures\tut\). If you now (re)open q3radiant, you will see a new entry in the textures menu called tut, for now, it is empty.</p>
<hr>
<h4>Make Your first Shader</h4>
<p>We are now set up to make our first shader! We will start out by adjusting the strength of a light emitting texture. (This a good place to point out the fact that neither the Surf flags nor the Content flags in the Surface inspector have ANY effect in quake 3, they are ONLY for quake2 editing! The surface inspector is only good for sizing/moving textures in q3 editing)</p>
<p>Let's get started! make a small room, make two lamp brushes and apply the base_light/baslt4_1_2k shader to the bottom face (and of course a non-light texture to the other faces). </p>
<center><img src="content/quake3/tutorials/shadertut1/editor1.jpg"></center>
<p>(As you see you can run q3 in a window, at the same time as q3radiant, I doubt this will work without a sturdy amount of ram (like 128 mb)) So, what if we want the light a little dimmer on one of the lamps? Well, then we have to make a shader of our own! Open the texture window (textures in use) and shift click on the light texture. If Editpad is correctly installed, it will now open, browsing down to the beginning of the shader. Now select the whole shader (as you probably have guessed, the shader consists of the declaration, and all the indented text, including the brackets). Copy the selected text, now open tut.shader (your empty shader script which we created earlier) and paste the text, we should now be here:</p>
<center><img src="content/quake3/tutorials/shadertut1/editor2.jpg"></center>
<p>First, to avoid conflicts, rename the shader. This is done by changing the line:</p>
<blockquote>textures/base_light/baslt4_1_2k<br>to<br>textures/tut/mylight_2k</blockquote>
<p>Now save the shader script choose textures|shaders|Load all (reload) from the q3radiant menu to reload the shaders. You should now see your shader if you load the texture set textures|tut. Apply your shader to one of the lamps, and bsp the map. The map should look the same. And now for the actual change! Enter the shader script and change the line:</p>
<blockquote>q3map_surfacelight 2000<br>to<br>q3map_surfacelight 500</blockquote>
<p>This will cut the ammount of light emitted by the surface in half. To reflect the change, rename your shader to mylight_500. Reload the shaders, and apply your new shader (q3radiant will think that your old shader is still there, I suppose this is a bug, and the old shader will disappear next time you restart q3radiant). Bsp the map, you will now clearly see that the left lamp, which we edited has a dimmer light.</p>
<center><img src="content/quake3/tutorials/shadertut1/editor3.jpg"></center>
<p>So, how do they get that fancy colored light then? This one is not as straight forward... If you study the .pk3 files, you can see that the light textures also have a blend texture. (This is a picture of the light emitting parts of the light, for example, the blend file for baslt4_1.tga is baslt4_1.blend.tga /*baslt4_1.tga baslt4_1.blend.tga */) In quake 3, the blend texture is drawn fullbright, using the formula: blendfunc GL_ONE GL_ONE This texture is also drawn last, so that it covers the other textures. When rendering the lightmap, q3map uses the average of all the pixels in the texture. For our light, this means gray, with a little brown, but if we want a blue light? Well, if we take a look at the shader textures/gothic_light/ironcrosslt2_2000 It contains the line</p>
<blockquote>q3map_lightimage textures/gothic_light/ironcrosslt2.blend.tga</blockquote>
<center><img src="content/quake3/tutorials/shadertut1/baslt4_1.jpg"></center>
<p>This makes q3map use the specified texture, instead of the default. This was made, because the designer wanted a more yellow light than the original texture would give. Now we want to make a cool blue light! Then we need a blue lightimage. I saved you the trouble. download the tga by pressing the picture.(right-click|save target as)</p>
<blockquote><b>DO THE FOLLOWING:</b><br><br>
- Place it in your baseq3\textures\tut folder.<br><br> 
- Copy the entire shader script nd paste it below, so that you have two identical shaders.<br><br>
- Rename the new one to mylight_500_blue<br><br> 
- Now inert the line q3map_lightimage 
textures/tut/baslt4_1.blueblend.tga just above the q3map_surfacelight line.<br><br> 
- Change the map textures/base_light/baslt4_1.blend.tga line in the final shader stage to map textures/tut/baslt4_1.blueblend.tga this will give the texure a blue look too.</blockquote>
<center><img src="content/quake3/tutorials/shadertut1/editor4.jpg"></center>
<p>Now that you have a some sort of clue of what shader editing is all about, we are going to do something that a lot of people have asked about, which is changing the look of fog.</p>
<blockquote><b>DO THE FOLLOWING:</b><br><br>
- Create a pit where the fog will reside, and make a big brush that covers the pit, remember that only one side of the brush should be visible, the fog may be bigger than the space that it should fill, the brushes inside it will show up correctly.<br><br>
- Shift-click the shader, (that one didn't work for me, if it just steps to the end of the sfx.shader, use the find function to search for fog_intel, or use the go to line function and type in 5020). Copy the fog_intel shader and paste it to your own tut.shader.<br><br> 
- Rename the shader to textures/tut/fog_yellow1 Reload the shaders in q3radiant and apply your yellow_fog1 to the fog brush. Bsp, and you will hopefully see the yellow smog.</blockquote>
<center><img src="content/quake3/tutorials/shadertut1/editor5.jpg"></center>
<p>But, we would like a green smog instead, so we have to modify the shader. The fog's appearance is controlled by a function called fogparms.</p>
<p>fogparms ( .75 .38 0 ) 800 means ( r g b ) distance-to-opaque The r, g and b values are the same as for lights, they range from 0 to 1 and thereby controls the color of the fog. Distance-to-opaque is the distance, in game units, from the player, to the point where the fog stops being transparent.</p>
<p>So lets make that fog <i>green</i>! Copy the shader and paste another copy of it below, name it fog_green1 Very well, a nice poisionus color is ( 0 0.7 0.2 ). (don't forget the spaces inside the paranteces, your fog will just be a gray grid without them).</p>
<center><img src="content/quake3/tutorials/shadertut1/editor6.jpg"></center>
<p>As you experiment with colors, a good thing to notice is that the shaders stand free of the bsp, if you want to experiment with different settings, well, except the q3map parameters (duh..), You don't have to re-bsp your map, just save the shader file, and restart your map (nom \map_restart won't work... use the \map command).</p>
<p>But, you have seen that flashy hellfog with moving textures on it, well, let's take a look at it!</p>
<p>Snatch the hellfog shader from the sfx.shader and paste it to our file, rename it tut/myhellfog make a cosy little hellfog pit so that we can study it a little closer. As you see, it emits light, because the surfacelight parameter. There is also two texture passes, they both apply the same texture, though one of them is flipped, this makes for a darker texture, as well as a little more complexity. The tga texture is white, so we are free to create a nice blue strange hellfog, by changing the color to ( 0 0.1 0.4 ). But... even if I re-bsp the emitted light is red! Now this is a little problem, that we could easily fix by making a 16*16 (or whatever) tga file filled with blue, and specify it as q3map_lightimage, but today I am lazy so I specify our good old baslt4_1.blueblend.tga which is blue by nature. So, add the line q3map_lightimage textures/tut/baslt4_1.blueblend.tga </p>
<center><img src="content/quake3/tutorials/shadertut1/ingame1.jpg"></center>
<p>Goodluck and I hope you have learned something new!</p></ul><h1 id="575" name="575" class="book-h3">Basic Shaders - Part 2</h1><ul><!-- by old Q3Lab Tutorial -->
<h3>Basic Shaders - Part 2<br><span class="tinytext">Created by Alvar Jansson</span></h3>
<h5>Preface:</h5><p>This time we're going to make a Space map. Before we begin I want to say that we will not use the already used space texture. This time we will make our own texture, shader ... and space! If you don't want make a space texture, just move down to step 3 in this tutorial.</p>
<hr>
<h4>Step 1:</h4>
<p>We first begin with making a new texture that we will use as a "space sky". I will use my Photoshop to make this texture, and i make it 256x256 pixels big. Now you can make it black only, or maby add some white spots that should looks like stars. My one looks like this:</p>
<center><img src="content/quake3/tutorials/shadertut2/sky.jpg" width="250"><br></center>
<p>As you can see i try to make it very dark. I do this because of the Quake3Arena engine will make all textures much more brighter. I will place this texture under the "baseq3/textures/tutorial" directory. Now, we have a texture. Should we load up the Q3radiant now? Nope, q3radiant checks for shaders that it uses for "compiling" the map. Therefor we need to make a shader for this new "sky".</p>
<hr>
<h4>Step 2:</h4>
<p>Why do we need shaders for this texture? Well, first of all we don't want the guns to do impacts on it. To do this, we need to use shaders. I will try to explain each line below.<p>
<div class="r"><pre>
textures/tutorial/sky
{
//*********************
//***Space map shader***
//*********************
surfaceparm nomarks
surfaceparm noimpact
{
map textures/tutorial/sky.tga 
}
}</pre></div>
<p>Like that, now. Note that the lines with // infront of it is comments, and will not have any effect of the shader. Copy the code above, and place in a new file called &quot;my.shader&quot; under baseq3/scripts.</p>
<p>Also add a new line &quot;my&quot; in the shaderlist.txt too.</p><h5>What does all this do?</h5>
<p>The first line &quot;textures/tutorial/sky&quot; is a quick note what texture you're using. The &quot;surfaceparm&quot; lines tells Quake3Arena what surface parameters that will be used. The first one changes so there's nomarks, and the other one makes the guns make noimpact. Now we just have to move on to the fun part, making the map itself =).</p>
<hr>
<h4>Step 3:</h4>
<p>Now we have a new texture, we have the shader for this new texture. What we need is a map. Let's load up Q3radiant.</p>
<p>This part is very easy. Simply make your map, and then place a new very big room around the map, with the new "space sky" texture on it.</p><h5>Note:</b> You have to place lights to get the level bright. But, if you have made a space map looking like Q3DM17, then the hole level should have the same light. Easy to do!</p> 
<p>Select one of the boxes on the map (not entities, the other map objects). Push "N" to bring up the Entity list. It should now say that you have selected the "worldspawn" entity. Enter a new Key called: "ambient", and give it the value of how much light the map should have. Then Enter a new key, and name it "_color", 
enter a value for it "&lt;R&gt; &lt;G&gt; &lt;B&gt;" Where &lt;R&gt;=Red, &lt;G&gt;=Green and &lt;B&gt;=Blue.</p> 
<p>This is the value of what color the light should have. You should add a value between 0 and 1. To get a white color, simply enter "1 1 1".</p>
<p>That's about it! Hope you get your new space-maps working as you want it!</p></ul><h1 id="546" name="546" class="book-h3">Falling leaves!</h1><ul><!-- by Jon Eriksson -->
<h3>Falling Leaves<br><span class="tinytext">by Jon Eriksson</span></h3>
<p>This is a nice effect that Quake 3 Arena allows you to have, Falling leaves.<p> 
<hr>
<p>First, you need a texture that looks something like this:<p> 
<center><img src="content/quake3/tutorials/shadertut4/picture1.jpg"></center>
<p>Now select the "leaves", and save it. I saved mine as mytextures/le.tga. Now, over to the Scripting part.</p>
<p>Open notepad and type this:</p>
<pre>textures/mytextres/leav
{
    qer_editorimage textures/mytextures/le.tga
    surfaceparm nonsolid
    surfaceparm trans
    cull none
    deformVertexes wave 30 sin 0 10 0 .2
    nopicmip
    {
        map textures/mytextures/le.tga
        tcMod scale 2 2
        blendFunc GL_ONE GL_ZERO
        alphaFunc GE128
        depthWrite
        rgbGen identity
        tcmod scroll 0 .25
    }
    {
        map $lightmap
        rgbGen identity
        blendFunc GL_DST_COLOR GL_ZERO
        depthFunc equal
    }
}</pre>
<p>Now save it under your baseq3/scripts directory. I saved mine as "my.shader", remember to call it *.shader. Load up Qeradiant, and apply the texture "mytextures/leav" to an object, and compile.</p></ul><h1 id="905" name="905" class="book-h1">Quake Toolkit</h1><ul><h3>Quake Toolkit</h3>
<p class="q3bg1b"><b>Author</b>: Eraser, r3tina &amp; Sithlord</p>
<p class="q3bg1b"><a href="http://www.fileplanet.com/dl.aspx?/planetquake/eoc/qtoolkit_157.exe">Download V1.57</a><br><a href="http://planetquake3.net/download.php?op=viewdownloaddetails&lid=1949">Download V1.56</a><br><a href="http://www.planetquake.com/eoc/qtoolkit">Official Site</a><br><br>
The Quake ToolKit utility is a simple, but very effective and multifunctional utility designed to give Q3A players, mappers and server administrators easy access to very useful tools. The ToolKit is basically a collection of small tools.<br><br>
Features:<br><br>
Tool for easy .arena file creating<br>
Shell for Q3Map and Q3Map2. Allows you to configure the compiler and compile maps through a graphical interface.<br>
Easy to use tool to create new bots<br>
Random Team Generator. Randomly Generates two teams from a list of players<br>
Wizard for easy compiling of RoQ video files<br>
Server Configuration. Basic server setup utility. Great for setting up lan games.<br>
Quake 3 player profile manager.<br>
Customizable Skins<br>
Easy access to all tools and Q3Radiant through taskbar trayicon<br>
Now with support for RTCW</p></ul><h1 id="900" name="900" class="book-h1">Quark - Level Editor</h1><ul><h3>Quark - Quake Army Knife</h3>
<p class="q3bg1b"><b>Author</b>: Armin Rigo</p>
<p class="q3bg1b"><a href="http://dynamic.gamespy.com/~quark/download.php3">Downloads Page</a><br><a href="http://www.planetquake.com/quark/infobase">Quark Information Base</a><br><a href="http://dynamic.gamespy.com/~quark">Official Site</a><br><br>
Quake Army Knife (QuArK) is a multi-purpose tool for the games using engines similar to or based on the Quake engine by id software. QuArK has the ability to directly edit maps, and to a limited extent, models, and can import, export and convert sounds, textures and various other game assets. It is also able to modify .pak and .pk3 files, as well as importing compiled BSP's in order to study the entities as well as add/change/delete entities from these files. No other game editing tool available has the ability to do all of these things. QuArK is completely different from the desktop publishing program Quark.</p>
<!--break-->
<p class="q3bg1b">One difference between QuArK and many other editors is a consistent emphasis on an easy-to-use and intuitive interface, with extensive flyover hints and other forms of in-program documentation. No need to remember 50 combinations of hot keys to produce a map. Initial configuration is simply a matter of filling in fields indicating where the games you're editing and their compiling tools are located, and when you start the map editor for the first time, you're presented with a basic map than you can run by hitting the 'GO'  button.<br><br>There has also been extensive development of tools such as 'duplicators' and 'shape builders' to help in creating complex patterns such as stairs, arches and other sophisticated architecture. If you know you need a row of pillars but can't make up your mind about what texture to use on them, you can use a duplicator, and changing the texture on the original will automatically update the copies.<br><br>A final difference is that QuArK is as far as we know the only GPL (Gnu Public License) game editor that is being actively developed, and is easy to extend to accomodate a wide range of different games. The GPL means, among other things, that the QuArK developers can't impose any restrictions at all on what you do with it, unlike editors supported by games companies, which can't be used for games produced by other companies. So if you are an aspiring game-developer you can adapt QuArK for your own project, without having to reveal editor source until you release the editing tools for your game (actually you don't even have to do that, though we would certainly hope that you would).</p></ul><h1 id="901" name="901" class="book-h1">Quest - Level Editor</h1><ul><h3>Quest - a 3d map editor </h3>
<p class="q3bg1b"><b>Author</b>: Alexander Malmberg</p>
<p class="q3bg1b"><a href="http://quest-ed.sourceforge.net/dl/index.html">Downloads Page</a><br><a href="http://quest-ed.sourceforge.net/doc/index.html">Quest Documentation</a><br><a href="http://quest-ed.sourceforge.net">Official Site</a><br><br>
Quest is an editor for the games Quake and Quake 2, by id software. It also supports other games using their engines, like Hexen 2. Quest was originally written by Chris Carollo and Trey Harrison back in '96, and after they stopped working on it, I (Alexander Malmberg) continued working on it. </p>
<!-- break --></ul><h1 id="892" name="892" class="book-h1">SC3K Map Editor (Terrain)</h1><ul><h3>SC3K Map Editor</h3>
<p class="q3bg1b"><b>Author</b>: Tenermerx Software and Terence Martin</p>
<p class="q3bg1b"><a href="http://www.tenermerx.com/sc3maped/download.html">New Version 1.2 Release</a><br><a href="http://www.tenermerx.com/sc3maped/fractal.zip">Fractal Plug-In for 1.0 or 1.1 only</a><br><a href="http://www.tenermerx.com/sc3maped">Official Site</a><br><br>
SC3K Map Editor is the fastest and most accurate terrain editor currently available for SimCity 3000. It gives you the finest possible control over modifications to your terrain.<!-- break -->
<br><br>
<b>With SC3K Map Editor you can: </b><br>
Edit in 3D - Use an interface very similar to that given by SimCity 3000 so that you can see exactly what your terrain will look like as you create it. <br><br>
Rearrange, resize and remove the editing windows - Make your layout suit your purposes and techniques. <br><br>
<b>SC3K Map Editor offers a wide range of tools for editing your personal terrain:</b><br>
The magic wand will select all contiguous points of the same height, so that it is easy to select flat plains. <br><br>
A gradient tool allows unlimited possibilities for mountains and valleys. <br><br>
A highlight tool to mark out patterns on the terrain before you make them. </p>
</ul><h1 id="917" name="917" class="book-h1">ScapeMaker Landscape Generator Viewer</h1><ul><h3>ScapeMaker</h3>
<p class="q3bg1b"><b>Authors</b>: Dirk Plate & Matthias Buchetics</p>
<p class="q3bg1b"><a href="http://www.heikoplate.de/dP-Software/zips/ScapeMakerSetup_1_3.exe">New Version 1.3 Release</a><br>
<p class="q3bg1b"><a href="http://www.heikoplate.de/dP-Software/zips/ScapeMakerSetup_1_2.exe">Version 1.2 Release</a><br>
<a href="http://stud4.tuwien.ac.at/~e0225149/ScapeMakerSetup_1_1.exe">Version 1.1 Release</a><br>
<a href="http://www.dplate.de/scapemaker">Official Site</a><br><br>
<b>ScapeMaker is a landscape-generation-tool</b> for Windows. Adjusting simple parameters, you define how your landscape looks and ScapeMaker creates a appropriate height-profile, surfacetextures etc. for you. Then you may freely move throughout your 3d-landscape and take screenshots.<br><br> <!-- break -->
<b>ScapeMaker consists of</b> an extensive Topology-Generator which generates heightmaps which can be used in other apps such as Quake III Arena via GTKRadiant. The Topology-Generator simulates different types of ground and erosion caused by water. By specifically adjusting the simulation parameters all kinds of landscapes can be generated.<br><br>
The <b>Texture-Generator</b> creates surface-maps that match the topology to simulate e.g. grass, rock or snow. The surface-texture is generated from free choose-able presets.<br><br>
To give more varied form to landscapes, it's </b>possible to place 3d-objects</b> (eg. trees) around <b>with the Object-Generator</b>. This functions according to the Topology-settings (gradient and height) and the chosen density, or manually.<br><br>
The <b>clouds-generator</b> creates random cumulus and cirrus clouds whose appearance can be defined with many settings. For a realistic movement of the clouds, they don't move statically over the sky but change their shapes constantly.<br><br>The <b>3D-mode</b> is the highlight of ScapeMaker. With a powerful 3D-Engine, the own landscape is presented. In the sea, the sky is reflected and clouds pass realistically over the landscape & you can roam through your world and take screenshots from any angle. Some special effects uses newer technologies (Vertex- and Pixelshader), check requirements, visit the <a href="http://www.matthias-buchetics.com/cgi-bin/ikonboard/ikonboard.cgi">forum</a>.</p>
</ul><h1 id="895" name="895" class="book-h1">Terragen</h1><ul><h3>Terragen</h3>
<p class="q3bg1b"><b>Author</b>: Planetside Software</p>
<p class="q3bg1b"><a href="http://www.planetside.co.uk/terragen/download.shtml">Download Page</a><br><a href="http://www.planetside.co.uk/terragen/guide/">Manual</a><br><a href="http://www.planetside.co.uk/terragen">Official Site</a><br><br>
Terragen is a scenery generator, created with the goal of generating photorealistic landscape images and animations. It is available for Windows and the Mac OS. At this stage in its development, Terragen is free for personal, noncommercial use.<br><br>Although Terragen is a continually evolving work-in-progress, it is already capable of near-photorealistic results for professional landscape visualisation, special effects, art and recreation. Terragen has been used in a variety of commercial applications including film, television and music videos, games and multimedia, books, magazines and print advertisements. For just a small selection of projects Terragen has been used in, please visit the commercial use page.<br><br>Despite the fact that Terragen can be used for professional landscape visualisation projects, it is accessible and easy to get started with. You could be rendering your first landscape image in as little as 15 minutes after installation.<br><br>You can view a gallery of images created by Terragen users here.<br><br>Terragen has a native user interface, using facilities provided by the operating system of the respective platform, as opposed to the custom user interfaces used by many similar applications. This means Terragen can follow the usage conventions of each platform as closely as possible, which ensures that it looks and feels just like the other applications you use and means there is no learning curve with respect to the basic operation of Terragen. Here are some screenshots of Terragen on different platforms. Click to see larger images in a new window.</p></ul><h1 id="902" name="902" class="book-h1">Tread - Level Editor</h1><ul><h3>Tread 3D </h3>
<p class="q3bg1b"><b>Author</b>: Alexander Malmberg &amp;  Joe Riedel + Nicholas Randal</p>
<p class="q3bg1b"><a href="http://www.planetquake.com/tread">Downloads Page</a><br><a href="http://www.planetquake.com/tread">Tread Documentation</a><br><a href="http://www.planetquake.com/tread">Official Site</a><br><br>
 to focus on the major lackings of our last version, and fix all the problems. Tread3D2 has been rewritten from scratch. Not a single line of 1.12 lives on in this version.<br><br>Speed A lot of hindrance came from 1.12's inherent lack of support for hardware acceleration. Part of this was remedied by visgroups, however, this often proved to be inadequate. Tread3D2's rendering engine has been completely reengineered to be more flexible, and way faster. On an AMD K6/2 450 with a diamond Viper V770 (or 550) Tread3D2 is wicked fast. You can pan a thousand brushes in the 3D view without a hiccup. An entire Quake2 level will move in real-time at about 2-5 f.p.s. That may not sounds impressive, but trust me, it is. Often a designer works with much smaller subsets of a level, but sometimes you need to see the whole thing, and Tread3D2 makes it possible. As far as the flat views go, don't even try to slow those suckers down, you just ain't gonna do it<br><br><!-- break -->Ease of Use with Power for the Pros Nick Randal's partnership in Tread3D2 has taken editing to the next level with user interface. If only he'd been able to work on 1.12 when it was still in its infancy. Nick's thrown new controls and functionality into the interface this time around. You'll sit back and say: "This is how it should have been the first time." All colors can be customized to your liking. If you hate the way a hot spot looks, then change it. Fully bindable action and mode keys are still here. A debug window sports the ability to show what's going on inside Tread3D2. This will be useful for plugin designers. Nick has also come up with a new editing paradigm: anchors. Points in your map that can be centered on by a simple click of the mouse. You can also expand and collapse views with the press of a key.<br><br>Eye Candy One of the biggest new eye candy features of Tread3D2 is a ZombieLight Plugin. Tread3D2 will precompute the lighting in your level in literally seconds and show you what it will look like in the game. Currently this supports has only been tested with Quake2 and HalfLife. It's fast! Tread3D2 can compile the lighting for base1 of Quake2 in under 20 seconds on an AMD K/6 450 machine. With this feature the full source code is also included. That conveniently leads me to the next topic.<br><br>Fully Extendable with Plugins Tread3D2 can be extended to do anything an end user wishes it to with a fully integrated plugin system. Users can code new texture loading, model importing features, just about anything their hearts desire. Full source code to five plugins is included to get you off on the right foot. Two of them are used in Tread3D2 as major features: the leaktrace and ZombieLight ( Lighting preview).<br><br>Currently Tread3D2 provides the following plugins source code:<br><br>
Leaktrace<br>
ZombieLight (Lighting preview)<br>
Quake2 Pak Reader (Reads the Quake2(tm) pak file format)<br>
Quake Map (Read and write maps of Quake type)<br>
Shapes Plugin for Arches, Cones and Cylinders</p>
</ul></body></html>