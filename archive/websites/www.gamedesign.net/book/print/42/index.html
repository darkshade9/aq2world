<html><head><title>Tutorials</title><base href="http://www.gamedesign.net/" /><style type="text/css">
@import url(misc/print.css);
</style></head><body><h1 id="42" name="42" class="book-h1">Tutorials</h1><h2>RUST's Quake II Tutorials</h2><h1 id="43" name="43" class="book-h1">Advanced Brushes</h1><ul><h3>Quake 2</h3>
	<blockquote>
		Advanced Brushes - Herbert "BONEWOLF" Flower
	</blockquote>

<br><br>

<p>I started studying the subject of Quake brushes when I was first starting my TC (<a href="http://www.planetquake.com/gunman/">http://www.planetquake.com/gunman/</a>). My aim has always been to push the Quake engine to its fullest potential. I read a quick little description of how the brushes work, and wrote a few programs to allow me to make brushes with my 3D program and convert them to .map format. I spent several weeks discovering, by trial and error, the techniques needed to make practically anything out of brushes. What I know is just the result of alot of hard thinking, and staring at a computer screen. I havent talked to Carmack or anyone that is really educated on the subject of 3d engines, and I'm sure that if I did, I'd have more to say on this subject.

<br><br><b>BRUSH DESCRIPTION</b>

<p>Brushes are of course the building blocks that the level is made from. They are always convex because of the way they are created. Imagine a world made of styro-foam that goes forever in all directions. To make a brush, you make infinitely large slices in the foam, and what is left over from that whole universe of styro-foam is your brush. You can imagine how easy it would be to forget a slice or two and end up with a brush that goes off into infinity. Its also obvious that you cant create a single brush that has a dent or "concave" surface on it, because each slice you make goes forever... you'd always chop-off parts of the brush that would have caused it to have the concave shape in the first place. In the old days of Quake1, brushes had to have 16 or less "slices" to compile, but now you can find QBSPs that have the ability to create brushes with 256 slices, and QBSP3 seems to allow alot of slices too.

<p><div align="center"><img border="0" width="450"  src="/content/quake2/tutorials/abrush/abrush_img1.gif"></div>

<br><br><b>THE "KNIFE"</b>

<p>How do you make the slices? Its easy. You define the slicing plane with three points... essentially a triangle. Each point's coordinates are whole numbers with no decimals (this is due to the .map format). In the world of 3D graphics, each triangle that makes up an object either faces IN or OUT depending on whether the triangle was made clockwise or counterclockwise. That "direction" is called the "normal" and it's used to tell which side of the plane to discard. You want your normals to face INWARD, or you will chop-off the interior of the brush, rather than the stuff on the outside. But now it gets complicated. Think of a cube. It would in fact be made up of 6 triangles, rather than 6 squares. To add to the confusion, you could have the points that define each plane appear anywhere on that plane... so-long as the "normal" still points inward. There are a zillion possible ways to make a cube then, but in some respects, each way will result in a cube that will behave differently when you manipulate it (shearing, rotation etc.)

<p><div align="center"><img src="/content/quake2/tutorials/abrush/abrush_img2.gif"></div>

<br><br><b>THE .MAP FORMAT</b>

<p>Here is an example of a cutting plane in the .map format:

<blockquote>
1.000000 ( -225 -265 -145 ) ( -175 -235 -170 ) ( -225 -215 -170 ) CAVE_3 0 0 0 1.000000
</blockquote>

<p>The numbers within the parentheses are the X-Y-Z coordinates for the three points of a cutting plane. Notice that all vertices (points that define each "slice" or "plane") end up being integers (no decimals) in the .map format. This is what causes alot of the errors and gaps and mis-alignments in your Quake maps. The problem is that when you rotate a brush to anything but 90 degree angles, it is almost guaranteed that most or all of your cutting planes will contain decimal values, which will be truncated when you save as .map to compile. This causes shapes to change slightly... For example... imagine a small cube that is rotated only a few degrees. You never know how the vertices will be rounded off--some may move, some may round back to where they started. So you could end up with something that was no-longer even a true cube. Now imagine a cube that has its plane-vertices spread far apart... beyond the visible corners of the cube-brush. You could rotate this cube with a greater degree of accuracy. "Big deal!" you say. But it IS a big deal when it comes to brushes that must match up to other brushes perfectly. For instance, a rectangle and a square may match up perfectly until you rotate them as a group. If the rotation is some oddball angle, like 21 degrees, you may end up with the brushes overlapping, or you may have a VERY THIN gap between them. That is BAD. If the overlap is very small, you will get some sort of funny error, and Qbsp will choke on it. If there is a gap, you end up with extra faces to draw, and I'm sure plenty of extra crap for vis to deal with too. You can also get those annoying black spots and shading errors. Of course, the solution to this would be for the smaller cube-shaped brush to have the vertices on the side that meets up with the rectangle be in the same exact place as the rectangle's vertices. This will allow the square brush to fit perfectly against the rectangular brush no matter how you rotated it. Another thing that causes errors would be "duplicate planes". If you have two triangles that define the same plane, you either get a simple warning, or Qbsp will choke. Sometimes if you shrink a brush that has two planes that are very nearly at the same angle, the truncating effect of the .map format will cause them to actually BECOME identical. So small size can cause trouble for fancy brushwork... unless the points that define the planes are placed beyond the edges of the actual brush, resulting in greater accuracy. The same kind of errors can show up when you start "shearing" or otherwise fiddling with a brush in programs like WorldCraft etc. So I guess the moral to the story is this: you have alot more control of brushes than you might imagine. You just have to be able to build them at the most basic level.

<p><div align="center"><img src="/content/quake2/tutorials/abrush/abrush_img3.gif"></div>

<br><br><b>BRUSH SCULPTING</b>

<p>As far as I know, there is no Quake-specific program out there that lets you really get to the guts of a brush. Clipping tools and vertex editing help, but are rather clumsy for any real precision work. I prefer using a 3D modeling program to make special-purpose brush prefabs. You will need a program that allows you to create 3D objects with the ability to manually add and delete faces, and change the normals on the faces individually. It's a simple job to convert .raw or .txt saved files to the .map format so that you can include it into the normal map editors like WorldCraft etc. There is a program that supposedly converts .3ds to .map out there. I have tried it, and it doesnt work well at all on any but the simplest of shapes. 

<br><br><b>SHAPES TO AVOID</b>

<p>Its not so much the shape of a brush you should avoid, but rather the shape of certain FACES on brushes that match-up to other brushes that you should beware of. A sure-fire way to get those nasty little gaps and overlaps is to try to match-up faces that have more than 3 corners AND are not square AND are rotated on more than one axis. This is just the type of thing that causes those strange qbsp compiling problems when you try to use "Subtraction" features in the level-editing programs. You end up with corners on your brush that are not on any of the vertices that form the cutting planes, and these corners very rarely are going to end up with X-Y-Z on even numbers. When I create prefabs of smooth, biological structures, I always try to avoid faces that have more than 3 corners, unless the plane is on a 90 degree angle. This ensures that all the corners of the brushes will match-up flawlessly. However, it can really cause qbsp to chop-up the level. Especially when you use a bunch of these triangular-based brushes to create a concave surface.

<p><div align="center"><a href="/content/quake2/tutorials/abrush/abrush_img4.gif"><img border="0" src="/content/quake2/tutorials/abrush/abrush_img4_s.gif"></a></div>

<br><br><b>SOLUTIONS TO PROBLEMS</b>

<p>If you load a brush that you created into WorldCraft, and it complains "1 brushes were not loaded, due to errors" it probably means you ended up with a duplicate plane. There are a few ways to deal with that. Go into you modeling program and look for 2 very similar planes. Together, they make a square. Delete the two triangles that make-up that square, and replace them with triangles crossing the square in the opposite direction. Sometimes this is all it takes. If that fails, you can try slightly adjusting the size of the whole prefab. This will cause the vertices to be truncated differently for the .map format. Sometimes a slight rescaling makes all the difference and gets rid of your duplicate planes for you. Remember, larger brushes=more accuracy for the cutting planes. The last solution is to find the trouble-making plane, and extend the vertices defining that plane out to a distance where they can gain more accuracy. This is actually pretty difficult for some angles, so I avoid getting in to this situation whenever possible! One thing that I notice is that Worldcraft seems to load brushes and convert them to something that REPRESENTS the brush, but doesnt actually function like a brush. When you have corners on a brush that are the result of the cutting planes and dont actually have any vertices on them, it is legal for them to be on coordinates that have decimal places (figure A). The later versions of WC try to snap vertices to the nearest integer when you rotate or otherwise manipulate a brush... which is fine for most brushes, but will not accurately represent the final product. I find that it works best if you rotate complex brush sculptures in the 3D editing program and export them to WC 

<p><div align="center"><img src="/content/quake2/tutorials/abrush/abrush_img5.gif"></div>

<p><div align="center"><a href="/content/quake2/tutorials/abrush/abrush_img12.jpg"><img border=0 src="/content/quake2/tutorials/abrush/abrush_img6.gif"></a></div>

<br><br><b>R_SPEEDS</b>

<p>I'm sure you're thinking, "Well, I'm sure you can create some really cool things with brushes, but I bet it slows the game WAY down!". Sure, that can happen. But if you use fancy brushwork in combination with more simple forms, your r_speeds will be just fine. Think about it... a few staircases can give you hundreds of triangles for Quake to draw. Stairs have ALOT of different planes, and they cut up the walls next to them. Now, would you rather have an awesome brush model in the room and a simple ramp, or nothing cool in the room and yet-another staircase? 

<br><br><div align="center"><b>EXAMPLES OF WHAT YOU CAN DO IN QUAKE</b></div><br><br>

<table align="center" width="400" cellspacing="0" cellpadding="0" border="0">
<tr><td>
	<a href="/content/quake2/tutorials/abrush/abrush_img7.jpg"><img border="0" src="/content/quake2/tutorials/abrush/abrush_img7_s.jpg"></a>
</td><td width="300">
	This took about 1 1/2 days to create. Half the work went into bug-fixing. I used about every trick in the book on this one.
</td></tr>
<tr><td>
	<a href="/content/quake2/tutorials/abrush/abrush_img8.jpg"><img border="0" src="/content/quake2/tutorials/abrush/abrush_img8_s.jpg"></a>
</td><td width="300">
	This is a stone hand. You can walk around on the palm and shoot out between the fingers. Really a fun item.
</td></tr>
<tr><td>
	<a href="/content/quake2/tutorials/abrush/abrush_img9.jpg"><img border="0" src="/content/quake2/tutorials/abrush/abrush_img9_s.jpg"></a>
</td><td width="300">
	It *IS* possible to make smooth looking rolling hills in the Quake engine.
</td></tr>
<tr><td>
	<a href="/content/quake2/tutorials/abrush/abrush_img10.jpg"><img border="0" src="/content/quake2/tutorials/abrush/abrush_img10_s.jpg"></a>
</td><td width="300">
	Its difficult to get the sloped disk shape of a flying saucer without cracks and still have empty space inside like this one has.
</td></tr>
<tr><td>
	<a href="/content/quake2/tutorials/abrush/abrush_img11.jpg"><img border="0" src="/content/quake2/tutorials/abrush/abrush_img11_s.jpg"></a>
</td><td width="300">
	This is a rather simple sculpture that has a dramatic effect.
</td></tr>
</table>

<p>
</ul><h1 id="45" name="45" class="book-h1">Area Light</h1><ul><h3>Quake 2</h3>
	<blockquote>
		Area Light - <a href="mailto:granny@gamedesign.net">GrrandMaMa</a>
	</blockquote>
<br><br>

<p>One of the things I've always dreaded doing when building is area lighting. I can have all of my sourced lighting up and going, all my spot lighting and texture lighting set and done, but there are always dark spots (usually in the center of a fairly large room with a high ceiling.) So, the next step (for me) was to put a whole bunch of low-brightness lights close to the floor (usually 150 brighness, about 64 units off the floor) and space them out to put a dim cover. Just enough to put light where I need it, but not enough to overpower the sourced lights. And then there is the matter of coloring them. 

<p>All in all, it works well, but it takes a long time to get it just right, and it's just a general pain in the ass. There is however, another way that gives nearly perfect coverage, and is (most importantly) fast and easy to adjust to get it looking just right.

<p>Let's look at a particular area.

<p><div align="center"><img border="0" width="450"  src="/content/quake2/tutorials/alight/alight_img1.jpg"></div>

<p>Notice how the center of the room is dark. Now, if we were to put a light, bright enough to cover the dark area, in the center of the dark spot, it would flood out the sourced lighting from the lights in the wals near the floor. So, now we have a problem just like the one I described above, but instead of using cover lighting using point lighting like I described above, we'll do something different -- texture lighting. I know, that would look pretty bad to light up the floor. Don't worry, we're not going to use the floor. 

<p><b>First thing we need to do</b> is find a texture that will give us the color we need when we light it. In this case, we'll use the texture for the wall-mounted lights.

<p><b>Next, create a brush </b>that covers the general area, a bit off the floor (no, I'm not going to tell you exactly how far, because it's something you have to play with.) 

<p>You should have something like this:

<p><div align="center"><img src="/content/quake2/tutorials/alight/alight_img2.jpg"></div>

<p>Now we set the properties for the brush. Set the following flags <b>on all faces</b> of the brush:

<br><br>

<blockquote>
	<li><b>light:</b> Well, why else would we be doing this?<br>
    <li><b>sky:</b> This way it will still emit light, even though it won't be drawn<br>
	<li><b>nodraw:</b> A big light brush probably wouldn't look too good in the middle of a room<br>
	<li><b>detail:</b> Since it is a sky brush, it will be a     factor in your PVS unless this is checked, which means you'll be having sky pop up in all kinds of wierd places. Trust me... check this<br>
	<li><b>mist:</b> If you don't check mist, people will be wondering who stuck a big clip brush in the middle of the room<br>
</blockquote>

<p>Keep the light value <b>very</b> low.

<p><b>NOTE</b>: This will <b>dramatically</b> increase your QRAD3 times. Just thought I'd let you know.

<p>Now compile it, and you should come up with something like this:

<p><div align="center"><img border="0" width="450"  src="/content/quake2/tutorials/alight/alight_img3.jpg"></div>

<p>It's a subtle difference, but every little bit counts (and it looks pretty good too)

<p><hr width=75% color=black noshade><p>

<p> You can download the example <a href="/content/quake2/tutorials/alight/alight_ex.zip">here</a>.

<p>
</ul><h1 id="50" name="50" class="book-h1">Clip Brush Q&A</h1><ul><h3>Quake 2</h3>
	<blockquote>
		Clip Brush Q&A - Various
	</blockquote> 
	
<br><br><b>Do I REALLY need to use Clip brushes?  It seems like a lot of tedious work!</b>

<p>The harsh reality is that creating Clip brushes in levels, especially large ones, is a pretty tedious job.  Especially since you'll typically want to add them after doing all of the structural and texture work of your level.  So, it's one thing that is often overlooked by most mappers.

<p>However, if you want your map to be played, or at the very least be enjoyed by many people (which is the reason most people publish maps), then you really should spend the time creating Clip brushes.  Nothing is more frustrating in a deathmatch game than to be running backwards while firing, only to be stuck by a small light fixture!

<br><br><b>Is preventing the player from getting stuck the only practical use for Clip brushes?</b>

<p>No. Clip brushes can be used in a variety of situations.  For example, let's say you created a hole in a wall from an explosion.   In this hole, you had the quad damage.  While everything might be setup by brushes for the player to crawl into that gap, the player might not be able to get out.   In this case, you could create a ramp with the clip brush to make it easier for the player to get back out.

<br><br><b>Can I use Clip brushes TOO much?</b>

<p>Like any tool or technique in Quake 2 editing, it's sometimes easy to go overboard.  Keep in mind you can't ever completely prevent the player from getting stuck.  Likewise, it's also very easy to abuse Clip brushes by putting them in a place where they block the player's movement with no indication as to why.  While this may be a interesting effect for a while, it very quickly becomes frustrating.

<p>As with everything else in Quake 2, be sure to test your level after adding Clip brushes - it's very easy to forget you're working in a 3D world - and that Clip brush which keeps the player from getting snagged on the first floor may end up accidentally blocking a doorway on the second floor!

<br><br><b>I just have some small light fixtures along my wall and using Clip brushes seems a bit too tedious.   Is there another way to handle this?</b>

<p>If you've got a lot of small items sticking out of a wall, you can change their content property to Mist (or AUX) which allows the player to pass through them without the need for Clip brushes.  However, this is really only useful for small items since the player passes completely through the object.  So, if you had some big columns, this technique probably wouldn't be practical.  But, for small light fixtures, this is sometimes quicker and easier than using Clip brushes!

<p></ul><h1 id="48" name="48" class="book-h1">Colored Light</h1><ul><h3>Quake 2</h3>
	<blockquote>
		Colored Light - <a href="mailto:fishman@gamedesign.net">Shane 'Fishman' Sherman</a>
	</blockquote>

<p>The one thing that I think makes quake2 one of the best looking games ever is colored lighting. The difference in visual quality between the software version with no colored lights and the hardware version with colored light support is like night and day. It adds so much atmosphere to the game. id made it very easy to use colored lighting when level designing and hopefully I can give some tips on the best ways to use them to their full potential. If you know all about colored lights and using them then you might want to skip to the bottom and check out my tips. Some of them can be very useful. 
	
<br><br><b>How do I use colored light?</b> 

<p>There are 2 ways you can produce colored lights:

<p>First way is the typical light entity with the key value pair <b>_color</b> and a value of the RGB code of the color you want.

<p>The second way is to have a texture radiate light. What's cool about this is whatever color the texture is that is the color the light will be. This is my preferred choice with using colored lights. Why? It gives off a much more realistic color of light. <em>It's much easier to let the light texture radiate the color then trying to match that color with a light entity</em>. 

<br><br><b>Why do some user made levels look like shit?</b> 

<p>It is very easy to overuse colored light. A lot of the first user made levels I have seen have severely overused colored light. Here are a few examples of overused colored lights:

<p><div align="center"><img src="/content/quake2/tutorials/clight/clight_img1.jpg">

<p>Blue and Red? Very unnatural light.

</div>

<p><div align="center"><img src="/content/quake2/tutorials/clight/clight_img2.jpg">

<p>Lime green...yuck.

</div>

<p><div align="center"><img src="/content/quake2/tutorials/clight/clight_img3.jpg">

<p>Not bad but still too much -- 5 different colors in one shot.

</div>

<p>Now if these people just let the surfaces radiate most of the light for them then they would get a much more natural look and feel. I'm not saying never use light entities i'm just saying to let the surfaces do some of the work for you.

<br><br><b>How do I made a surface emit light?</b> 

<p>To make a surface emit light, you must you the edit the surface properties of that brush or surface. There is a surface Property flag called light. For a better explanation on how to edit the surface properties and the light property I suggest you read my surface/content properties tutorial. It will explain everything you need to know on how to edit the surface properties. 

<br><p><b>Hints and Tips</b><br><br>


<p>Here are a couple of tricks I have figured out about colored light that might be able to help you:

<ul>
   <li>Values don't have to be between 0 and 1. The can be between 0 and 255 like normal RGB colors.<br><br>
        
   <li>Try using your favorite paint program and pick the color you want and write down the RGB code.<br><br>
        
   <li>Most editors have a color button that allows you to select the color from a pallete. Very handy!<br><br>
        
   <li>Sometimes when having a surface emit light, you will have to set the value EXTREMELY high depending on the size of the face or brush. Light values as high as 10000 are not uncommon. This is only with surface emitting light though.<br><br>

</ul>

<p>
</ul><h1 id="595" name="595" class="book-h1">Creating an outdoor area using Gensurf</h1><ul><h1 align="left"><u>Creating an outdoor area with Gensurf</u></h1>

<p><i>Original tutorial provided by Ricebug, written with QERadiant in mind.</i>

<p><font face="Arial">This tutorial will involve making an outside area and sky box. For making
realistic-looking landscape, we will also be using the stand-alone version of
David Hyde’s fantastic terrain generator program, <i><b><a href="http://www.planetquake.com/gensurf/">GenSurf</a></b></i>.
A plugin version is available for QERadiant also.</font></p>
<hr width=80% align="center">
<h3><u>Making
the Ground with <i>GenSurf</i></u></h3>
<p><font face="Arial">Since David Hyde keeps improving <i>GenSurf</i>, the instructions below may
not follow the current update.</font></p>

<font face="Arial">
1. For learning purposes, our outdoor area is going to be a small
&quot;backyard.&quot; Once you have <i>GenSurf</i> up and running, click on the General
tab. Under Set Waveform, select From
Bitmap. Also, uncheck Add Skybox<i>.</i>
The <i>skybox</i> option tells <i>GenSurf</i> to create a playable map with
ground, sky and player entity. We won’t need these for our purpose.</font>

<p align="center"><a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/content/quake2/tutorials/gensurf_outside/outs_01.gif"><img border="0" src="content/quake2/tutorials/gensurf_outside/outs_01.gif" width="450"></a></p>
<p align="center"><font color="#aa0000" size="2" face="Arial"><b>Figure 1: <i>GenSurf</i>'s
interface (click for larger image)</b></font></p>
<p><font face="Arial">3. We’re going to use a grayscale bitmap to form our ground elevations. If
you want, you can left-click on the one in Figure 2 and save it as a .BMP to a
directory of your choosing. Click on <i>GenSurf’s </i>Bitmap
tab and browse to this location.</font></p>
<p><font face="Arial">4. Compare the bitmap below with the wireframe preview in Figure 1 above. The
black areas dictate the lower elevation, while the whiter areas cause the ground
to swell upward. Lightwave and 3DSMax users know this as &quot;displacement
mapping.&quot; For example, by drawing thick, black lines on a white background,
you can easily define drainage ditches or culverts. In reverse, drawing thick,
white lines on a black background will give you walls. Shades of gray in between
black &amp; white will cause variations in the height of your walls. Some
interesting landscapes can be created with a little imagination.</font></p>
<p align="center"><img border="0" src="content/quake2/tutorials/gensurf_outside/outs_02.gif"></font></p>

<div align="center">
  <center>
  <table border="0" width="50%">
    <tr>
      <td>
        <p align="center"><font face="Arial"><b><font color="#aa0000" size="2">Figure 2: Grayscale
        image used to define elevation of terrain in <i>GenSurf.</i></font></b> <font color="#aa0000" size="2"><b><i>Image
        scaled to half original size for tutorial purposes.</i></b></font></font></p>
      </td>

    </tr>
  </table>
  </center>
</div>
<p><font face="Arial">5. Now click on the Extents tab. Under Lower-Left
Corner<i>,</i> type </font> <font color="#000000" face="Arial Black">–128</font>
<font face="Arial">
in both boxes. Under Upper-Right Corner<i>,</i>

type <font color="#000000" face="Arial Black">128</font> in both boxes. This
will give an area size of 512 pixels, the exact dimensions of our bitmap. Also
set Number of Divisions to 16
in both boxes. This will make for a smooth ground.</font></p>
<div align="center">
  <center>
  <table border="0">
    <tbody>
      <tr>
        <td>
          <p><font color="#aa0000" face="Arial"><b>WARNING</b></font></p>

        </td>
      </tr>
    </tbody>
  </table>
  </center>
</div>
<div align="justify">
<table border="0">
  <tbody>
    <tr>

      <td>
        <p><b><small><font face="Arial"><font color="#aa0000">Depending on the size of your map and
        hardware limitations, <i>GenSurf</i>-created walls, ceiling and floors
        can very quickly bog down the editor and dramatically increase compile
        times if you set the </font><font color="#000000">Number of Divisions</font><font color="#aa0000">
        to a number less than 64. Start with larger numbers and work your way
        down. As a rule, I complete my maps first and add the terrain when I'm
        done.&nbsp;</font></font></small></b></p>
      </td>
    </tr>
  </tbody>

</table>
</div>
<p><font face="Arial">6. Notice that your map preview shows a steep terrain. We want our ground to
flow downward in a smooth angle. To achieve this, change Map
color 0 to 50,
and <i>Map color 255</i>  to 100. Press <font color="#ffff00"><span style="BACKGROUND-COLOR: #000000">Tab</span></font>
on the keyboard and your map should smooth out.</font></p>
<p><font face="Arial">7. Click on the General tab and set Roughness
to <font color="#000000" face="Arial Black">0</font> and Random
Seed to <font color="#000000" face="Arial Black">1</font>.</font></p>

<font face="Arial">
8. Finally, under Output Map File<i>,</i> browse
to your <i>maps</i> folder and save the ground as <font color="#0000ff">outside.map</font>.</font>
<p>&nbsp;</p>
<hr width=80% align="center">
<h3><u>Adding
the Ground to the Map</u></h3>
<font face="Arial">1. Fire up Radiant and select FILE/NEW MAP.
I want you to clear anything out of the editing window to show you how to load
multiple maps into Radiant.</font>

<p><font face="Arial">2. With nothing in the editor, click on FILE and choose OPEN (Not LOAD).
Select the map of the rooms and hallway we’ve been working on. (Hopefully,
you’ve been saving things.)</font>
<p><font face="Arial">3. Now click on FILE. This time, choose LOAD and select the <i>GenSurf</i>
terrain you made. You should have both the terrain (in red) and the other map
file, as shown in the screen shot below. <u>Leave the terrain selected.</u>
</font>
<p><font face="Arial">4. With the terrain in red, click somewhere in its center and drag it towards
the bottom of your screen (you should be looking at the XY Top view). Drag it so
it rests on the outside wall of the square room as shown in Figure 3.</font></p>
<p align="center"><font face="Arial"><img border="0" src="content/quake2/tutorials/gensurf_outside/outs_03.gif"></font></p>
<p align="center"><font color="#aa0000" size="2" face="Arial"><b>Figure 3: Ground object in
place</b></font></p>
&nbsp;
<p><font face="Arial">5. Since I want the ground to slope down, away from the building, we’ll
need to rotate it.&nbsp; Look at the row of 6 buttons circled in yellow in Fig.
4<i>.</i> These show the different rotation commands for <b>X</b>, <b>Y</b>,

&amp; <b>Z</b>. With the ground still selected, you want to click on the last (<font color="#ffff00"><span style="BACKGROUND-COLOR: #000000">ZN</span></font>)
button TWICE, or you can click the <font color="#ffff00"><span style="BACKGROUND-COLOR: #000000">Y|Y</span></font>
button ONCE. The difference between these two buttons is that <font color="#ffff00"><span style="BACKGROUND-COLOR: #000000">ZN</span></font>
rotates a selection clockwise at 90-degree increments, while <font color="#ffff00"><span style="BACKGROUND-COLOR: #000000">YY</span></font>
vertically flips the selection. The end result is the same.</font></p>
<hr width=80% align="center">
<blockquote>

  <blockquote>
    <blockquote>
      <p align="center"><b><font face="Arial"><font color="#ffff00" size="3"><span style="BACKGROUND-COLOR: #000000">Y|Y</span></font><font color="#008080" size="3">
      </font><font color="#008000" size="3">flips brushes vertically on the
      screen;</font><font color="#008080" size="3"> </font><font color="#ffff00" size="3"><span style="BACKGROUND-COLOR: #000000">X|X</span></font><font color="#008080" size="3">
      </font><font color="#008000" size="3">flips them horizontally.</font></font></b>
    </blockquote>

  </blockquote>
</blockquote>
<hr width=80% align="center">
<font face="Arial">
6. The next thing to do is go to a side view of our <u>still-selected</u>
ground. CTRL-TAB until you get to the <font color="#0000ff" face="Arial Black"><b>YZ
Side</b></font> view. Click on the ground and drag it down until the high side
is even with the floor of the square room, as shown in the figure below.</font>
<p align="center"><font face="Arial"><img border="0" src="content/quake2/tutorials/gensurf_outside/outs_04.gif"></font></p>
<p align="center"><font color="#aa0000" size="2" face="Arial"><b>Figure 4: Ground lowered to
same elevation as floor</b></font></p>
<font face="Arial">

&nbsp;7. Once the slope is positioned where you want it, hit <font color="#ffff00"><span style="BACKGROUND-COLOR: #000000">ESC</span></font>ape
to deselect it. Save your work.</font>
<p><font face="Arial">8. The next thing we want to put in are some walls to enclose the ground. It
would look unrealistic to bring the sky texture down to the ground. I added a
&quot;stepped&quot; down stone fence along the sides.</font>
<p><font face="Arial">9. Next, select the sky texture and build a box to enclose the fence and
ground. The &quot;walls&quot; of the sky box should rest flush against the
outside of the fence. The &quot;ceiling&quot; of the sky should come just above
the &quot;roof&quot; of the exterior building. See figure 5.</font>

<p align="center"><a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/content/quake2/tutorials/gensurf_outside/outs_05.jpg"><img border="0" src="content/quake2/tutorials/gensurf_outside/outs_05.jpg" width="450"></a></p>
<p align="center"><font color="#aa0000" size="2" face="Arial"><b>Figure 5: Constructing the
Sky Box (click for larger image)</b></font></p>
<hr width=80% align="center">
<b><font face="Arial"><font color="#008000">Thankfully, Radiant uses some conventional Windows
commands to make things easier. </font><font color="#ffff00"><span style="BACKGROUND-COLOR: #000000">Ctrl-C</span></font><font color="#008000">
copies a brush and </font><font color="#ffff00"><span style="BACKGROUND-COLOR: #000000">Ctrl-V</span></font><font color="#008000">
pastes it. By copying, pasting and rotating brushes with the </font><font color="#ffff00"><span style="BACKGROUND-COLOR: #000000">X|X</span></font><font color="#008000">,
</font><font color="#ffff00"><span style="BACKGROUND-COLOR: #000000">Y|Y</span></font><font color="#008000">
and other rotate buttons, you can quickly fabricate structures.</font></font></b>

<hr width=80% align="center">
<p><font face="Arial">After you finish the skybox, let’s make a small pool of water in the lower
depression to give our yard some character.</font></p>
<font face="Arial">
10. Find one of the water textures and click on it. Now drag a square brush
through the ground. Make sure you don’t go outside of the brick fence we just
built. See figure 6. I made the depth of my water brush 32 units, just enough to
give it an illusion of depth.</font>
<p align="center"><a href ="content/quake2/tutorials/gensurf_outside/outs_06.jpg"><img border="0" src="content/quake2/tutorials/gensurf_outside/outs_06.jpg" width="450"></a></p>
<p align="center"><font color="#aa0000" size="2" face="Arial"><b>Figure 6: Adding water (click for larger image)</b></font></p>
<p align="center"><font face="Arial"><img border="0" content/quake2/tutorials/gensurf_outside/outs_07.jpg"></font></p>
<p align="center"><font color="#aa0000" size="2" face="Arial"><b>The completed outside area.</b></font></p>
<p align="center">&nbsp;</p>
<hr width=80% align="center">
<p align="center"><b><small><font face="Arial">Copyright 1999, by Terry DeLaney. Permission is granted to
distribute this file as long as the author receives credit.</font></small></b></p></ul><h1 id="530" name="530" class="book-h1">Custom door/plat/button sounds</h1><ul><!-- by Knightmare (andy_howard@bigpond.com) 2004 -->
	 
<h3>Quake II</h3>
<blockquote>
	<b>Custom door/plat/button sounds</b> by <a href="mailto:knightmare66@yahoo.com">Knightmare</a> .
</blockquote>

  <p>I've found a quick way to add support for custom door, plat and button sounds to Q2. This will be in the next release of KMQuake2, but it can easily be added to any MOD.</p>

<hr noshade color="black">
<!--break-->
<h3>Methodology</h3>

<h3>Step 1:</h3>

  <p>In g_func.c, look for this code in the function SP_func_plat:</p>

<blockquote><code>
  ent->moveinfo.sound_start = gi.soundindex ("plats/pt1_strt.wav");</br> 
ent->moveinfo.sound_middle = gi.soundindex ("plats/pt1_mid.wav");</br> 
ent->moveinfo.sound_end = gi.soundindex ("plats/pt1_end.wav");</br>
</code></blockquote>

  <p>and replace it with this:</p>

<blockquote><code>
if (ent->style > 0 && ent->style < 100) // custom sounds</br> 
{</br> 
   ent->moveinfo.sound_start = gi.soundindex  (va("plats/pt%02i_strt.wav", ent->style));</br> 
   ent->moveinfo.sound_middle = gi.soundindex  (va("plats/pt%02i_mid.wav", ent->style));</br> 
   ent->moveinfo.sound_end = gi.soundindex  (va("plats/pt%02i_end.wav", ent->style));</br> 
}</br> 
else</br> 
{</br> 
   ent->moveinfo.sound_start = gi.soundindex ("plats/pt1_strt.wav");</br> 
   ent->moveinfo.sound_middle = gi.soundindex ("plats/pt1_mid.wav");</br> 
   ent->moveinfo.sound_end = gi.soundindex ("plats/pt1_end.wav");</br> 
}</br> 
</code></blockquote>

  <p>This change could also be added to the func_trackchange entity in Lazarus.</p>

<h3>Step 2:</h3>

  <p>In the SP_func_button, replace the following:</p>

<blockquote><code>
if (ent->sounds != 1)</br> 
   ent->moveinfo.sound_start = gi.soundindex("switches/butn2.wav");</br> 
</code></blockquote>

  <p>with this:</p>

<blockquote><code>
if (ent->style > 0 && ent->style < 100) // custom sounds</br> 
   ent->moveinfo.sound_start = gi.soundindex (va("switches/butn%02i.wav", ent->style));</br> 
else if (ent->sounds != 1)</br> 
   ent->moveinfo.sound_start = gi.soundindex ("switches/butn2.wav");</br> 
else</br> 
   ent->moveinfo.sound_start = 0;</br> 
</code></blockquote>

<h3>Step 3:</h3>

  <p>In both the  SP_func_door and SP_func_door_rotating, replace this:</p>

<blockquote><code>
if (ent->sounds != 1)</br> 
{</br> 
   ent->moveinfo.sound_start = gi.soundindex  ("doors/dr1_strt.wav");</br> 
   ent->moveinfo.sound_middle = gi.soundindex  ("doors/dr1_mid.wav");</br> 
   ent->moveinfo.sound_end = gi.soundindex  ("doors/dr1_end.wav");</br> 
}</br> 
</code></blockquote>

  <p>and replace it with this:</p>

<blockquote><code>
if (ent->style > 0 && ent->style < 100) // custom sounds</br> 
{</br> 
   ent->moveinfo.sound_start = gi.soundindex  (va("doors/dr%02i_strt.wav", ent->style));</br> 
   ent->moveinfo.sound_middle = gi.soundindex  (va("doors/dr%02i_mid.wav", ent->style));</br> 
   ent->moveinfo.sound_end = gi.soundindex  (va("doors/dr%02i_end.wav", ent->style));</br> 
}</br> 
else if (ent->sounds != 1)</br> 
{</br> 
   ent->moveinfo.sound_start = gi.soundindex  ("doors/dr1_strt.wav");</br> 
   ent->moveinfo.sound_middle = gi.soundindex  ("doors/dr1_mid.wav");</br> 
   ent->moveinfo.sound_end = gi.soundindex  ("doors/dr1_end.wav");</br> 
}</br> 
else</br> 
{</br> 
   ent->moveinfo.sound_start = 0;</br> 
   ent->moveinfo.sound_middle = 0;</br> 
   ent->moveinfo.sound_end = 0;</br> 
}</br> 
</code></blockquote>

<hr noshade color="black">
<!--break-->
<h3>FILES</h3>

  <p>The custom filenames for doors are:</p>

  <p><UL type="square"> 
     <LI>doors/drxx_strt.wav, 
     <LI>doors/drxx_mid.wav, 
     <LI>doors/drxx_end.wav
  </UL></p>
 
  <p>The custom filenames for plats are:</p> 

  <p><UL type="square"> 
     <LI>plats/ptxx_strt.wav, 
     <LI>plats/ptxx_mid.wav, 
     <LI>plats/ptxx_end.wav
  </UL></p>
 
  <p>The custom filenames for buttons are:</p> 

  <p><UL type="square"> 
     <LI>switches/butnxx.wav
  </UL></p>
 
  <p>Where xx is a 2-digit number from 01 to 99 that corresponds to the style value.</br> 
</p>

<hr noshade color="black">
<!--break-->
<h3>Comments</h3>

  <p>I decided to use the style key for custom sounds because many maps may have different sounds values set for doors. The default QERadiant .def file has door sound sets listed that are from Q1, and many mappers may have given their doors sounds values other than 0 and 1 (default and no sound). I didn't want to change the behavior of existing maps.</p>
</ul><h1 id="51" name="51" class="book-h1">Environmental Maps</h1><ul><h3>Quake2</h3>
	<blockquote>
		Environmental Maps - <a href="mailto:fishman@gamedesign.net">Shane "Fishman" Sherman</a>
	</blockquote>
	
<p>One of the coolest new things in Quake2 are the environment maps. The only problem is that there is not a great variety of them in Quake2. They are <b>unit1_</b> through <b>unit9_</b> and <b>space1</b>. The unit maps are all of the alien world backgrounds and space is the one used on the last few levels. To view these in a map just type <b>sky</b> <i>name of sky</i> at the console.<br><br>

What if you dont like any of the Quake2 environment maps? Well make your own. This is what I will attempt to show you how to do. It's not very easy though.<br><br>

First thing you have to do is draw the art which is by far the hardest part. The environment map acts like a cube around your level so there must be 6 seperate pictures; up, down, left, right, front, back. They aren't orientated the way you think they are though... Below are some screenshots of some of the Quake2 env. maps so you can see what sides must match the other sides.<br><br>

<p><div align="center"><img src="content/quake2/tutorials/env_maps/env_maps_img1.jpg"></div>

<p>The unit5_ environment map.

<p><div align="center"><img src="content/quake2/tutorials/env_maps/env_maps_img2.jpg"></div>

<p>The space1_ environment map.

<p><hr width=75% color=black noshade><p>

<p>Each image <b>must be 256x256 pixels and there must be 2 seperate sets of images</b>. This is because there must be a set of 6 24 bit color tga files for people with 3d acceleration cards and a set of 6 8 bit color pcx files for people without. Remember though that the 8 bit color pictures must be converted to the quake2 pallete. You can get the quake2.act photoshop file on the <A HREF="../../quake2files.shtml">files</A> page.<br><br>

The last thing you need to do is <b>end all your image file names with: bk, dn, ft, lf, rt, and up</b>. These stand for back, down, front, left, right, and up.<br><br>

So if we made a new environment map called earth1 these are the image files we would have to have: earth1bk.tga, earth1dn.tga, earth1ft.tga, earth1lf.tga, earth1rt.tga, earth1up.tga, earth1bk.pcx, earth1dn.pcx, earth1ft.pcx, earth1lf.pcx, earth1rt.pcx, and earth1up.pcx. All of these images would be 256x256 pixels in size.<br><br>

Once you have all your art done and you want to see what it looks like in a level then all you need to do is create a directory off of your /quake2/baseq2 dir called env. and put all the files in that directory. Then load up quake and start playing and type sky <i>name of sky you made</i>. So with earth1 we would type sky earth1.<br><br>

To actually get the sky to appear from the beginning you will need to add sky <i>name of sky</i> to your worldspawn entity. You can also make the sky rotate by adding a <b>skyaxis</b> and a <b>skyrotate</b> key and value into the worldspawn. Thats about all there is to creating your own environmental maps. The hardest part is the art but there are some programs that will make it easier. The one is called Bryce2 which is a 3d landscape creator. There is also a photoshop plugin at <a href="http://www.wasabisoft.com/" target="_top">http://www.wasabisoft.com/</a> that lets you create cubic graphics that you might want to check out. You might also like to have a good graphic editing program. I prefer Photoshop4. also remember that you will have to include your homemade environment map with any level you distribute if you want other people to be able to see it.<br><br>

<p><div align="center"><img src="content/quake2/tutorials/env_maps/env_maps_img3.jpg"></div>

<p>Here is my own bright sky env. map I made

<p>
</ul><h1 id="241" name="241" class="book-h1">Func_areaportal - 1 - Addendum</h1><ul><h3>Func_areaportal - Addendum</h3>

<p>
First off, be warned: this is not a new tutorial on how to make and use a func_areaportal. If you need to know how to make one, check out fishman's tutorial on that very thing.
</p>
<p>
Now, the purpose of this mini-tutorial is to familiarize you with one of the problems you will almost undoubtedly come across when you are using func_areaportals: the dreaded <strong>"func_areaportal [entity number] doesn't touch two areas"</strong> error. Don't worry, it's a pretty simple thing.
</p>
<p><strong>A func_areaportal must entirely separate two areas.</strong> That's it; it's that simple. This means that there can be no "leaks" (for lack of a better word) between the areas on either side of the areaportal. 
<p>
<strong>Anything that does not completely block vis, such as windows, holes, func_walls, detail brushes, transparent brushes, brushes with the mist flag set, liquid, etcetera, etcetera, will generate the error</strong> if that brush or entity connects the two areas. If, on the other hand, another func_areaportal is used, the error is gone. Makes sense, because the very purpose of the areaportal is to block vis.
</p>
<p>
What it all boils down to is this: If you get this error, <strong>make sure that the only way for you or the engine to get (or see) from one side of an areaportal to the other, is through an areaortal</strong> (doesn't have to be the same one.)
<HR>
</p>
<p>Another little thing, and a bonus for sitting through my feeble attempt at coherency:
</p>
<h4>Func_areaportals and multi-part doors.</H4>
<p>
(WooHoo! Excited?) There are a few ways to do muti-part doors, and this is just one. One of the doors in the <a href="http://www.gamedesign.net/miniwood/tutorials/maps/func_ap.zip">example map</A> is a two-part door, for reference.
</p>
<p>Quick and simple. First, create your door, and place one areaportal inside the doorway, just like the door was one piece. Now, give all of the pieces of the door a matching "team" key. For example,                 "door1". Now all of your door pieces have "team"="door1". Next step: set one of the door pieces to target the areaportal. Thats it. 
</p>
<p>There are a few good things about this. First, you won't have to worry about one side of a door triggering the areaportal off, and the other trigering it back on. Second, in the case of an especially wide door, no matter how you approach the door, it will always open all at once.
</p>
<p>
<b>GrrandMaMa</b>
</P>
<BR><BR>

You can download the <a href="http://www.gamedesign.net/miniwood/tutorials/maps/func_ap.zip">example map</a> here. Also if you have any problems or need some help please post to the <a
                href="http://forums.gamedesign.net">forums</a>.</ul><h1 id="242" name="242" class="book-h1">Func_areaportal - 2 - Problems</h1><ul><H3>Func_areaportal - Problems</H3>
<P>
This tutorial was sent to rust by Joel Caesar. We'd like to thank him for helping us out.
</P>
<p>
Some people have problems with the Areaportal entity in Quake 2. Usually, they can get an areaportal setup, and compiling correctly (no errors of the "doesn't touch two areas", or "touches more than two areas" variety). Still, the
infamous hall of mirrors effect will appear. Sometimes it even appears on a previously working Areaportal, after you've added another.
</p>
<p>
Here is a tip to put into your arsenal, to make more or less perfect areaportals. Actually, it's also a door design technique. You need to isolate the door. Completely. Take a look at the accomanying graphic. Here you see a door between two rooms. This could be a door between a room and a hallyway, or between two <b>DIFFERENT</b> hallways. Many people when creating an Areaportal,
actually wind up putting the Areaportal touching two areas, say 1 and 2, but frequently put the areaportal within one of these areas. Therein lies the problem.
</p>
<p>
An Areaportal, I find, has to be <b>BETWEEN</b> two areas, not part of either. Sometimes the HOM effect won't appear with just two portals, but when you have 6 or 7 (like on my map) it eventually happens. Create a box to contain your door. Cut out the hole for the door, being sure to leave some brush on all sides (except the walkway of course). When you create the door, be sure it won't touch the adjacent rooms, and is inset a little. Put the areaportal within the door. You can let it extend into the surrounding brush, but don't let it touch the void.
</p>
<p>
That's it. I have yet to create a door using this technique, with an areaportal, and get the hall of mirrors effect. This works for anykind of door, even rotating ones, and multisegmented doors too. There may be those who say you don't need to do this exactly like this, and sometimes I think that's true, but I find this one so far, has worked 100% of the time for me.
</p>
<center><img src="http://www.gamedesign.net/miniwood/tutorials/images/ap.gif" width=214 height=522 border=0 alt=""></center>
<P>
Well anyways if you still don't understand please post your questions to the <a href="http://forums.gamedesign.net">Forums</a>.</P></ul><h1 id="243" name="243" class="book-h1">Func_areaportal - 3 - Common Problems</h1><ul><h3>Areaportals - Common Problems</h3>

<p>By Joel Caesar</p>

<p>
Areaportals (or APs) tend to be one of the more problematic elements of Quake2. I've found that time after time, people are reading the previous tutorials and are STILL not able to get them working correctly. I almost couldn't believe it, thinking these other people were doing something wrong. Until I was working on a tower in an outdoor area map, I didn't realize that many of the terms related to APs are understood differently. This addendum is a brief recap of some of the previous tutorials, but is not meant as a replacement for all of them.
</p>

<p>I will cover the following items:</p>

<p>
1. A proper AP door (building)
<br>
2. What is an area? ( and placing the AP)
<br>
3. The Hall of Mirrors (HOM) error
<br>
4. The Grey Door Problem. (Updated 4/19/98)
</p>

<h4>1. A proper AP door.</h4>
<p>
A proper AP door is a func_door surrounded on all sides by a frame (required because otherwise the entity touches the void causing a leak--this will be more clear in placement). The func_door then has a target of a func_areaportal. In fig. 1, you can see the frame brushes outlined in white (filled gray). The outline of the func_door is in yellow. The func_areaportal can be seen in fuscia. In my
working with APs, I've found it actually is OK to allow the areaportal to touch the void.
</p>
<p><center><img src="http://www.gamedesign.net/miniwood/tutorials/images/ap0.gif" width="297" height="209" alt="ap0.gif (2896 bytes)"></center></p>

<h4>2. What is an area?</h4>

<p>
An areaportal door needs to be sandwiched between two different areas. Like a slice of cheese between bread. In fig. 2 below, you can see where I've drawn two rooms, and a room and a hallway--I've also drawn the entire AP entity in yellow (func_door and func_areaportal). The door must be BETWEEN, and NOT IN, any of the rooms involved, or hallways (henceforth, areas)--and each area, must be sealed with no leaks or openings, or the area must be terminated by another AP.
</p>
<p>
Sometimes, the two rooms can touch the door entity.  Sometimes it cannot. Why? I can't tell you, suffice it to say, try pushing the two areas together until
they touch the AP door and its frame. If this causes problems, you might need to extend the frame to meet the two areas. Usually the first way does work, so read on to see if you have other problems before changing this, as changing frame size is usually a minor problem.
</p>
<p><center><img src="http://www.gamedesign.net/miniwood/tutorials/images/ap1.gif" width="353" height="319" alt="ap1.gif (3115 bytes)"></center></p>

<p>
Ah hah... there's more. The above fig. 2 is an easy example to see two completely seperate areas. In fig 3. below, there is a room within a room. A common configuration of an outdoor room, or a room within a room. You might think that the two areas here are completely seperate. Quite WRONG. The problem lies in the inner room (red arrow). It's not seperate. It has the same floor and ceiling
(and if it didn't it wouldn't matter--it's not enough of a difference. The problem
is actually the walls.</p>

<p>While not entirely incorrect, this configuration may work as is, albeit with some trouble. Seperating the ceiling and floors of the inner room and making them different brushes of the outer room might work, but not if you need another entrance to
the inner room, other than teleporters.</p>

<p><center><img src="http://www.gamedesign.net/miniwood/tutorials/images/ap2.gif" width="420" height="321"
alt="ap2.gif (3320 bytes)"></center></p>

<p>Here is how to correctly build this type of room for an AP (fig. 4 below). Different walls, different ceilings, and so on (different floors and ceilings, green and blue). Trust me.. If you don't build your rooms like this, you're gonna rebuild them later.</p>

<p><center><img src="http://www.gamedesign.net/miniwood/tutorials/images/ap3.gif" width="397" height="363" alt="ap3.gif (4874 bytes)"></center></p>

<p>Okay.. you say.. I get it, I get it.. But do you? Do you know WHY? Here's
the answer:</p>

<p>1. An area is a completely sealed room (or container if you will) from which, all of
it's interior faces can ONLY be seen from within that area.</p>

<p>2. An area is a completely sealed room from which all of it's exterior faces, can only
be seen by the void (or nothing).</p>

<p>This of course doesn't include looking through where doors would be.</p>

<p>Below, you will find two examples, based on my map "Atmospheric Processor" (terraform2.bsp). I discovered in fig.5 below, my APs weren't working, yet I followed all the other tutorials (obviously). It ultimately came down to "What is an area?" The red outlined brushes represent sky, so this is an outdoor area. The above examples of a room in a room, are basically the box at the bottom of
the figure, with the tower on top. Most of the brushes, more or less were very similar to what you see here. Large, solid brushes. They broke rule 2. above. BSP did not see them as entirely seperate areas (in the tower and outside the tower), even though both ends of the openings (as seen) are terminated with APs.</p>

<p><center><img src="http://www.gamedesign.net/miniwood/tutorials/images/apt1.gif" width="442" height="380" alt="apt1.gif (6296 bytes)"></center></p>

<p>What I had to do is add a small room within the opening (actually I wound up rebuilding the entire tower to learn this--so do what you need to do). I basically wound up with an inner-lower room, and inner-tower room (both connected). The large outer room, was made of the "skybox" and floor room, and the outer shell of the tower, and outer shell
of the lower room (outer shell or lower room not shown below).</p>

<p><center><img src="http://www.gamedesign.net/miniwood/tutorials/images/apt2.gif" width="418" height="386" alt="apt2.gif (7594 bytes)"></center></p>

<h4>3. The Hall of Mirrors Effect (HOM)</h4>

<p>The Hall of Mirrors Effect is an error caused by an areaportal, which causes an area of the map to constantly display the contents of the screen without clearing. It's sort of like giant smudging, and sort of cool lookin I suppose, but.. still.. it's an error to be killed. What causes it? I don't know... But usually, it's not a bad areaportal. HOM usually appears after adding two or more APs to your map and usually it's because they connect the same areas... Can I help you fix it? Maybe.. Here's what I recommend. In the figure below, you will see the typical OK-side, and HOM-side. On the HOM-side you need to make the opening smaller (as
indicated by the red arrows). I'm talking about 2 grid points (pixels) here folks.. If you chose the right textures, you may not even have to realign them.</p>

<p>If you have HOM on BOTH sides of a door, then you have the problem on more than one areaportal. Do the above steps to each areaportal to see if this fixes it. If none of this works for you, I've usually found that having very symmetrical rooms (or groups of rooms) are the cause of this error (but not always), so try repositioning where the door is.</p>

<p><center><img src="http://www.gamedesign.net/miniwood/tutorials/images/hom1.gif" width="374" height="253" alt="hom1.gif (5170 bytes)"></center></p>

<h4>4. The Grey Door Problem</h4>

<p><i>NOTE: I knew I'd figure this out after emailing J. Carmack and all the level designers at Id, and before getting a response... ARGH.</i></p>
<p>I've usually found the grey door problem when testing my level in software mode. Hardware accelerated graphics boards (3Dfx, Permedia2) don't usually show the problem. I have found that this happens under two possible conditions.  Check your areaportals by the numbered list below:</p>

<ol>
<li>Be sure your areaportal has the <b>Clip</b> texture on <b>ALL</b> sides, or, you can use the <b>trigger</b> texture.<br>
<b>NOT</b> the Skip, Hint, or other textures. 
<br>
</li>
<li>Make sure the texture properties (again on <b>ALL</b> sides) have<br>
NoDraw <b>ON</b>, PlayerClip <b>OFF</b>, and MonsterClip <b>OFF</b>!<br><br>
<i>Try compiling at this point.</i><br><br>
</li>
<li>If you still have the grey areaportal, check to see if the frame<br>
of the door (you do have one right) completely touches the<br>
outer edges of the door.<br></li>
</ol>
<p>If the above doesn't work, then the area opposite the grey side may have too many
polygons to be drawn for software mode and this is just a result. You may have to remove the AP door, or change it to a regular door, and then perhaps use a U or L shaped hallway, or some other type of vis-blocker to make this part or your level work.</p>
<br><br>

<h4>Area Portals set for DM and Single Player</h4>

When using Area Portals in both DM and Single Player, you might find some problems.  In the typical single player game, doors are closed.  In DM most, if not all doors, are open.  You'll get the good ol' HOM.  Also, you won't get any errors related to areaportals and the number of areas they touch.
<br><br>
Sure you can take the cheap way (read, "easy") and make doors open real fast and close real fast (I personally like this, cause I don't think there is
any real place where doors are always open).  The hard way, is to have your DM areaportal doors not appear in deathmatch.  Sadly enough, I didn't have
an answer for the HOM portal problem.  Phil Daniels figured it out though, so he gets the credit for the info., cause I'd never have figured it out.
<br><br>
Most entities in most editors have spawnflags for whether they appear in single player, deathmatch, or under a particular difficulty level.  The
logical thing to do, would be to set the door to have a spawnflag "not in deathmatch" and the same for the areaportal (after all there is no more
door).  Nope.
<br><br>
The areaportals cannot be set this way.  They have to be operated, not flagged out (i.e. they will still be loaded).  Set a trigger_always targeted
to the ap's name and set it's spawnflags to "not in easy", "not in normal", and "not in hard".  The AP should have NO flags set, the door has "not in
deathmatch" set.
<br><br>
The level loads in DM and at load point, the areaportal is triggered (stays open) so there is no HOM.


<p>Copyright © 1998 Joel Caesar<br>
Permission granted to R U S T to publish this doc.</p></ul><h1 id="52" name="52" class="book-h1">Hint Brushes De-Mystified</h1><ul><h3>Quake 2</h3>
	<blockquote>
		Hint Brushes De-Mystified - <a href="mailto:jcaesar@mediaone.net">Joel "Death Mongrel" Caesar</a>
	</blockquote>
	
<br><br><b>Why this tutorial?</b>

<p>Even with the recent .plan file posting from PlanetQuake's QuakeFinger server detailing how to use hint brushes, many people still find them difficult to understand. I therefore offer this "Tutorial" to help you learn how, where, when, and why to use them. 

<p>The difficulty in learning how to use hint brushes is complicated, mainly because one has to know how the bsp and vis utilities (or QBSP/QVIS) actually work. I may not be 100% correct here, but in some test maps, the effects desired were achieved by placing the hint brush according to the steps which will follow below. 

<p>Knowing how bsp works is the most important aspect of using hint brushes. Learning how bsp builds triangles out of your brushes can really only be done well if you have a FULL OpenGL implementation on your build machine. If you do, you can use "gl_showtris 1" in the console to have the Quake2 engine display the triangles. Unfortunately 3Dfx boards don't allow this. FireGL1000Pro's from Diamond work nicely, and are a decent 3D accel. for NT (Not as smooth as 3Dfx in games like GLQuake1/2). The FireGL1000Pro also doesn't show colored lighting (if they do, I'd like to know how to turn that on). 

<p>All of the figures below will be shown from the top-down view only. (Please note that bsp will often be more complicated in building triangles out of your brushes, and my example was drawn to keep it "clean" and understandable). 

<p><hr width=75% color=black noshade><p>

<p><b>Part of the Map</b>

<p><div align="center"><img src="/content/quake2/tutorials/hint/hint_img1.gif"></div>

<p>Here is an example hallway between two areas (shown in later examples). Again, shown from the top-down view.

<p><hr width=75% color=black noshade><p>

<p><b>Understanding BSP Created Triangles</b>

<p><div align="center"><img src="/content/quake2/tutorials/hint/hint_img2.gif"></div>

<p>When you run BSP (or QBSP3) the program goes through each brush and slices it into triangles. Some people refer to the triangles as polygons. I will use the term triangles, because that should remind you that, to my knowledge, Quake doesn't use 4-point polygons. 

<p>Here you can see the brushes (at least as far as top-down view is concerned) have been divided into triangles as shown by the yellow lines. 

<p><hr width=75% color=black noshade><p>

<p><b>Understanding How VIS Determines What to Draw</b>

<p><div align="center"><img src="/content/quake2/tutorials/hint/hint_img3.gif"></div>

<p>Here you can see we've added two areas in red, representing either more hallways, rooms, or any "container" in which the player can go or see. 

<p>Notice the green line of sight line (LOS) that I've drawn. It indicates how far you can see into the hallway and around its corner from Area 2. 

<p>Now say your player is at Point A. Since he is not past the green line, the Quake engine will not draw triangles of and within Area 2. Now say your player moves to Point B. Suddenly, the Quake engine will draw area 2--and you're still behind the LOS line! 

<p>The reason? Point C, which is on the SAME triangle as Point B, can see into Area 2. When VIS determines what can and can't be seen from a single triangle, it uses the vertexes (I assume ;). 

<p><hr width=75% color=black noshade><p>

<p><b>What a Hint Brush is and How to Place It</b>

<p><div align="center"><img src="/content/quake2/tutorials/hint/hint_img4.gif"></div>

<p>A hint brush, is a brush with the hint texture applied to all sides. Typically you make it as small as is manageable (about 8 units thick) and large enough to slice through the area you need to "split." 

<p>As shown in the diagram, the hint brush (in pink, or fuscia if you will), completely slices through the section of hallway. DO NOT USE CSG!!! You will create a leak if you do. The hint brush is not rendered, and is only used by VIS (more on that in part 4). 

<p>In this example, the hint brush has been placed almost to the line of sight and extends into the void through the hallway. 

<p><hr width=75% color=black noshade><p>

<p><b>What the Hint Brush Does</b>

<p><div align="center"><img src="/content/quake2/tutorials/hint/hint_img5.gif"></div>

<p>The hint brush forces QBSP to "break" brush triangles at the indicated points (see diagram), creating more triangles VIS can use to calculate with. 

<p>Now, when the player is at Point A or B, Area 2 is NOT drawn. When the player is at Point C, Area 2 IS drawn. Notice how in example 2, Area 2 is drawn for 50 percent of the hallway. The triangle in example 4, under Point C, is now about 25 percent as large as it was previously. 

<p>What this means is, you've added maybe 10-20 triangles but 80 percent of the hallway doesn't draw Area 2, saving you even more triangles from Area 2 being drawn. 

<p><hr width=75% color=black noshade><p>

<p><b>Final Notes</b>:

<p>You need to be careful adding hint brushes. If BSP had created triangles as in example 4, then you don't need to add a hint brush. The "break" is already there. Adding the hint brush in this case would simply increase the total number of triangles in the hallway, completely defeating it's purpose.

<p>Also, in order to accurately determine whether or not you need a hint brush in a specific place, you really need the gl_showtris option set to 1, and a full OpenGL implementation on your system.

<p>
</ul><h1 id="46" name="46" class="book-h1">Jump pads in Q2? You betcha!</h1><ul><!-- <html> --> 
<!-- temp tag used for previewing, remove later -->

<!-- angles_data.htm - converted 21/08/01 from old rust documents -->
<h3>Quake 2</h3>
<blockquote>
		Jump pads in Q2? You betcha! - 
		<a href="mailto:rascal@magnolia.net">David Hyde</a> &amp; 
		<a href="mailto:tonykat127@earthlink.net">Mad Dog</a>
</blockquote>
<br><br>	

<h3>The "angles" key/value pair</h3>

 <p>OK, this is a long story, but you goons are required to read the whole thing... 
	that's the price you pay for cool information. My 
	<a href="http://tarot.telefragged.com"> Tarot</a> teammate and spiritual advisor 
	Monsto Brukes wanted to simulate Q3 jump pads in Q2 for map testing purposes. 
	Tarot's bit_twiddling nerd guy (that's me) opened up the Q2 source and started to 
	plug in an elevation value. But wait... he found that trigger_push code refers to 
	the "angles" key... but that's not right he says... trigger_push just uses 
	"angle". Well it turns out id didn't trust you mapper goons to be able to do a 
	little simple trigonometry, so they published the input for trigger_push as 
	"angle" only, but the code does not have that limitation.</p>

 <p>The "angles" values are pitch (up/down), yaw (left/right) and roll (fall over). 
	If "angle" is specified for an entity, then the code automatically sets "angles" 
	to 0,angle,0... and these values are used for the entity. But what happens if 
	instead of specifying "angle" in the .map file, you set the three "angles"?... 
	heh heh... you know the answer, don't ya? And all it takes is a little math to 
	translate those angles into movement directions... but not to worry, Tarot's 
	bit_twiddling nerd has done that for you. The translations performed by the game 
	source end up making a positive pitch down from horizontal. Yaw is unaffected by 
	this, so you'd use the same angle you've previously used for the angle key. And 
	roll is ignored for trigger_push, which is a shame, really... it would be nice 
	to have a trigger_push that made you do flips. Anyhow... quick example, and I'm 
	sure you can take it from there. Say you want the trigger_push to push you up 60
	degrees from horizontal and to the west. Set "angles" to _60 180 0. That's it.</p>

 <p>So how do you go about using this info in your editor? If your editor allows you 
	to enter user_defined keys (qED, QERadiant, QuArk), you're all set. Just enter 
	"angles" for the key and "<_pitch> <yaw> 0" for the value. If you're using Tread, 
	open up quake2.gdf, find trigger_push, and enter the following below the "angle" 
	line:<br>
	<blockquote><pre>def_key : string : "angles" : "pitch yaw roll" : ""</pre></blockquote><!-- <br> -->
	If you're using WorldCraft, Mad Dog has already done the work for you... 
	<a href="http://home.earthlink.net/~tonykat127/mapediting/fgd_q2.zip">get his new 
	.fgd file.</a> If you're using Qoole, stop. (ed. I’d have to agree.)</p>

 <p>One qualifier that could foul this up for you: If your editor forces an "angle" 
	key to be written to the .map file, "angles" will still work as long as it occurs 
	after the "angle" definition. So if you try this and you get the same old 
	trigger_push behavior, open up your .map file in a text editor, find the 
	trigger_push, and delete the "angle" line.<br>
	<br>
	The syntax for an 'angles' keyvalue is:<br>
	<blockquote><pre>"angles" "pitch yaw roll"</pre></blockquote><!-- <br> -->
	Pitch can be any number from _90 to 90; negative numbers "aim" up and positive 
	numbers "aim" down. Yaw can be virtually any positive number, generally 0_360 
	(this would be the same value one would typically use for 'angle'). Roll can be 
	any number from _180 to 180; this affects the "canted" view one can achieve with 
	an info_player_intermission. Depending on the entity, a "roll" value of anything 
	other than 0 can yield no result, an interesting result, or a result you want to 
	avoid.</p>
	
 <p>Some example entities by way of explanation:
	<ul type="square">
		<li><b>Ammo</b> - Ammo need not lie flat. If you want to put a box of ammo 
			on a tilted floor, or simulate an item amid a jumble of other debris you 
			can. Note that the bounding box of the ammo does not change position or 
			orientation, so you may need to work in a wedge_shaped mist brush in 
			there to get the visual effect just right. Giving values to all three 
			angles is fine.
			<br>&nbsp;
		<li><b>Player starts, deathmatch starts, teleporters</b> - DM spawn points 
			and teleporter/dest platforms can be canted just like ammo. However the 
			'angles' value translates into the direction the player looks when he 
			spawns. So if you want the player to spawn up on a high ledge, looking 
			down on the action, you could give the spawn point an 'angles' value of 
			"45 0 0", for example. Even if the player has freelook off and lookspring 
			on it works fine. I strongly advise against using a "roll" value of 
			anything other than 0, since the player gets stuck with the canted view. 
			Until he hits a teleporter dest which straightens him out anyway. Unless 
			of course you want to simulate drunkeness.
			<br>&nbsp;
		<li><b>Strogg ships, Vipers</b> - Simulate diving or launching ships. Or a 
			crashed misc_bigviper. Looks cool; use all 3 values. Advise the use of a 
			playerclip brush to avoid weird clipping problems with the misc_bigviper 
			model in the game.
			<br>&nbsp;
		<li><b>Banner</b> - All 3 values work, but the appearance is odd; so "roll" 
			has little value __ but a slight "pitch" effect could have its place I 
			suppose.
			<br>&nbsp;
		<li><b>Monsters</b> - Good for a laugh. Give a monster_soldier an 'angles' 
			keyvalue of "60 0 0" and he "swims" on the floor. Too bad monsters drown 
			in water. Death animations can be even funnier.
			<br>&nbsp;
		<li><b>Target_blasters</b> - Want a blaster that shoots up or down at an 
			angle? No problem. "Roll" values don't matter. Works with lasers too, if 
			you don't want to bother with an info_null. And it works with the 
			target_splash too.
			<br>&nbsp;
		<li><b>Doors and buttons</b> - This is very very cool. You can have
			multi_piece doors that move up/down at angles, and buttons that recess 
			properly into angled consoles. Figuring out 'lip' may be a problem; 
			I haven't experimented but I suspect that the game uses either a 
			horizontal or vertical orientation for calculating 'lip'; so I would
			avoid using _45 and 45 for "pitch", so you can get predictable results. 
			Again, "roll" doesn't matter.
			<br>&nbsp;
		<li><b>Weapons, keys, armor, etc</b> - Spinning crap seems to ignore 
			'angles'. Too bad.
	</ul>	
	Anyway these are some ideas. In order to use the 'angles' key properly in 
	Worldcraft, you should set 'angle' to '0'; this removes the 'angle' key from 
	the .map file. My .FGD prompts you for "pitch yaw roll" for entities which can 
	make use of "roll", and it prompts you for "pitch yaw 0" for entities which 
	can't.</p>
	
 <p>The team was so fired up about this that we built a fun DM map for you guys to 
	check out. We started out making a small tutorial sort of thing, but it got out 
	of hand pretty quickly and turned into the real deal: <br>
	<a href="http://tux.telefragged.com/file.pl?filename=jumpbch.zip&dir=telefragged/tarot/ryo/">
	You can download the map here (589Kb)</a>.<br>
	The map is an r_speeds hog, so if you don't have a 3D card please don't bother. 
	The .map file is included.</p>
	
 <p>You can download Mad Dogs .FGD 
	<a href="http://home.earthlink.net/~tonykat127/mapediting/fgd_q2.zip">here</a>.</p>
										
 <p><b>David Hyde:</b><!-- <br> -->
	<ul type="square">
		<li><a href="http://www.magnolia.net/~rascal">Home Page</a>
		<li><a href="http://mapspy.gamedesign.net">MapSpy 1.0</a>
		<li><a href="http://www.planetquake.com/gensurf">GenSurf 1.7</a>
		<li><a href="http://tarot.telefragged.com">Tarot Game Development</a>
	</ul>
	</p>

 <p><b>Mad Dog:</b><!-- <br> -->
	<ul type="square">
		<li><a href="http://home.earthlink.net/~tonykat127/">Home Page</a>
	</ul>
	</p>

 <p>Note: This tutorial was copied almost verbatim from the 
	<a href="http://forums.gamedesign.net">Rust Forums</a> (ed. note: the 
	<a href="http://forums.gamedesign.net/forums/">OLD Rust forums</a>, 
	that is - <a href="mailto:merlinis@bigpond.net.au">Merl</a>) with minimal 
	editing by <a href="mailto:raygunn@gamedesign.net">raYGunn</a>. It is also 
	interesting to note the discovery of the usage of the angles key by the authors 
	was independent and for different purposes.</p>

</font> <!-- jic -->

<!-- eof @ 163 --></ul><h1 id="47" name="47" class="book-h1">Making ENV. Maps with Bryce 2</h1><ul><h3>Quake 2</h3>
<blockquote>
	Making ENV. Maps with Bryce 2 - <a href="mailto:m.christian@student.murdoch.edu.au">Murray "[PnC]Muzman" Christian</a>
</blockquote>

<br><br>

<p>Want to make environment maps for Quake2 that don't look cubic? Want to do it without spending ages touching up the corners of the individual sky pics? This tutorial is about how to do exactly that with Bryce 3d.<br><br>

If you don't know anything about Q2 skies/environment maps you should read Fishman's tutorial on the subject to get familiarised with the basics. In particular the different images and the file name system for different angles, the different file formats for different renderers (software and hardware) and how to set the sky into your map (I'm not a mapper, I can't tell you how to do that).<br><br>

The technique described in this tutorial was done using Bryce 3d and Photoshop 4; Bryce 3d for building the scene and Photoshop 4 to convert it into the format used by Quake2. Photoshop 4 isn't essential for this, any graphics program will do so long as it can resize images and convert them to different formats and colour modes  (the shareware version of Paintshop pro for example). This technique should also work with Bryce 2 no problem, but some of the functions I talk about might be in different places. I'm also assuming that people reading this are reasonably familiar with Bryce 2 or 3d; how it works, rendering etc. If you want some more detail on Bryce 2 scene building there's a list of sites at the bottom that will get you started (and  much more). <br><br>

Ok, the first and most important thing to do is create a Bryce 2/3d document for the env map and set up the document, the camera and the sky  for (pretend) spherical rendering.</b><br><br>

Go into the File menu and go into Document setup. Down the right hand side of the box that pops up there is a list of default aspect ratios; pick Square (this makes the aspect ratio 1:1 ie the top/bottom and side resolutions will be the same)<br><br>

Next put in a resolution. Anything will do so long as the aspect ratio stays square. Also, remember that the final pics will have a resolution of 256x256, Photoshop and the like reduce images best when proportions are nice and relative, so multiples of 256 will get the best results. I chose 512x512 because I run windows in 800x600 and it fits nicely on the screen.<br><br>

This is what it should look like (in case I'm making no sense)<br><br>

<p><div align="center"><img src="/content/quake2/tutorials/bryce2/bryce2_img1.jpg"></div>

<p><hr width=75% color=black noshade><p>

<p><b>Next, the camera</b>

<p>Select a view other than the camera's view and select the camera itself. Go into the camera attributes (the little "A" seen right).

<p><div align="center"><img src="/content/quake2/tutorials/bryce2/bryce2_img2.jpg"></div>

<p>Set all the rotation axis' to zero. Set all the position axis' to zero except the y axis. This is the height of the camera  off the "ground". How high you put it is up to you, it depends on the sky you want and how it is meant to fit into the map. For example; I did a suburban sky and I wanted it to look like the ground and the players head/viewing height were in proportion, so setting y to 4 turned out to be the best. Over all there is not much need to go over 10 for this setting. Set the field of view (FOV) to 90 degrees. Set the viewing scale to 72 percent. These two settings are vital to making the finished product blend together, removing any "corners" from the sky.  Once set, do not change them. (In case you're wondering, it means that only 72 percent of the actual FOV is at 90 degrees. The rest is dragged in from 'outside' to fill the view, distorting things slightly. It's similar to increasing the FOV in Quake2; since you can't change the size of your monitor things get distorted. Confusing; hard to explain; but it works.) After all that the camera settings should look like this (with important stuff underlined in red)

<p><div align="center"><img src="/content/quake2/tutorials/bryce2/bryce2_img3.jpg"></div>

<p><hr width=75% color=black noshade><p>

<p><b>Now, the one and only sky setting</b>

<p>Go into the Sky&Fog section and pull down the options, choosing  Edit Sky/Fog

<p><div align="center"><img src="/content/quake2/tutorials/bryce2/bryce2_img4.jpg"></div>

<p>In there, make sure that the option 'Link sun to view' is turned off /not ticked. This is very important as it makes the sun stay put when rotating the camera (which we will be doing later), otherwise, as the name suggests, the sun will re-align in relation to the camera position. This option might be somewhere different in Bryce2, just remember to find it and turn it off or the whole effect will be lost.

<p><hr width=75% color=black noshade><p>

<p><b>Now the document is ready for the render sequence</b>

<p>Go ahead and build the scene, with the camera as the centre. You might want to do something simple to start with, like an infinite water plane and one of the preset cloud and sun arrangements, just to try it out.<br><br>

Once the scene is finished it's time to do the final render of the six images that make up the Q2 sky.  If the camera has been moved while doing the scene make sure it's returned to the position described above before you render using the following instructions.<br><br>

The camera is going to be turning right and up and down; doing this involves changing the x and y rotation axis' in the camera attributes (see the camera settings picture back up the page a bit).<br><br>

First render the scene (through the camera view) with x, y and z rotation at zero.  Then export the image (give it an obvious name with a 1 at the end). Five more to go.  Follow this sequence of camera rotations to get the rest.<br><br>

<blockquote>
	x= 0 y= 90 z= 0.  Render.  Export the image, named as the second in the series<br>
	(NOTE: Bryce will replace the rotation angles with negative numbers sometimes. Just delete them and put in the ones given here as you change them.)<br><br>

	x= 90 y= 90 z= 0. Render. Export the image, named as the third in the series.<br>
	x= 0 y= 180 z= 0. Render. Export the image, named as the fourth in the series<br>
	x= 0 y= 270 z= 0. Render. Expert the image, named as the fifth in the series.<br>
	x= 270 y= 270 z= 0. Render. Export image, named  as the sixth in the series.
</blockquote>

If everything went according to plan the last render should have been the camera pointing straight up.  And now you have six images which make up a cube.

<p><hr width=75% color=black noshade><p>

<p><b>Next up, the six images must be converted to Quake2's formats</b>

<p>Load them all into your graphics program and shrink them all to 256x256 pixels. Then change them to the appropriate file name (remember those little tags on the end for each face) and save them in .tga format. The filenames for the six pictures are as follows:

<blockquote>				
	image 1: back (bk)<br>	
	image 2: right (rt)<br>	
	image 3: down (dn)<br>	
	image 4: front (ft)<br>	
	image 5: left (lf)<br>	
	image 6: up (up)<br>	
</blockquote>

Then things get tricky, converting to 256 colours for the .pcx versions can have…….questionable results.  It depends on the colours in the original image and how close they are to colours in the Quake2 palette. Techniques on how to convert can be found all over the web, I used the one I found in the "tutorials" section of <a href="http://www.labyrinth.net.au/~jchin/skins/skins.htm" target="_top">this</a> page. This site describes both Paintshop and Photoshop conversion techniques for skins, but works great for skies as well. It gets around the differences that Photoshop and Quake2 have for the pcx format nicely.<br><br>

However, after conversion some serious touching up might be needed to get the most out of the format. (Photoshop dithering can be really bad, depending on the sky. Experiment a bit.)<br><br>

For an example check out the env map from the second of the awesome Falhaven ctf maps by Lance S. Winkel (<a href="http://www.planetquake.com/dl/dl.asp?captured/ctf2review/falhavn2.zip" target="_top">here</a>). The difference between the gl and sofware versions is vast, but necessary to keep the effect.<br><br>

Anyway, by now you should have a sky to try out on your map. For more map specific skies the orientation might have to be changed, just rotate the file names of the side images and rotate the actual up and down images to suit (a tip: the front -ft- image of the sky always joins to the right side of the up and down images). Or better yet, find out which way the sky sits in the map and build the sky to suit it.<br><br>

Good Luck! And mail me with any major questions (or better ways to do it)<br><br>

<p><hr width=75% color=black noshade><p>

<p>Some shots of the sky I did for the forthcoming Action Q2 map "The Crackdown" by Wanderer.

<p><div align="center"><img border="0" width="450"  src="/content/quake2/tutorials/bryce2/bryce2_img5.jpg"></div>

<p><div align="center"><img border="0" width="450"  src="/content/quake2/tutorials/bryce2/bryce2_img6.jpg"></div>

<p><hr width=75% color=black noshade><p>

<p>For more about the Bryce series and how to get the most out of them visit some of these<br><br>

<a href="http://www.metacreations.com" target="_top">http://www.metacreations.com</a><br>                       
The makers<br><br>

<a href="http://www.peter-sharpe.com" target="_top">http://www.peter-sharpe.com</a><br>                          
The home of indepth, advanced Bryce3d <br><br>

<a href="http://www.geocities.com/SoHo/Lofts/9589/bryce_almanak.html" target="_top">http://www.geocities.com/SoHo/Lofts/9589/bryce_almanak.html</a><br>
Absolutely everything and everywhere Bryce<br><br>

<a href="http://www.geocities.com/SoHo/Lofts/9589/bryce_tutorials.html" target="_top">http://www.geocities.com/SoHo/Lofts/9589/bryce_tutorials.html</a><br> 

How to do absolutely everything in the Bryces, from the ground up

<p>
</ul><h1 id="561" name="561" class="book-h1">Making Rain</h1><ul><!-- by by Chris "Kold" Stringer 2004 -->
<center><h3>Making Rain for Quake II and III</h3>
by Chris "Kold" Stringer</center>
<p class="q2bg1">Quake II has long been a game with many things we wanted but couldn't always have. <a href="http://www.planetquake.com/j-spot/jbuzz.html">Jester</a>, a fellow mapper recently made this deathmatch map and despite the amazing brush &amp; texture work .. one thing that caught my attention was the rain, now although quake II doesn't support such a feature without a engine mod, there's several ways to make it with one of them being animated (or flowing) textures if you will.<br><br>
<span class="note"><b>IMPORTANT CONSIDERATION:</b> There's one flaw to making the rain in this tutorial and that's the <a href="http://www.gamedesign.net/book/view/53">r_speeds</a>, you'll notice a massive difference in fps .. that noted don't use this affect too much in your map or it will be unplayable in the online arena's.</span></p>
<hr noshade width="75%" align="center">
<h3>Requirements:</h3>
<p class="q2bg1">Before you start this tutorial, in order for the rain to work you'll need a graphics card with the latest opengl driver's installed as the affect's of the texture/rain rapidly disappear in software mode as explained in this <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/54">tutorial</a>.<br><br>You'll also need the <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/content/quake2/tutorials/make_rain/rainb.wal">rain texture</a> and the <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/content/quake2/tutorials/make_rain/raintut.zip">example map</a> I'm using in this tutorial (the rain texture is in the .zip with the example map)<br><br>In the editor, work with the grid settings on "16" as that's what I'm using in this tutorial.<br><br>phew ! With keeping all the above in mind, in this tutorial i'll show you a fast and affective way to make some convincing looking rain in no time!</p> 

<hr noshade width="75%" align="center">

<h3>Step 1: Make a Small Room</h3>
<center><img border="0" width="450" src="content/quake2/tutorials/make_rain/koldtut2.jpg"><br>
"TOP" View in QuArK</center><br><br>
<center><img border="0" width="450" src="content/quake2/tutorials/make_rain/koldtut1.jpg"><br>
in game shot</center><br><br>

<p>Firstly make a small room as shown above, then add a info_player_start in there along with some light fixtures to give us some light. I'm using Quark's default room for this tutorial so most of this should be already done for you . </p> 

<hr noshade width="75%" align="center">

<h3>Step 2: Adding the Rain Texture</h3>
<center><img border="0" width="450" src="content/quake2/tutorials/make_rain/koldtut3.jpg"></center><br><br>

<p>Next we'll add the rain texture into the map you just created , in the screenshot in step 1 there's a opening in the roof , make 1 brush for a start to fit between the sky brush and the floor ( click the image above on the left for a closer look )</p>

<center><img border="0" width="450" src="content/quake2/tutorials/make_rain/koldtut4.jpg"></center><br><br>

<p>Then rotate the texture if its facing the wrong way to look like the picture above, the flag settings should already be set with the texture but if they aren't add the following to each face <i>mist</i>, <i>current_dn</i>, <i>trans33</i> and <i>flowing</i>.</p>

<center><img border="0" width="450" src="content/quake2/tutorials/make_rain/koldtut5.jpg"><br>
The applied rain texture</center><br><br>

<p><b>Important:</b> Sometimes your rain may be flowing upwards ;o), if it is then just rotate the texture on that certain face in till it starts going the right way.</p>

<center><img border="0" width="450" src="content/quake2/tutorials/make_rain/koldtut6.jpg"><br>
the 5 brushes spread apart</center><br><br>

<p>Next, copy the brush you just made into 5 copy's , randomly move them around the gap in your roof as shown with the image above on the right, they don't have to be exactjust roughly but keeping them inline with the sky and the floor brushes as you did with the first brush. I spread mine apart to give the rain a better look.</p>

<center><img border="0" width="450" src="content/quake2/tutorials/make_rain/koldtut7.jpg"><br>
click for a bigger view</center><br><br>
 
<p>There's different ways you can tweak the affect I've just shown you like stretching the rain texture a little longer to give it a faster looking affect</p>

<hr noshade width="75%" align="center">
<h3>Step 3: The Result!</h3>
<center><img border="0" width="450" src="content/quake2/tutorials/make_rain/koldtut8.jpg"><br>
the finished result</center><br><br>
<hr noshade width="75%" align="center">
<h3>Summary</h3>

<p>I hope you enjoyed this tutorial and even if there isn't a true way to make rain in quake 2 , this is probably the closest you'll get without a engine mod . I look forward to writing more tutorials in the future, but until then go make yourself some rain! :o)<br><br>Here's my contact details if you need further help with this tutorial: <script language="JavaScript" type="text/javascript"> <!--
document.write('<a href="&#32;&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#107;&#111;&#108;&#100;&#111;&#110;&#101;&#64;&#109;&#115;&#110;&#46;&#99;&#111;&#109">koldone</a>');
// --> </script></p>

</ul><h1 id="54" name="54" class="book-h1">Partial Transparency</h1><ul><h3>Quake 2</h3>
	<blockquote>
		Partial Transparency in Quake 2 - <a href="mailto:jexjackl@home.com">Jex</a> and <a href="mailto:suppenhuhn123@hotmail.com">Who</a>
	</blockquote>
	
<br><br>

<p>Something that's always been missing from Quake 2 is the ability to have "holes" in a texture. Half-life was one of the first games to properly implement "holes". Some examples of this are: see-through, shoot-through railings made from a single brush, see-through grating for floors. Well it is possible to do the same in Quake 2. While Quake 2's Partial Texture Transparency is not perfect, when used intelligently, it is a simple and effective way of adding detail without adding many faces.

<br><br><b>Image of the web texture before and after:</b>

<p><div align="center"><img src="/content/quake2/tutorials/pttrans/pttrans_img1a.jpg"> <img src="/content/quake2/tutorials/pttrans/pttrans_img1b.jpg"></div>

<p><div align="center"><img src="/content/quake2/tutorials/pttrans/pttrans_img2.jpg"></div>

<p>The first step in the process is preparing the texture; punching the "holes" in it. Any part of the texture that will be invisible must be coloured with Quake 2's transparency colour (Red: 159, Green: 91, Blue: 83). In our examples all the black spaces in the cobweb are replaced with the transparency colour.

<p>Once you've got you texture prepared, it is only a matter of applying the texture to a brush and setting the proper flags. In all cases either trans_33 or trans_66 will be checked (usually trans_66 as trans_33 makes the visible parts of the texture very noticably translucent) as this is what does the magic. This flag must be applied to all faces of the brush. All other flags are completely optional as with any other brush. 

<p><div align="center"><img src="/content/quake2/tutorials/pttrans/pttrans_img3.jpg"><br>Image of the web texture without trans_66 checked.</div>

<p><div align="center"><img src="/content/quake2/tutorials/pttrans/pttrans_img4.jpg"><br>Image of the web with trans_66 checked, the web texture is applied on all faces.</div>

<p><div align="center"><img src="/content/quake2/tutorials/pttrans/pttrans_img5.jpg"><br>Image of the web with a totally clear texture, and the web texture applied to one face (the "correct" way).</div>

<p>When making a fence-like brush, you will only want to have 1 face of the brush visible. One way would be to make a completely transparent texture to apply to all faces but one. This would be the "proper" way to do it. But there is also another trick which may come in handy as well as decreasing the translucency of the visible fence. Create the fence as a 1 unit thick brush. Keep the fence texture applied to both sides of the brush. If the brush is any thicker than 1 unit the double effect can become quite noticeable, but at 1 unit apart the player has to be very close to notice the effect.

<blockquote>
<p><div align="center"><a href="/content/quake2/tutorials/pttrans/pttrans_img6.jpg"><img src="/content/quake2/tutorials/pttrans/pttrans_img6_sm.jpg" border=0></a><br>Image of two fences, the right side is a brush 8 units thick. You can clearly see the double effect. The fence on the right is only 1 unit thick, making the double effect disappear, and also reducing the translucency.</div>
</blockquote>

<p>One disadvantage of this technique is that it cannot be used in software mode:

<p><div align="center"><a href="/content/quake2/tutorials/pttrans/pttrans_img7.jpg"><img src="/content/quake2/tutorials/pttrans/pttrans_img7_sm.jpg" border=0></a></div>

	<b>Things to remember when using this technique:</b><br>
        <li>This does not work in software rendering mode.
        <li>The visible parts of the texture will always be translucent which makes thinner visible areas preferable (example: a wire fence). 
        <li>Translucency can be reduced by making the brush 1 unit thick with two exact visible sides overlapping eachother. 
        <li>Placing the transparent brush partially out of range of the player will reduce the chances of any translucency/double effect being noticed. 
        <li>Colour for transparency is: Red: 159, Green: 91, Blue: 83. 
        <li>Detail added this way does not produce high r_speeds. 
        <li>Only works with trans_33 or trans_66 applied to all faces. 
        <li>Wherever the transparent brushes intersect other brushes, a faint red glow appears.<br>

<br><br><b>Some Examples:</b>

<p><div align="center"><a href="/content/quake2/tutorials/pttrans/pttrans_img8.jpg"><img src="/content/quake2/tutorials/pttrans/pttrans_img8_sm.jpg" border=0></a></div>

<p><div align="center"><a href="/content/quake2/tutorials/pttrans/pttrans_img9.jpg"><img src="/content/quake2/tutorials/pttrans/pttrans_img9_sm.jpg" border=0></a></div>

<p><hr width=75% color=black noshade><p>

<p> You can download the example map <a href="/content/quake2/tutorials/pttrans/pttrans_ex.zip">here</a>.

<p>
</ul><h1 id="53" name="53" class="book-h1">Polygon Count Reduction</h1><ul><h2>Polygon Count Reduction</h2>

<blockquote>By David Hyde, Mad Dog and Richard Neff</blockquote>
<br><br>
<!-- Table of Contents -->
<a name="TOC"></a>  
<p><b>Contents</b><br>
<p>(Click on a heading to quickly scroll down the page)<p>
	<ul><li><a href="/node/53/#introduction">Introduction</a><br>
        <li><a href="/node/53/#examples">Example maps</a><br>
        <li><a href="/node/53/#tricks">The Tricks</a><br>
		<ul><li><a href="/node/53/#cut1024">Awarenessof qbsp3's default cuts</a><br>
		<li><a href="/node/53/#func_wall">Alternative uses of func_walls</a><br>
		<li><a href="/node/53/#embedlites">Embedded light fixtures</a><br>
		<li><a href="/node/53/#donut">Doughnut hallway</a><br>
		<li><a href="/node/53/#evil">Brush subtraction is evil</a><br>
		<li><a href="/node/53/#gaps">Gaps between brushes</a><br>
		<li><a href="/node/53/#detail">Detail brushes</a><br>
		<li><a href="/node/53/#miter">Mitered corners</a><br>
		<li><a href="/node/53/#textures">Let the textures do the work</a><br>
		<li><a href="/node/53/#threesides">3 sides rather than 4</a><br>
		<li><a href="/node/53/#opaque">Transparent vs. opaque water</a><br>
		<li><a href="/node/53/#nodraw">No draw = No polys</a><br>
		<li><a href="/node/53/#fooled_you">Fast framerates for large, detailed areas</a></ul>
	<li><a href="/node/53/#summary">Putting it all together</a></ul>

<br><br>
<p><br><hr color=black noshade width=75%><br><p>

	<a name="introduction"></a><b>Introduction</b><br>
	<p>The purpose of this tutorial is to describe several simple techniques you can use in your Quake2 maps to reduce the number of polygons seen by the game engine, thereby increasing the performance of your map and improving gameplay. None of the techniques described here are difficult to implement, and will usually not result in any undesirable tradeoffs, i.e. reduced visual quality. This tutorial does <b>not</b> discuss hint brushes, which, like the techniques discussed here, are often used to influence the way qbsp3 partitions brushes. Proper use of hint brushes is a difficult technique to master, and, unlike the methods discussed here, generally requires a trial-and-error approach to achieve the desired results. NOTE: Don't even think about using hint brushes unless you are able to run &quot;gl_showtris 1&quot; (see below). It's just about impossible to know how to use hint brushes to block off areas when you don't know what the engine can/cannot see from a view. For more information on the use of hint brushes, see Steven Boswell's excellent article, <a href="/content/quake2/tutorials/poly_count/bspvis.htm">qbsp3, qvis3, and map-making</a>.<br><br>

	<p>The authors assume that the reader has some experience at creating maps for Quake2. This is not meant to be a primer on map editing, and we assume that the reader has prior knowledge of why reducing polygon counts is important. For basic information on creating Quake2 maps and map-related issues, read through the <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/42">Tutorials</a>, <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/21">Entity Properties</a>, and <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/17">FAQ</a> sections at Rust. <br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>

	<a name="examples"></a><b>Example maps</b><br>
	<p>This tutorial is accompanied by an example map that demonstrates most of the techniques mentioned here. To get the most out of this tutorial you should print this document and refer to it as you navigate through the rooms in the examples. The example map is available <a href="/content/quake2/tutorials/poly_count/poly_count.zip">here</a>. Two files are included - a standard .map file that you can import into most Quake2 editors, and a compiled bsp. Unzip tricks.zip to your quake2\baseq2\maps directory. To see the results achieved by the methods used in the examples, you should run the map with <b>r_speeds 1</b> and, if available to you, <b>gl_showtris 1</b>. Either start the map with a command line similar to:<br><br>

	<b>\quake2\quake2.exe +set r_speeds 1 +set gl_showtris 1 +map tricks</b><br><br>
 
	or start Quake2, bring up the console(press the '~' key), and type:<br><br>
   
	<b>r_speeds 1;gl_showtris 1;map tricks</b><br><br>

	<b>NOTE:</b> All of the example maps are very simple, and so the polygon counts are reasonably low with or without the methods described in this tutorial. Likewise, the reductions in polygon counts achieved by the methods described here are not very significant in the context of the examples. However, these methods <b>will</b> produce significant performance increases when used together in a large, detailed map.<br><br>
    
	<p>GL_Showtris draws white lines around all of the polygons in view of the game engine. This allows you to see how your brushes are broken up in a level, and also shows you what polygons the engine sees that you might have thought were sufficiently isolated that they would not be in view. If you have a 3dfx card, you will first need to download the <b>Mesa OpenGL drivers</b> from <a href="http://www.geocities.com/SiliconValley/Lakes/7220/mesa.html">Phil Frisbie's Programming Page</a>. These drivers will allow you to use the Default OpenGL video mode with your 3dfx card, which in turn allows you to use gl_showtris. Framerates will be only slightly slower than with the normal 3dfx setting.<br><br>


	<br><br><center><img src="/content/quake2/tutorials/poly_count/poly_count1.jpg"><br>Screenshot from a level you're probably familiar with, with gl_showtris turned on.</center><br><br>
    
	<p>R_Speeds displays several numbers of interest to map authors. The format of this report is dependent on what type of rendering you are using. With software rendering, r_speeds will display something like:<br><br>
    
        <b>33 ms 250/220/30
        poly 0 surf</b><br><br>
    
	The first number indicates the time, in milliseconds, required for one game cycle. Your framerate in frames/sec is 1000 divided by this number. The second number indicates how many polygons are in view, the third number shows how many polygons are drawn, and the fourth entry is the number of polygons in view but not drawn. For our purposes, the <b>second</b> number (polygons in view) is what we are trying to reduce.<br><br>

	With 3D accelerators, the r_speeds display will look something like:<br><br>
    
        <p><b>250 wpoly 450 epoly 3 tex 2 lmaps</b><br><br>

	&quot;wpoly&quot; is the number of world polygons in view and &quot;epoly&quot; is the number of entity polygons. Although you also need to monitor &quot;epoly&quot;, this tutorial concentrates on the <b>wpoly</b>entry.<br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>

	<a name="tricks"></a><h3>The Tricks</h3><br>

<a name="cut1024"></a><b>Awareness of qbsp3's default cuts</b><br>The original id-supplied qbsp3 (and most other qbsp3's) initially divides your map into 1024x1024x8192 sections. This procedure can produce unwanted brush cuts unless you arrange your map to minimize these effects. Steven Boswell has produced a version of qbsp3 which does <b>not</b> divide your map up in this way (available <a href="http://yyz.com/~whatis/Quake2/bspvis.html">here</a>), but this can often produce &quot;Subdivide face: didn't split the polygon&quot; errors. In the first room of the example map, the inside face of the wall to the player's left is at x=-16. This causes qbsp3 to break the 4 adjoining surfaces (floor, ceiling, and adjacent walls) along the line x=0. <b><i>Any brush which intersects a line at x or y equal to a multiple of 1024 will be divided in this way</i></b>. (Since the sections used are 8192 units tall, and the maximum extents of a map are +/-4096 units in any direction, you don't have to worry about these cuts on the z axis.) The solution here is obvious: move the entire room (or only this one wall) 16 units in the +x direction, and these cuts are no longer made (Actually they are made, but no longer result in additional polygons). Of course if your room is larger than 1024 units in either the x or y direction, at least one of these cuts will still be made. However, you can minimize the effects of these cuts by careful arrangement of your brushes. For example, if you have a crate with one face at x=1022, move it over 2 units so that this face is at x=1024. This method can very easily decrease your polygon count by 50 or more in a room with many details.<br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>

	 <p><a name="func_wall"></a><b>Alternative uses of func_wall</b><br> 
	 The second set of examples shows a room with 6 columns that span from floor to ceiling. The intersection of the columns with the horizontal floor and ceiling surfaces causes the horizontal faces to be broken up more than they would be if the columns were not present. In the next room, these columns are made into a func_wall. Since entities (including func_walls) do not influence the way qbsp3 breaks up your world brushes, the floor and ceiling are partitioned as they would be if the columns were not present at all.<br><br>

	 There are several limitations to using this method:
	 <ol>
		<li>The lighting quality of your func_wall will usually not be as good (though it is hard to see a difference in the example). Extra effort would usually be required to correct this.
		<li>Entities do not block light or, put another way, cast shadows. You can see this effect in the screenshots from the example map below.</li>
		<li>You cannot have more than 256 total models in any one map, and each func_wall counts against the total. If you exceed this limitation, you will get a game-crashing Index Overflow error. For more information on this subject, see <a href="http://mapspy.gamedesign.net/eio.html">this tutorial</a>. You <b>can</b> include multiple non-contiguous brushes in the same func_wall (as has been done in the example), <b>but:</b>
		<li>You should never allow a func_wall to span across areas that are not seen by the engine at the same time. For example, it might be tempting to include many brushes throughout your map into the same func_wall, like on opposite sides of an areaportal, to prevent Index Overflow errors. However, this practice will at a minimum cause visual errors in your func_walls.
		<li>You should <i>never</i> make a wall/floor/ceiling which &quot;touches&quot; the void an entity; otherwise, your map will leak!
	 </ol>
	 <br><br>



        <center><img src="/content/quake2/tutorials/poly_count/poly_count2.jpg"><br>Normal brushes used for columns</center><br><br>
           
        <center><img src="/content/quake2/tutorials/poly_count/poly_count3.jpg"><br>Columns are a func_wall. Note the lack of shadows.</center><br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>

	<p><a name="embedlites"></a><b>Embedded light fixtures</b><br>
	<p>It's very easy to slap several of the 16x16 light fixture textures against your ceiling, walls, or floors to light a room. However, the 4 edges adjacent to the lit surface are visible, and will be divided up into 2 polygons each. You can embed your light fixtures in your ceiling/walls/floor such that the sides of the fixture aren't visible. This method generally results in a decrease of 8 polygons/fixture. Of course, this method is quite a bit more trouble, as you will also have to divide your ceiling/walls/floor up carefully. For best results, you could place the fixtures such that the edges are all at multiples of the texture dimensions, as well as making sure they line up with each other. This not only allows you to forego texture alignment hassles, but will also produce fewer brush cuts than if your fixtures are placed at random locations. <p>This method is applicable to other textures, of course. For example, &quot;exit&quot; signs, etc. and texture blending can use this method to decrease the number of brush cuts.<br><br>
    
	If you <b>want</b> the edges of the fixtures visible, such that it is apparent that the fixtures stand out from the mounting surface, consider moving the fixtures 1 unit from the surface such that the two brushes don't touch. (This technique is described <a href="/node/53/#gaps">below</a>). This method will not be as effective as embedding the fixtures, but <b>will</b>produce a lower polygon count than placing the fixtures flush against your ceiling/walls/floor.<br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>

	<a name="donut"></a><b>Doughnut hallway</b><br> 
	The doughnut hallway is the only method presented here that significantly alters the appearance of your map. If you have adjacent rooms connected by a short hallway, but don't want to separate the rooms with a door and func_areaportal, the doughnut hallway is ideal for blocking visibility from one room to the next. This method was used extensively in Quake1, since it lacked func_areaportals to block vis from one room to another. It's popularly known as the &quot;Donut Trick&quot;, and is as viable a technique for Quake2 as it was for Quake1.<br><br>

	The key to the success of the doughnut hallway is to size the vis-blocking wall such that the player (and the engine) cannot see from one hallway entrance to the opposite side of the wall. This wall should extend from the floor to the ceiling, and both the floor and ceiling of the hallway must be constructed with solid non-transparent textures. Naturally, making this wall an entity in whole or in part would defeat efforts at blocking polygons from view.<br><br>

	<center><img src="/content/quake2/tutorials/poly_count/poly_count4.gif"><br>Doughnut hallway</center><br><br>
    
	<p>A similar result can be achieved in a large open space if a huge monolithic structure is placed so it blocks the view from one side of the area to the other. Naturally this would require experimentation to get just right for each specific open area where you might want to use this method. Of course you may only make things worse if your vis-blocking structure is not quite so monolithic, and its own polys added to the mix outnumbers the polys that it blocks.<br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>

	<a name="evil"></a><b>Brush subtraction is evil</b><br>
	Well, OK, not really. But brush subtraction (or carving, hollowing, CSG subtraction) is generally the most abused feature of any map editor. The time savings you achieve with brush subtraction are very often more than offset by the time required to fix brush subtraction errors. At best what you're liable to get is a mess that is painful to look at and read in your editor. The example map shows a set of 3 arched doorways constructed with brush subtraction. In this case, small roundoff errors have resulted in several very noticeable gaps between brushes, and higher than necessary polygon counts. In the next room, the identical arched doorways have been created by manual placement of the brushes that form the arches. <b>NOTE:</b> Even if your editor does not have roundoff problems and you very carefully perform the subtraction operation with the cutting brush aligned to the grid and do everything else correctly, this example shows an obvious problem with using brush subtraction with a non-square cutting brush on a large wall - say you've constructed your arches, but then decide you want to move one arch over by 4 units - good luck. Well, take the opportunity then to pat yourself on the back for all the time you saved performing brush subtraction in the first place, because you're going to be using that time now.<br><br>
   
	<center><img src="/content/quake2/tutorials/poly_count/poly_count5.gif"></center><br><br>

	<p>If you insist on using brush subtraction for some odd masochistic reason for this type of operation, you will do <b>much less</b> damage in this case by isolating the area that is affected to the smallest possible one.<br><br>

	<center><img border="0" width="450"  src="/content/quake2/tutorials/poly_count/poly_count6.gif"></center><br><br>

	<p>In this example, the cylindrical top of the arch is subtracted from the smallest possible cube. The result of this operation is then copied to the other arch locations. This results in much simpler (and more importantly much easier to edit) brushes.<br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>
    
	<p><br><hr color=black noshade width=75%><br><p>

	<a name="gaps"></a><b>Gaps between brushes</b><br>
	Brushes will <b>always</b> be split where they intersect other brushes. To get rid of this effect, you can move small objects away from the other brush by 1 unit so that they do not touch. If this trick is used with discretion this small gap will not be visible to the player. This technique is typically best used in areas where the player isn't going to notice differences in shadowing -- such as the ceiling or on the upper edges of walls. You can also use this technique on non-breakable windows to lower your polygon count (it won't help to use this method on breakable windows -- since they are entities they will not break up the window frame anyway). The lighting will be fine, but you should use this method with discretion if the player can get very close to the window - the gap will almost always be visible from close range. Floors are typically the worst place to try to implement this feature (as shown below), unless they're in a very well lit area with offsetting lights where shadows won't be dramatic.<br><br>

	<center><img src="/content/quake2/tutorials/poly_count/poly_count7.jpg"><br>The crate in this example is 1 unit from the floor. Notice that the resulting shadows give the crate the appearance of being suspended several units above the floor.</center><br><br>
         
	<p>In the example map, the roof of the test room is open to the sky with many criss-crossing roof beams. These beams result in the faces making up the walls of the room being broken up much more than they would be if the beams were not present. In the following room, these beams have been shortened by 2 units such that neither end touches a wall. Even in this relatively simple room, this method results in a polygon reduction of about 30. The lighting in this room is such that the gap is not visible at all, so there is no visual problem in this case.<br><br>

	<center><img src="/content/quake2/tutorials/poly_count/poly_count8.jpg"><br>Beams touch the wall. Notice how the wall is split up by qbsp3</center><br><br>

	<center><img src="/content/quake2/tutorials/poly_count/poly_count9.jpg"><br>Ends of beams are 1 unit away from wall</center><br><br>
	
	<p><b>NOTE: This method should </b><i>never</i> be used on brushes that would otherwise block visibility from one area to another. For example, creating 1-unit gaps at the tops and bottoms of vis-blocking walls is a pretty silly thing to do.</b><br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>
    
	<a name="detail"></a><b>Detail brushes</b><br>
	You have probably seen warnings that the use of detail brushes will result in higher r_speeds. While <b><i>sometimes</i></b> true, the only way to know for certain whether the use of detail brushes will increase, decrease, or have no effect on r_speeds is to test it and measure the results. Detail brushes are usually recommended as a method for speeding up a lengthy vis, since they are not included in vis calculations. Qbsp3 will <b>not</b> use the planes of detail brushes to split your map, so <b><i>sometimes</i></b> the use of detail brushes will <b><i>decrease</i></b> the number of polygons in your map - this is what we want.<br><br>

	Detail brushes can generally safely be used on any object which does little or nothing to block visibility. If restricted to small objects which don't block the view of other objects, the use of detail brushes <b><i>usually</i></b> does not cause an increase in r_speeds. And in fact, in the 3rd roof beam example detail brushes actually <b>improve</b> r_speeds since the planes of the beams are no longer used to split up the map.<br><br>
	
	<center><img src="/content/quake2/tutorials/poly_count/poly_count10.jpg"><br>Beams are detail brushes. Contrast this screenshot with those above. Note that the planes of the beams are no longer selected as bsp splitters.</center><br><br>

	<p><b>NOTE: Detail brushes are designed to be used on brushes that do not block the player's view. You should <i>never</i> make a wall/floor/ceiling which &quot;touches&quot; the void a detail brush; otherwise, your map will leak!</b><br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>

	<p><a name="miter"></a><b>Mitered corners</b><br>
	Some may think this method is generally best reserved for times when you are truly desperate to lower your polygon counts. While the return on your investment is usually small, and can be quite a bit of trouble (particularly if your editor does not support vertex manipulation - a glaring omission), in general this can be a good technique on general principles. In the example map, one room contains two open-ended concrete boxes that are constructed from normal cube brushes. The next room shows these same concrete boxes constructed with mitered brushes. This technique will generally result in lower polygon counts in any location where the <b>outside</b> corner of the intersection of two brushes is visible.<br><br>

	<center><img src="/content/quake2/tutorials/poly_count/poly_count11.jpg"><br>Exploded view of mitered box</center><br><br>
            
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>

	<p><a name="textures"><b>Let the textures do the work</b><br>
	This is primarily intended for all of you engineers and architects and wannabe's out there - you know who we're talking about. It may be very tempting to try to mimic a real environment with brushes as much as possible, down to the smallest details. However, this practice will very often produce a completely beautiful, but unplayable map. If architectural details aren't critical to gameplay, consider simplifying your level by <b>simulating details with textures</b>. If a stock-Q2 texture does not exist that will accomplish what you want, make your own! There are several excellent tools available for creating custom textures (<a href="http://www.telefragged.com/wally/">Wally</a>, for example).<br><br>

	<center><img src="/content/quake2/tutorials/poly_count/poly_count12.jpg"><br>&quot;Correct&quot; Wide-flange beams</center><br><br>

	<center><img src="/content/quake2/tutorials/poly_count/poly_count13.jpg"><br>Beams simulated with custom texture</center><br><br>
	
	
	<p>Here's a sobering thought for those wishing to include custom textures (or sounds, models or custom anything for that matter) with multiplayer maps: An online server will seldom run such a map, for the simple reason that it is unlikely that all players connecting to that server will have the necessary files themselves. Other players who make their own maps as you do will have the Quake2 textures extracted for compiling purposes, and they may be loath to &quot;pollute&quot; their textures directory with new ones which will only make selecting textures for their own maps confusing. Additionally, if such a map has to be run from a custom &quot;game&quot; directory, it would be even more unlikely an online server would run it, unless your map is part of a mod which the server is running. Keep in mind also that it is not possible to run 2 &quot;game&quot; directories simultaneously, so maps run from custom directories cannot be used with bots. Custom files are probably best suited to single-player maps.<br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>

	<p><a name="threesides"></a><b>3 Sides rather than 4</b><br>
	This one will seem obvious after you try it. If you have four-sided brushes in a spot where the player cannot get to the far side, use a 3-sided brush instead. Depending on the architecture of your map, this simple change can result in a significant decrease in your polygon count. In the example map, two barred windows are placed in the two test rooms. In the first room, the bars are regular square brushes; in the second room, triangular brushes are used with the point of the triangle facing away from the player. Even up close it is hard to tell that these brushes aren't 4-sided, but the peak polygon count drops by more than 50 with this simple change. This method will likely produce similar results with jail cells and any type of grate.<br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>

	<p><a name="opaque"><b>Transparent vs. opaque water</b><br>
	Transparent water is cool, but of course does nothing to block visibility. If you have water brushes in a high-poly area of your map, consider turning off the TRANS33 or TRANS66 flags, which will make the water opaque (or use a non-transparent water texture). The water is still transparent on the inside, but will act like a normal solid brush from the outside and block visibility. Yeah, you say, &quot;but I like my transparent water.&quot; Before you dismiss this idea entirely check out the example map with r_speeds turned on (or the screenshots below, taken from another map) and note the difference.<br><br>


	<center><img src="/content/quake2/tutorials/poly_count/poly_count14.jpg"><br>Transparent water. Notice that the engine sees the bottom of the pool.</center><br><br>

	<center><img src="/content/quake2/tutorials/poly_count/poly_count15.jpg"><br>Opaque water</center><br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>

	<p><a name="nodraw"></a><b>No draw = No polys</b><br>
	This may be the most obvious one of all (so why was it the last method we thought of?). Environment (or sky) textures do not contribute towards the polygon count. You can replace brushes that do little to contribute to the look of a room with sky brushes to lower your polygon count. In the example map, a small section of the ceiling has been replaced with a sky brush, resulting in lowering the world polygon count by 4. Of course, the more complex your  ceiling is, the greater will be the savings realized. Taken to its logical conclusion, here's a screenshot from our ultimate deathmatch map:<br><br>

	<center><img src="/content/quake2/tutorials/poly_count/poly_count16.jpg"><br>Not much to look at, but check out the r_speeds! Yeah, OK, it's a dumb idea. Shut up.</center><br><br>

	<p><b>NOTE: This method is best used on brushes which do not face other parts of a map. If a sky brush is located between two map areas, the player may sometimes see through the brushes of another area and into that area. These visual errors are sometimes hard to fix. For more information on the &quot;sky bug&quot;, see the <a href="http://www.gamedesign.net/quake2/q2faq.shtml">FAQ</a> at Rust.</b><br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>

	<p><a name="fooled_you"></a><b>Fast framerates for large, detailed areas</b><br>
	Ha! Made you look! Sorry, but there's only so much you can do to make your map play well. Large areas with a lot of detail just don't work with Quake2.<br><br>
<a href="/node/53/#TOC">Back To Table Of Contents</a><br>

	<p><br><hr color=black noshade width=75%><br><p>


	<p><a name="summary"></a><b>Putting it all together</b><br>
	The following screenshots show the results of using several of the techniques described here in a single room. Your own results will vary, of course, but it should be apparent by now that by making prudent, well-thought-out changes to your map you may be able to significantly improve it's performance.<br><br>
   
	<center><img src="/content/quake2/tutorials/poly_count/poly_count17.jpg"><br>a. Room has southwest corner at -16,-16<br>b. Roof beams intersect walls<br>c. Light fixtures flush against walls<br>d. Hideous, evil brush subtraction used in floor</center><br><br>

	<center><img src="/content/quake2/tutorials/poly_count/poly_count18.jpg"><br>a. Room has southwest corner at 0, 0<br>b. Roof beams are detail brushes and do not touch walls<br>c. Light fixtures embedded in walls<br>d. Manually placed triangular brushes for the cylindrical part of holes in floor</center><br><br>

	<p>The authors consider this tutorial a work in progress, and are always open to new ideas which should be included here. If you find a technique not outlined here that works, by all means contact us and clue us in!<br><br>

</ul><h1 id="235" name="235" class="book-h1">Sunlight - Part 1</h1><ul><h1>Where did that <font color="orange">SUN</font> go?<br>(or what you will)</H1>
      
<H2>CONTENTS</h2>

<h3>Introduction</h3>
<ol>
<li>
<a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/235#intro">Just the facts, ma'am.</a>
</li>
</ol>
<h3>You're not the only one staring at the _sun.</h3>
<ol>
<li>
<a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/235#what">What does it do?</a>
</li>
<li>
<a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/235#sowhat">Okay, it's a sun.  So what?</a>
</li>
</ol>
<h3>That's neat.  How do I use it?</h3>
<ol>
<li>
<a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/235#_sun">From the beginning (_sun)</a>
</li>
<li>
<a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/235#_sun_light">Shedding a little light on the subject (_sun_light</a>
</li>
<li>
<a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/235#_sun_ambient">How about the shadows? (_sun_ambient)</a>
</li>
<li>
<a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/235#_sun_color">What color is the sun, anyway? (_sun_color)</a>
</li>
</ol>
<h3>No fluff</h3>
<ol>
<li>
<a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/235#sun">Explain it non-verbosely</a>                 </li>
</ol>
<h3>Summary</h3>
<ol>
<li>
<a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/235#example">What should my worldspawn look like?</a>
</li>
<li>
<a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/235#comments">Conclusion</a>
</li>
</ol>
<h3><font color="red">C</font><font color="orange">o</font><font color="yellow">l</font><font color="green">o</font><font color="blue">r</font><font color="purple">e</font><font color="violet">d</font> lights are neat, but...</h3>
<ol>
<li>
<a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/235#nocolor">...how about we not use it               </a>
</li>
</ol>

<h1><a name="intro">Introduction</a></h1>
<p>
For those of you who are using Geoffrey DeWan's version of Qrad3 version 1.03, this is going to be a real treat. If you have read the text file included with the executable, you may have noticed the mention of a sun feature. For whatever reason, everyone I have spoken to has been reluctant to try it.
</p>
<p>
Not only is the sun feature incredibly easy to use, but it also provides a lot more versatility than straight environmental lighting.  Plus, it looks a whole lot better. This tutorial is dedicated to helping you get started with using the sun (you'll never turn back).  It also mentions in passing another useful feature included, the -nocolor ption.
<br><br>
</p>
<h2><a name="what">What exactly does the _sun feature do?</a></h2>
<p>
As you may be aware, the ability to use environment maps is a welcome improvement that has accompanied the release of Quake2. The Environment maps are pretty gosh darned cool, but outdoor lighting is only so-so.
</p>
<p>
The _sun feature allows you to chose a direction for the sun to shine, and it lets you control diffuse lighting, highlight intensity, and sunlight color.&nbsp; Also, from what I have noticed areas lit by large amounts of sky can qrad much faster          when the area is lit by the sun instead of the sky         surface. In the test map I created, qrad took 1016        seconds when the sun was not used. The same map took 509 seconds with the sun activated.
</p>
<p>
If everything is properly entered, qrad should recognize your sun without having to use command lines.&nbsp; This was what confused me at first, since you activate your sun in your worldspawn entity, and not at the command line. In actuality, this makes things a lot easier. 
</p>
<h2>
<a name="sowhat">So what's the big deal?</a></h2>
<p>
<a href="http://www.gamedesign.net/miniwood/tutorials/images/nosun_l.jpg"><img src="http://www.gamedesign.net/miniwood/tutorials/images/nosun.jpg" height="120" width="160" align="left"></a>As you can see, outside areas look really nice, but the light looks like it is coming from everywhere. It also has a really ugly orange hue. That's not the most glaring of the things it lacks, there are no shadows!!! Well, okay, there are shadows, but they are not very well defined. The problem is, how do we get our outdoor lighting to look as cool as our indoor lighting without using a gazillion light entities and spending a couple years putting them in place? It's easier than you thought.
</p>
<p>
<a href="http://www.gamedesign.net/miniwood/tutorials/images/sun_l.jpg"><img src="http://www.gamedesign.net/miniwood/tutorials/images/sun.jpg" height="120" width="160" align="right"></a>
With a few alterations and a couple entities, a          drab outdoor scene can take on a whole lot of life and personality. There are now clearly defined shadows AND highlights. With the sun activated, outdoor scenes begin to really look like they are outside. What's better, you have complete control over the color that the sun emits.
<br><br><br><br>
</p>
<h1>How do I do it?</h1>
<h2><a name="_sun">You start with the _sun.</a></h2>
<p>
The first thing you need to do is to give the sun a vector. The qrad program looks for an entity that is targeted to an info_null. First, place a light anywhere inside your level (don't put it outside the level, or else you will create a leak). Target the light to the info_null that you are about to create. Now create your info_null and give it the appropriate targetname. The position of the info_null relative to the light that targets it will tell qrad the angle that the sun shines.
</p>
<p>
Add the _sun key to your worldspawn options (the same place you use to set your map's entering message). Give it a key value that is the same as your info_null's targetname. Here's an example from the .map file I used for the screenshots above.
</p>
<div class="bodytext">
<font face="Lucida Console">
"classname"&nbsp;&nbsp;"worldspawn"<br>
"sky"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"unit1_"<br>
"message"&nbsp;&nbsp;&nbsp;&nbsp;"Map With Sun"<br>
"_sun"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"star"
</font>
</div>
<div class="bodytext">
<font face="Lucida Console">
"classname"&nbsp;&nbsp;"light"<br>
"target"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"star"<br>
"origin"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"220 -232 272"
</font>
</div>
<div class="bodytext">
<font face="Lucida Console">
"classname"&nbsp;&nbsp;"info_null"<br>
"targetname"&nbsp;"star"<br>
"origin"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"192 -208 224"
</font>
</div>
<h5>For those of you that are confused about the Worldspawn entity. It is the place where you set all of the options such as sky, gravity, and map name. You simply add _sun to the keys.</h5>
<p>
If you have any brush faces that are on the same plane as a lit sky face, AND they faces have an unobstructed line of sight to each other, then you will get unexpected and undesirable effects. Make sure that your sky and non-sky faces are either not on the same plane, or not visible to each other. Failure to do so may cause sunlight to appear where it doesn't belong.
</p>
<p>
The final thing you need to do to make sure that your sun is working right is to give all of your sky textures a light value. Apply a light value (any light value) to all of your texture surfaces with the "sky" flag. If you do not do this, your sun may not work right. 
</p>

<h3><a name="_sun_light">Light me up!</a></h3>
<p>
Now that your sun is in place, the hard part is done. All that is left is to set the light values. The first thing we shall do is to set the highlight value. This is the value of any surface that has a clear line of sight to the sun. Add the _sun_light key to your worldspawn entity, and give it a value.  I have noticed that lower values tend to be quite dark. The screenshot above has a _sun_light value of 800.
</p>
<p>
How does this work? Well, qrad calculates the x y and z angles of the sun's direction, then checks all surfaces. From each surface, it checks if the sun is viewable at the opposite angle. In other words, the opposite angle of the sun's direction is calculated, the program checks each surface          at that angle.&nbsp; If it encounters a lit sky, then it is not in the shadow. If it encounters a solid without the sky flag, then it is in the shade.
</p>
<h3><a name="_sun_ambient">How about the shade?</a></h3>
<p>
With highlights, there must be shadows. If the shadows were completely unlit, it would be too harsh. After all, the diffuse light of a sky emits some light, even if it is not as bright as the sun. The _sun_ambient option allows you to fill your shadows. A value of 50-200 works best for this.
</p>
<p>
For a good example of how diffuse lighting works, take a look at the shadows outside on a sunny day. If you try to emulate this, you can't go wrong.
</p>
<h3><a name="_sun_color">Setting the sun's color</a></h3>
<p>
To give you absolute control over your sunlight, Geoffrey DeWan included the _sun_color option. This allows you to make your sun project any color without doing any screwy texture swapping.
</p>
<p>
Simply add the _sun_color key to your worldspawn and give it a color value just like you would to a light entity (I find that 1 1 .85 works good for a medium yellow light).  For a review of what your worldspawn entity should look like now, see the <a href="#example">example</a>.
</p>
<h2>In as few words possible</h2>

<h3><a name="sun">Using the sun feature</a></h3>
<p>
First, create a light and target it to an info_null. This will be your sun's angle.
</p>
<p>
Next, add the _sun key to your worldspawn, and enter the targetname of the info_null.
</p>
<p>
Make sure all of your sky textures have the light flag checked and a light value.
</p>
<p>
Add the _sun_light value to your worldspawn, and give it a light value.
</p>
<p>
Add the _sun_ambient value to your worldspawn, and give it a light value.
</p>
<p>
Add a _sun_color value to your worldspawn, and give it a value.
</p>
<p>
Run qrad3 as you normally would (make sure it's the one by Geoffry DeWan, version 1.03, or ArghRad 1.0).
</p>
<h3><a name="comments">Some closing thoughts</a></h3>
<p>
Version 1.02 of DeWan's qrad3 used the sun, sun_light, sun_ambient, and sun_color keys. This was annoying, because they would pop up a message "sun is not a valid field" when you would run the game.  Now that he has added an underscore before the keys, the error is gone, and everything          is peachy keen.</p>
<p>
The sun feature is incredibly useful. It is a definite improvement over the original qrad3 code. It is by the will of Id software that we have the source code available to improve an already great game, and by the hard work of the fans that the tools are there. Everyone should show their          appreciation of the spirit of free information by not plagiarizing or pirating software.
</p>
<div class="bodytext">
<a name="example"></A>Your worldspawn should look something like this now:
</div>
<BR>
<div class="bodytext">
<font face="Lucida Console">
"classname"&nbsp;&nbsp;&nbsp;"worldspawn"<br>
"sky"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"unit1_"<br>
"message"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Map With Sun"<br>
"_sun"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"star" <font face="Times New Roman" size="2" color="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use the targetname of your info_null</font><br>
"_sun_light"&nbsp;&nbsp;"800" <font face="Times New Roman" size="2" color="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The highlight brightness</font><br>
"_sun_ambient""100" <font face="Times New Roman" size="2" color="red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The shadow depth</font><br>
"_sun_color"&nbsp;&nbsp;"1 1 .85" <font face="Times New Roman" size="2" color="red">&nbsp;&nbsp;&nbsp;&nbsp;Same as if it were a light</font>
</font>
</div>

<h2>
<a name="nocolor">How to qrad without color</A></h2>
<p>
If you have ever compiled a level with colored or texture lighting only to find out later that it looks a lot better without color, you can easily recompile it without having to change all of your entities and messing with your surface properties. All you have to do is add -nocolor to your          qrad command line. For example, if you normally compile with this command line:
</p>
<div class="bodytext">
qrad3 -extra -bounce 40 [filename]
</div>
<p>
You just add -noclor to it and you're good to go.
</p>
<div class="bodytext">
qrad3 -extra -bounce 40 -nocolor [filename]
</div>
<p>
The light intensities may not be the same as it was when you had color, but it shouldn't change too much. Here's a little clip from the text file included with version 1.03.
</p>
<BLOCKQUOTE><h5>
Disables colored lighting.  All colored light is computed as normal, but final lighting results are converted to grayscale according to the formula that is used to compute the Y signal of a color television broadcast (which is what a black & white television displays). The colors are not weighted equally (0.299Red + 0.587Green + 0.144Blue).         A green of the same intensity as a blue will convert to a brighter lightmap than the blue. Red falls in the middle. 
</h5></BLOCKQUOTE>
<br><br><br><br><br><br>
<center>
This was written by Michael N. Meadows, AKA Ryche. My sources were as follows: Me, the text file included with gddqrad3 version 1.03, and a lot of hard work. Feel free to quote me. Feel free to steal my words and claim them as your own. Your conscience is all that stands in your way. Most important of all, however, is that you have fun.
</center></ul><h1 id="237" name="237" class="book-h1">Sunlight - Part 2</h1><ul><h1>Sun part II</h1>

<p>I swear, these guys are worse than Intel! Just when you think you have one radiosity program nabbed, someone goes and releases another.
</p>
<p>
Actually, thanks goes to Tim Wright (Argh!) for making so many improvements. And thanks goes to Geoffry DeWan for getting the ball rolling. If you don't already have ArghRad, download it now!
<BR><BR>
<A HREF="http://www.planetquake.com/arghrad">Arghrad Homepage</A>
</p>
<h2>Contents</h2>
      
<h3>Why should I use something new...</h3>
<ol>
<li>
<a href=node/237/#why>...when what I have works fine?            </a>
</li>
</ol>

<h3>What's new?</h3>
<ol>
<li>
<a href=node/237/#four>Did you say FOUR suns?</a>
</li>
<li>
<a href=node/237/#shadow>Ambient shadow coloring</a>
</li>
<li>
<a href=node/237/#diffusion>Shadow diffusuion</a>
</li>
<li>
<a href=node/237/#alternate>Alternate aiming techniques</a>
</li>
</ol>
<hr width=100%>
<br><br>

<h3>Why should I use something new...</h3>

<div class="bodytext">
<a name=why>...when what I have works fine?</a>
</div>
<p>
Progress.
</p>
<p>
For real, though, ArghRad is like a version update of gddqrad3. It fixes some of limitations of gdqrad3 that caused the shadows caused by sunlight to look blocky, and made some definite improvements (like ambient color control and multiple suns. It does all of this WITHOUT sacrificing support of gddqrad3 and qrad3.
</p>

<h3>What's new?</h3>
<p>
Here are all of the new keys available for the sun. If you're hungry for more, go to the online manual         at the Arghrad page.
</p>

<h5>
&quot;_sun_angle&quot;<br>
&quot;_sun_mangle&quot;<br>
&quot;_sun_vector&quot;<br>
&quot;_sun_diffuse&quot;<br>
&quot;_sun_diffade&quot;<br>
&quot;_sun_difwait&quot;
</h5>
<p>
"_sun_angle" and "_sun_mangle" are aliases for the same function, as are "_sun_fade" and "_sun_wait", but that still leaves us with four new options, plus the ability to use up to four suns.
</p>
<div class="bodytext">
<a name=four>Did you say FOUR suns?</a>
</div>
<p>
Yes! You can now use up to four suns in your maps, each with their own color and angle. To use multiple suns, you would simply define them as you normally do, except you substitute "_sun2" "_sun3" and "_sun4" for "_sun" when entering information on your second, third, and fourth suns.
</p>
<p>
You can use multiple suns on all of the _sun keys except "_sun_ambient".
</p>
<div class="bodytext">
<a name=shadow>Ambient shadow coloring</a>
</div>
<p>
You can color your ambient shadows now (the part that can't see the sun, but can see the sky). If you define a straight light value instead of a color value, the shadow color will default          to the average of all of your suns' colors. To define the color of the shadow, simply enter three values after the "_sun_ambient" key instead of one.
</p>
<h5>"_sun_ambient" "[red] [green] [blue]"</h5>
<p>
Each value represents the brightness of each individual color, so if the value entered were 120 150 50, the shadow color would have a minimum red brightness of 120, a minimum green brightness         of 150, and a minimum blue brightness of 50.    </p>
<div class="bodytext">
<a name=diffusion>Shadow diffusion</a>
</div>
<p>
This feature is so freakin' cool, I can't contain myself! What shadow diffusion does is provide an buffer of hazy shadow between the shade and the direct sunlight. This can make your shadows look much smoother less harsh. To define the diffusion, simply enter a value less than the highlight value,
and greater than the shadow value.
</p>
<h5>
"_sun_diffuse"   "[value]"
</h5>
<p>
To control the fade distance of the diffusion, Tim Wright has added the _sun_diffade and _sun_difwait keys. A value less than 1 will cause the diffusion to fade out slower, while a value greater than 1 will make it fade faster. Be aware, however, that if you use a large value, you may need to reduce         your -chopsky value (or else you will get a chunky shadow). This defaults to a value of 1, and any value entered will scale relative to the default. For example, if you entered a value of .5, the diffusion would fade twice as rapidly as it          did at 1.
</p>
<h5>
"_sun_diffade"   "[value]"
</h5>
<h5>
"_sun_difwait"   "[value]"
</h5>
<div class="bodytext">
<a name=alternate>Alternate aiming techniques</A>
</div>
<p>
There are now two additional ways to aim your sun (both of which you can substitute for the "_sun" "targetname" method. The first method is angle aiming. This uses pitch and yaw to aim. This method is the same as is used to aim info_player_intermission minus the roll.
</p>
<p>
The yaw is the position on the z axis. You aim yaw the same way you aim a door, or a player facing, with 0 pointing east, and moving counter-clockwise. Pitch is the angle on the horizon. Pitch values range from negative 90 to positive 90. -90 points straight down, and 90 points straight up.
</p>
<h5>
"_sun_angle"    "[yaw] [pitch]"
</h5>
<h5>
"_sun_mangle"    "[yaw] [pitch]"
</h5>
<p>
The second method is vector aiming. By using vector         aiming, you enter a vector coordinate into the value field, and ArghRad will calculate the angle from the origin (0 0 0) to the vector (x y z) coordinates you entered. The resulting angle         will be the sun's angle.
</p>
<h5>
"_sun_vector"    "[x] [y] [z]"
</h5>
<br><br><br><br><br>
<center>      
This was written by Michael N. Meadows, AKA Ryche AKA eg0. My sources were as follows: Me, the text file included with ArghRad 1.0, Tim Wright, and a lot of hard work. Feel free to quote me. Feel free to steal my words and claim them as your own. Your conscience is all that stands in your way. Most important of all, however, is that you have fun.</center></ul><h1 id="55" name="55" class="book-h1">Surface Properties and Content Properties</h1><ul><!--  converted 15/12/01 from old rust documents -->
<h2>Surface Properties and Content Properties</h2>
<blockquote>
		By Fishman
</blockquote><br><br>

 <p>One of the newest, coolest editing options in quake2 is the ability to set surface properties and content properties. They are:
    <ul type="square">
        <b>Surface Properties</b>
        <li>light
        <li>slick
        <li>sky
        <li>warp
        <li>trans33, trans66
        <li>flowing
        <li>nodraw
        <li>hint
        <li>skip
    </ul>
    <ul type="square">
        <b>Content Properties</b>
        <li>solid
        <li>window
        <li>aux
        <li>lava, slime, water
        <li>mist
        <li>player clip, monster clip
        <li>current_0, _90, _180, _270, _up, _down
        <li>origin
        <li>monster, corpse
        <li>detail
        <li>translucent
        <li>ladder
    </ul>
    </p>

<h3>Differences between a surface property and a content property.</h3>

<p>The main difference between surface and content properties is that <b>surface  properties</b> can be applied to any number of a brush's faces.  <b>Content  properties</b> must be the same on every face of a brush.<br><br>
For example, you could mark one brush face as light, or two face, or three, etc, but for a detail brush, every face must be marked as detail, or you will get an error when you compile the level (<b>Entity x, Brush x: mixed face contents</b>) Thanks <a href="mailto:autolycus@valvesoftware.net">autolycus</a> for the above info.
</p>

<h3>How to Set a Surface\Content Property</h3>

<p>In each editor setting surface properties are done differently.
    <ul type="square">
        
<li><b>In BSP:</b><br>
            Select the brush, press the '<b>S</b>' key, select the properties you want to set, then hit apply to brush, or apply to face. <br>&nbsp;

<li><b>In QERadiant & GTKRadiant:</b><br>
            Surface properties work the same in QERadient as in BSP. Select the brush, 
            press the '<b>S</b>' key, select the properties you want, then hit apply.
            <br>&nbsp;
       
 <li><b>In QOOLE:</b><br>
            Select the brush or surface and hit <b>alt-t</b>, select the property you 
            want, hit apply
            <br>&nbsp;
        
<li><b>In QuArK:</b><br>
            In QuArK you must select the brush and side you wish to add the surface 
            attribute to and then click (no flag). <br><br>
                    
<li><b>In WorldCraft 1.6:</b><br>
            Select the brush & Press Shift+A to call up the face properties window.<br><br>
        
<li><b>In DeathMatch Maker 2:</b><br>
            My pal <a href="mailto:DMM2Editor@aol.com">Richard Neff</a> has sent along this 
            <a href="/content/quake2/tutorials/surface/dmm2.zip">ScreenCam tutorial</a>(405 kb) on how to work with surface 
            properties and contents. So if your a DMM2 user then check em out.
            <br>&nbsp;
        
<li><b>In qED:</b><br><ol>
                <li>Select the brush from the level outline (tree view).
                <li>Select the "texture" tab from the properties notebook.
                <li>Right-click on the proper brush surface in the list or the top
                    &lt;brush&gt; line for all brush surfaces.
                <li>Select "surface attributes" from the pop-up menu that appears.
                <li>Put a check mark in the proper boxes and set the light value
                if necessary.
            </ol>&nbsp;<br>
        
<li><b>In BSP:</b><br>
            <ol>
                <li>Select the Brush
                <li>Hit the 'S' key
                <li>set the properties and remember to hit the 'apply to brush' button
            </ol>&nbsp;
        
<li><b>In Quest:</b><br>
            Select the face or brush, press <b>ALT-F</b>, select the properties
            you want to set, then hit <b>OK</b>. - thanks <a href="mailto:martin.fuchs@physik.fu-berlin.de">Martin Fuchs</a>
            <br>&nbsp;
    </ul>
    </p>

 <p>If there is an editor I missed (which I did) and you know how to use the surface properties then 
    please post on the <a href="http://forums.gamedesign.net/viewforum.php?f=14">RUST Q2 forum</a> and I will add it.
    </p>
    
<h3>What the Surface Properties/Contents Do</h3>

<ul type="square">
    <li><b>light</b><br>
        This means that the face will emit light the color of the texture. So if you 
        have a yellow texture emmiting light then the light will be yellow. This is 
        probably the most often used and useful surface property. To set the 
        brightness of the light you must enter the number of the brightness in the 
        value edit box that should appear on most editors' surface properties 
        windows'. This is a great alternative for creating your own light entities, 
        because it is much easier and provides more realistic lighting effects.<br>
        <br>
        The only thing that you should know is that sometimes, depending on the size 
        of the brush that will be emitting light, you will have to set the brightness
        of the light very bright. Sometimes as high as <b>10000</b> is needed.
        <br>&nbsp;
    <li><b>slick</b><br>
        Slick will make the selected surface slippery and the player will slide. Used
        in the id level cool1, the Cooling Station. There's an area where you jump on
        some crates and hop onto a large piston that takes you up to the next
        floor.  At the bottom around the piston there's a green slick area you can
        slide around in.
        <br>&nbsp;
    <li><b>warp</b><br>
        Makes the surface warp like water. Should be used when making water, forcefields, lava, etc.
        <br>&nbsp;
    <li><b>trans33, trans66</b><br>
        These make the selected surface transparent. 33 means 66 percent transparent, 
        66 means 33 percent transparent. So therefore trans33 is going to be more 
        transparent then trans66.<br>
        <br>
        You should also remember that <b>entities cannot be transparent</b>, so you 
        couldn't have a transparent func_water, or a transparent func_door, etc.
        <br>&nbsp;
    <li><b>flowing</b><br>
        flowing makes the surface look like it is moving. It is usually used along with 
        the <b>current_*</b> surface property to create the effect of a river flowing.<br>
        <br>
        It will move in the direction of the texture so if you wish it to flow in a 
        different direction then you need to <b>adjust the rotation of the texture</b>.
        <br>&nbsp;
    <li><b>nodraw</b><br>
        This is used for triggers and clip brushes. What it does is makes the selected
        surface invisible if it is a clip brush or a trigger such as a trigger_once 
        and a trigger_multiple.<br>
        <br>
        By default though, triggers are already set to not drawn.
        <br>&nbsp;
    <li><b>hint</b><br>
        A hint brush blocks vis from seeing into certain areas, thus decreasing frame 
        rate(which is a good thing) They are difficult to determine where to place though.
        There is a good <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/52">tutorial</a> 
        written by <a href="mailto:jcaesar@mediaone.net">Joel Caesar</a> on hint brushes 
        that will help you figure out how to use them.
        <br>&nbsp;
    <li><b>solid</b><br>
        Solid is the default for all brushes. Not real sure on why you would have to use it though.
        <br>&nbsp;
    <li><b>window</b><br>
        Prevents the renderer from drawing the backfaces of a brush.  Used on windows 
        (or other transparent brushes.) For an example, look at the window at he very beginning of base1.
        <br>&nbsp;
    <li><b>skip</b><br>
        A skip brush is very strange. It does nothing if a whole brush is set as a skip brush, 
        but if you only set one face of it to a skip brush then it will create the effect of 
        one way glass. The player on the side of the brush that is marked as skip will be able
        to see through the brush, but not shoot through it, and the player on the sides which
        are not marked skip will not be able to see through or shoot through the brush.
        <br>&nbsp;
    <li><b>aux</b><br>
        Does not do anything. I may be wrong though.
        <br>&nbsp;
    <li><b>lava, slime, water</b><br>
        these 3 are pretty self explanatory. Lava takes off the most damage. Slime takes off a 
        lower amount of damage, and water takes off no damage, unless you stay in it too long.<br>
        <br>
        The brush that has one of these properties turned on will not actually warp like water until
        you also give the brush the <b>warp</b> property. It will act the same way though without warp 
        set (you will be able to walk through it).
        It's cool to use these attributes with different textures, like give the lava attribute to a 
        metal brush, etc for some strange different effects. For example, in the 
        <a href="/content/quake2/tutorials/surface/surface.zip">example
        map</a> I created water but I didnt use a water texture. I used the crystal texture. It turned out pretty good.
        <br>&nbsp;
    <li><b>mist</b><br>
        Mist makes the brush nonsolid, thus you could walk through it. You can also create a mist 
        type effect by setting the mist, warp, and trans_33 properties on. Pretty cool.
        <br>&nbsp;
    <li><b>player clip, monster clip</b><br>
        The player cannot walk through a brush set with player clip but he will be able to shoot 
        through it. Monster clip is the same thing but it affects the monster_ entities instead of 
        the player. Good for not allowing monsters past a certain point or restricting the player 
        so he/she can't get into areas in which there is a possibility of getting stuck.  The use of clip brushes discussed in detail in <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/49"this tutorial</a>.<br>
        <br>
        You must also have nodraw set for the clip properties to work.
        <br>&nbsp;
    <li><b>current_0, _90, _180, _270, _up, _down</b><br>
        all the current properties are used to push the player in the selected direction (in water). 
        So current_0 will push the player in the angle of 0, which is straight right.<br>
        <br>
        The majority of the time current_ will be used along with the flowing and water properties to 
        create the effect of flowing, moving water.
        <br>&nbsp;
    <li><b>origin</b><br>
        The origin property is used with certain entities like the <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/39">turret_</a> 
        entities, <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/24#func_rotating">func_rotate</a>, and 
        <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/24#func_door_rotating">func_door_rotating</a>. Check those corresponding pages on how
        to use the origin property with these entities.
        <br>&nbsp;
    <li><b>monster, corpse</b><br>
        These do nothing at all. I may be wrong though
        <br>&nbsp;
    <li><b>detail</b><br>
        Detail brushes are very useful. They can be used to decrease vis time for a level. When a brush is 
        marked as a detail brush, vis will ignore it, thus decreasing the amount of time that qvis3 will 
        take while compiling your level.<br>
        <br>
        Too many detail brushes though will actually slow a level down. Try to keep detail brushes restricted
        to brushes that the player will not often see.<br>
        <br>
        Detail brushes, and how to use them, are discussed in 
        <a href="http://assets.aq2world.com/archive/websites/www.gamedesign.net/node/53">this tutorial</a>.
        <br>&nbsp;
    <li><b>translucent</b><br>
        if you have water and trans33 or 66 *not* set and the surface
        light flag 0 as well, then the water brush interior isn't lighted.
        when you set the translucent flag, light from outside can come inside
        although the water surface is not-see-thru. thanks 
        <a href="mailto:martin.fuchs@physik.fu-berlin.de">Martin Fuchs</a>
        <br>&nbsp;
    <li><b>ladder</b><br>
        The ladder attribute allows the player to climb up or down the brush. Most often used for creating ladders. 
        A number of people have been having problems with creating ladders but they are actually pretty easy to make.<br>
        <br>
        Make the ladder and then give every brush that the ladder is made up of the surface property of ladder. It's that 
        simple. The trouble comes up when you have the steps of the ladder too far apart and the player can't touch the next 
        step. If this is the case then you will have to create a very thin brush right in front of the ladder and set 
        the surface property player_clip and ladder to it. This will create the illusion of the player climbing up the
        ladder when in fact the player is climbing up the invisible player_clip brush.
        <br>&nbsp;
</ul>

<h3>Things to Remember about Surface/Content Properties</h3>

 <p>All the textures that are used with quake2 and are available for use by level 
    designers have default surface properties already set. For example... If you 
    select a glass texture, then it will already have the trans_33 property on. It 
    also follows that all the light textures, already have the light surface property
    set and with a light value that the creators of the texture thought was right. 
    All of this can overridden though if you desire.<br><blockquote>(Editor's Note:  Users of GTKRadiant, which was not written with Quake 2 in mind, may find that Surface & Content Properties are not set by default and will have to be set manually)</blockquote>
    <br>
    Surface Properties can also be mixed. So you could have one texture with lava, 
    flowing, current_0, tran_33 all set.<br>
    <br>
    Also remember that the surface <B>properties</B> can have selected faces with properties
    while, surface <B>contents</B> MUST have the whole brush selected with the same content 
    or a mixed face error will occur.<br>
    <br>
    The 
    <b><a href="/content/quake2/tutorials/surface/surface.zip">example map</a></b> 
    I made does not show examples of all the surface properties but it does show some
    potential of some of the cool effects you can get. It also shows how you can 
    misuse the light emitting textures. =) Way too colorful. <br>
    <br>
    Well anyways if you still don't understand please post your questions to the 
    <a href="http://forums.gamedesign.net">forums</a>.
    </p>


<!-- eof --></ul><h1 id="238" name="238" class="book-h1">Texture Blending</h1><ul><h3>Texture Blending</h3>
<br>
By James Parkman
<p>
I got an email from someone who played my maps, asking how to create the effect of a wall being painted with multiple textures. The solution is simple, but there are some nice tricks you can use to enhance both the appearance and speeds of rooms created like this. Here goes.
</p>
<p>
Ok, the goal here is to create a room whose walls appear to be painted with separate but well integrated textures. This is something you need to learn pretty quickly when editing Quake 2. Tim Willits mastered this in his levels in Quake2, and that's basically where I got the inspiration for the base style I used in Abandon All Hope. The textures were made to be used this way, and are usually clustered together by name in a manner that makes it easy to find a nicely fitting group of textures for your room. For instance, a lot of the e1u1 textures are 64x64, and their edges are specifically drawn to fit together perfectly with one another.
</p>
<p>
The idea is to <strong>let the textures do the work for you</strong>. Complex architecture may look pretty cool, but your speeds will suffer, and your vis times will completely skyrocket. So instead of adding to your poly count by crafting decorations, it's a lot more effective in the Quake 2 engine to simply meld two brushes, each painted with a well fitted texture.
</p>
<p>
<h4>An Example</h4>
<p><font size="2" face="verdana">Here you've got a simple wall. Paint it with one of the "duct" textures from e1u1, you'll notice that the texture doesn't look so hot when it's used on a large brush. So take that section of wall, decrease it's height by 64 units, and create another brush of equal width and length, this one 64 units high. Place this section in the spot that's now open from decreasing the former large wall brush. Here's 2 screenshots, before and after:
<p><center><img src="http://www.gamedesign.net/miniwood/tutorials/images/tbtut01.jpg" width="300" height="225"> <img src="http://www.gamedesign.net/miniwood/tutorials/images/tbtut02.jpg" width="300" height="225"></center></p>

<p>This adds a lot, without the need for complex architecture and outcroppings which slow down the level... plus it's simply got a nice even flow which doesn't draw your attention immediately, but creates a deep atmosphere within your level... to me, that's the difference between a level thats a work of art, and one that's "pretty cool". The best authors out there have this method down, and use it alot.
</p>
<p>Let's throw a wall support in now, using the same principle:
</p>
<p><center><img src="http://www.gamedesign.net/miniwood/tutorials/images/tbtut03.jpg" width="300" height="225"></center></p>
<p>... no  seams, blended well... get a motif like this going, and your level is one step closer to becoming a classic... take for instance this hallway from Abandon All Hope.
</p>
<p><center><img src="http://www.gamedesign.net/miniwood/tutorials/images/tbtut04.jpg" width="350" height="263"></center></p>
<p>I've used this effect to create an entire hallway, including the ceiling, walls, and support structures. Notice the depth and atmosphere this gives to the area. I'd say that this hallway was the first time I truly had that lightbulb flicker in my skull about the "art" of texture use... before this, I'd fight the editor alot trying to stretch and align whatever texture I was working with to fit the architecture. The key is, the OPPOSITE is what you should aim to do: design the architecture around the textures you will be using for your level. Of course, the brush count here is significantly higher than a simple cubic hall would give, but chances are that if you build a simple cudic hall, you're going to spend alot of time and waste alot of cpu power on decorations, or the hallway will end up looking quite plain.
</p>

<p>One other thing I should mention is light fixture placement. Personally, I like to carve my light brushes into the wall... some authors, even very good ones, don't mind having their lights jut out from the wall, which makes editing alot easier for them, as they don't have to deal with carving up their walls. If you do decide, however, to carve your lights into walls, keep in mind that you should make your light brush at least as thick as your wall, or you'll be splitting your wall brush not only into the 4 sections that result from splitting with a cube, but a 5th section, lengthwise, resulting from splitting a brush with another which is less thick. This makes it alot more difficult to move and resize your walls, and should you have alot of lights like this, you'll soon end up with a nasty  mess.</p>
<br><br>

J Parkman</ul><h1 id="44" name="44" class="book-h1">The Absolute Beginner's Guide to Quake 2 Editing</h1><ul><h3>Quake 2</h3>
	<blockquote>
		The Absolute Beginner's Guide to Quake 2 Editing - <a href="mailto:dmm2editor@aol.com">Richard Neff</a>
	</blockquote>
	
<br><br><b>In the Beginning...</b>

<p>So, you've finally played Quake 2 until your eyes are bloodshot and rather than get some sleep, you've decided, &quot;Hey, it would be sooooo cool to create my own levels!&quot; Unfortunately, you're getting into level design rather late, since Quake 2 is really an evolution of Id games since Wolfenstein 3D. So, keep one thing in the back of your mind: it is <b>not</b> a trivial thing to do Quake 2 editing. It is a very long and time consuming process - but, rest assured, the first time you blast a Strogg in a level you've created yourself, you'll be very glad you put the time into it 

<p>Just be aware that not only are you going to have to spend time creating the level, but you'll have to spend time learning the basic concepts, learning the editor you've chosen, planning the design of your level, waiting a <b>lot</b> on the compilers to do their job, and putting in the time to do all the picky little detail work on your level before it's &quot;good enough&quot; to post. Be fully aware that all of this takes some serious time, so don't expect to have a quality level in a few days.
	
<br><br><b>The First Steps</b> 

<p>The first thing you need (other than the registered version of Quake 2) is a level editor. Right now, I'm only talking about an editor that creates Quake 2 levels, not skins, texture, entities, models, etc. Some editors also include a few of those functions, but right now, let's just concentrate on the basic level editing functions. The first questions that are probably popping into your head are: &quot;What's the best editor?&quot; or &quot;What did Id use? That <b>must</b> be the best editor!&quot; First and foremost, you have to understand that <b>there is no best editor!</b>

<p>I know, all your friends babble endlessly how great one editor is and how another sucks. But, the bottom line is that you are the one that gets to spend hours bleary-eyed in front of this thing, so you need to check out all the editors you can before committing to a single one. In fact, you may have already jumped the gun and bought/downloaded an editor. That's ok too, just realize that although it may be the editor you learn on, it may not be the editor that you use to do all your later maps. (And Id used a rather hard-to-get working QE4, which had an interface that was designed more for people who REALLY knew the game rather than beginners. If you're really interested in trying to use QE4 under Windows 95, you're probably much better off just downloading QERadiant - trust me on this.)
	
<br><br><b>Where Do I Get a Level Editor?</b> 

<p>Fortunately, you're in luck. Go to the Links page here at Rust and you'll see a listing of some of the major Quake 2 editors. Keep in mind that some of them are freeware, some are shareware, and finally some are retail products. However, don't assume that the retail products are any better/worse than the others. Also, each has it share of advantages, disadvantage and flaws. Most also have Web sites dedicated to updates, tutorials and other editor specific information (as opposed to Rust which is pretty editor non-specific.)

<p>Additionally, there is something you may need beyond the level editor itself: the compiling tools. Id uses 3 compilers to turn the maps that editors create into fully playable levels for Quake 2. They are QBSP3, QVIS3, and QRAD3. Each of these has a different purpose which will be described later in this document. Some editors provide these files with the package/download, while others require you to download them yourself.
	
<br><br><b>Knowing the Components of the Quake 2 Engine</b>

<p>The key components of the Quake 2 engine are: Entities, Attributes, Brushes, .map files, and the compiler programs. Let's look at each and what it does.

<blockquote>
	
	<b>Entities</b>

	<p>Entities are the &quot;active&quot; objects of Quake 2. Things like monsters, weapons, powerups, triggers, etc. are all entities. Each entity in Quake 2 has a specific task that is hard coded, either in the regular Quake 2 engine or as a separate add-on modification, such as Capture the Flag (CTF) or the Mission Pack. Additionally, there are two different types of entities: point entities and solid entities.

	<p>A point entity is an entity that has a model preassigned to it. For example, a monster. The monster does not require the user to create the physical representation of the monster or its movement. This has already been done by the entity creator. When you place a monster entity in your editor, Quake 2 automatically puts the monster in its proper place. Typically, this also means that if you use a box and make it a monster, you don't need to worry about the size of the box, since it will be replaced by the appropriate model when Quake 2 runs. Some examples of point entities: monsters, lights, health, player starts and powerups.

	<p>A solid entity is an entity where the level designer does have to give a solid geometry in order for the entity to work. An example of this is a door. You have to make a door the size and shape you want. The advantage of having to define the solid for the entity is to allow a greater design range for which to create those entities. For example, you may want a double door rather than a single door, so being able to define this gives you that option. Examples of solid entities are: doors, triggers, buttons, trains, and platforms.

	<p>A common thing about all entities is that certain things need to be defined for each entity in the level to modify the behavior of that entity. For example a trigger isn't much good if you can't tell what is to be done by that trigger. So, each entity has properties that can be defined by the user. These properties are known as <em>attributes</em>.

	<br><br><b>Attributes</b>
	
	<p>An attribute is basically, the stuff that defines how an entity is supposed to work. For example, a trigger needs to have something to target when the player goes over it. So, one attribute of a trigger is the Target attribute, which points to the name of whatever is supposed to happen when the player runs over it. If the trigger is to open a door, then the Target attribute will have the name of that door. Additionally, a trigger entity also has a delay, which allows you to set the amount of time has to pass before the trigger becomes &quot;active&quot; again.

	<br><br><b>Brushes</b>
	
	<p>Now that we know what entities are, we can adequately describe what brushes are. Brushes are simply anything in the Quake 2 level <b>other</b> than entities. Basically, this means the walls, floor, ceiling and anything else that the player can't pass through, but don't really do any other functions. A good way to think of brushes is to equate them to bricks or building blocks. They simply define the structure of a level.

	<p>Some things to note about brushes, however. A brush can only be convex. This means that no &quot;dents&quot; are in the brush. You can't pass a straight line through a brush where it passes out of the brush and back in. For example, a square is a convex brush. A &quot;C&quot; shape, is not a convex brush. However, you can make multiple brushes to comprise a &quot;C&quot; shape.

	<p>Additionally, brushes must be solid and are comprised of straight edges. You can't ever be &quot;inside&quot; a brush (rooms are actually &quot;hollowed out&quot; brushes where you have six solid brushes making up the walls, roof, and floor.) The Quake 2 engine also doesn't support curved edges - however, you can have many straight edges on a &quot;side&quot; that make it seem curved. This was done by Id and other levels to simulate rounded objects.

	<br><br><b>*.MAP Files</b>
	
	<p>This is the standard for all Quake 2 editing files. However, as with any type of &quot;standard&quot; in the industry, each editor may implement .map files differently - which may make it harder to open a .map file created in one editor into another. That aside however, all editors (whether they are able to import .map files are not) must be able to create a .map file so the compilers can create a playable level.

<p>The structure of the .map file is actually pretty straightforward. It is a text file (meaning you can open it and modify it directly in any text editor, such as Notepad) that holds descriptions and attributes of the brushes and the entities that make up the level.

	<br><br><b>Compiler Programs</b>
	
        <p>As I mentioned earlier, you need 3 compiler programs in order to create playable Quake 2 levels. These compilers turn the text-based .map file into a compiled .bsp file which users can play. The first compiler, QBSP3, creates the initial .bsp file. This breaks up all the brushes into smaller brushes and builds the playable .bsp file. In fact, you could just run the QBSP3 compiler and have a playable map (and you'll usually do this as your maps get bigger for testing purposes.) However, the other two compilers do more modifications to the .bsp file that make it run faster and look better.
        
        <p>The next compiler, the QVIS3 program, does something known as visibility calculating. Basically, it calculates what a player can see from any given viewpoint in the level. The primary function of the VIS compiler is to speed the level up during gameplay be pre-determining whether or not a player can see certain areas of the map at the current viewpoint. While you may not notice much of a difference in the actual appearance of a VIS compiled map, the speed should almost always be faster than a map that hasn't had the VIS compile run.
        
        <p>The final compiler, QRAD3, is the lighting (radiosity) generator. Until this compiler is run, the map will not have any lighting effects defined. This means that the level will run completely lit, regardless of the location of any light entities or surface texture lighting. This is the last compiler to run, meaning you must run the QBSP3 and the QVIS3 compilers before this compiler can be run.
        
        <p>A thing to note about the compiled .bsp files. In Quake 1 textures used in the level were kept inside the .bsp file. In Quake 2 however, they are not. So, if you decide to use custom textures other than the ones originally used in the Id game, you have to provide those textures either in a .zip file or .pak file (which Id used to store all the .bsp level files) to distribute those textures. However, this is a little outside the range of what you should worry about as a beginner.

	<br><br><b>And Just What the Heck is a Leak?</b>

	<p>The dreaded leak - the biggest stumbling block to the beginner editor (and it even plagues more advanced editors from time to time). To understand leaks you need to understand how the Quake 2 engine views the world around it. By default, anything a that isn't in a self contained room, is in the 'void.' (not to be confused with the sky) Players can NEVER see or go into the void.

	<p>The best way to handle this is to realize that your level much be completely contained. Imagine filling up your level completely with liquid...if any of the liquid could escape, then your level is not completely contained - and a leak occurs. However, this checking occurs from the player start position and works out - so, if you have the player starting outside the outer walls of your level, a leak could occur as well.

	<p>Additionally, the player can't be able to see into the void. So, you can't use transparent textures as outer walls. This will also cause a leak error to be displayed.

        <p>As I mentioned, don't confuse this with the sky. A sky is simply a special texture property. The Quake 2 engine gives the illusion that there is more out there beyond the limits of your map, but from a design standpoint, your level still has to be self contained and the player can't see the void anywhere.

	<p>Keep in mind leaks can be very small...the slightest gap between two outer walls can cause leaks (and on a more advanced note - be sure to use the right compiler for your editor since some editors, such as Qoole, use 'floating point' sizes, while some compilers round off.) And some editors can use what's known as pointfile information to draw a line to leaks, while other editors don't offer this feature.

	<p>But, why worry about leaks? First and foremost, leaks are bad because they slow the engine down a lot. Also, they prevent you from running the VIS and RAD compilers, so you don't get proper lighting or a fast playing level. Both of which are considered bad and prevent you from having your levels posted or played by others. Finally, anywhere a player can see into the void may cause effect like the &quot;Hall of Mirrors&quot; effect where the last image is constantly displayed or a &quot;grey area&quot; effect, where the player is able to see grey where the void is.

</blockquote>

<b>What about the Next Steps?</b>

<p>Ok, so you've learned the basic concepts of Quake 2 editing, now lets look at what all Quake 2 levels need:

<blockquote>

	<b>The Worldspawn Entity</b>
	
	<p>The Worldspawn entity is a special entity that defines certain things about the map, like the CD track to play, the sky to use, the next level, and other things that affect the entire level. Keep in mind that with some editors, this may be listed or access differently (Qoole and DMM2 come to mind - Qoole requires you to bring up the entity window while no other entities are selected and DMM2 uses File, Game Options to edit these settings.)

	<br><br><b>A Room</b>
	
	<p>This is pretty obvious. But, you do need to have a least a room before you can place entities into your quake level

	<br><br><b>The Player_Start Entity</b>
	
	<p>Even in DM and CTF maps, you probably want to put this entity down to test your levels. Some editors will even put this entity in if you don't explicitly specify it. You can have only one player_start entity. However, you need to have a player start, even if you use the DM or CTF starts, in order to play your map.

	<p>The player_start has to be inside the level otherwise a leak will occur. This is especially important with editors that put a player_start where the observer in the editor is when you don't have an explicit player_start entity defined.
	
</blockquote>

<b>And that's about all the basics!</b>

<p>That's is the overview of Quake 2 editing in general.
Obviously, we didn't cover every single aspect of editing. Heck,
we didn't even talk about how to create a room! That's because
most anything else you want to do is going to be specific to a
particular editor. Some editors will create a room automatically
with all six sides, while some editors will require you to create
a box, then &quot;hollow&quot; it out. Check out the tutorials
for your editor on either the editor's home page or pages
dedicated to that editor to help you get started.

<p>However, Rust lists all the Quake 2 entities and attributes
for the entities included with the Id game (however, not all
modifications, total conversions (TCs), and mission pack entities
are listed). Additionally, other tutorials are here for helping
you to create better Quake 2 levels.

<div align="center"><br><br><b>Some Tips for Beginners</b><br><br></div>

<table width="400" align="center" border="0" cellspacing="0" cellpadding="0"><tr><td> 
        <li><b>Go slowly.</b> Don't try to make the perfect level on your first few attempts! Make small practice levels to learn basic concepts and effects before implementing them in a level you care about.<br><br>     
        
        <li><b>Read a </b><em><b>lot</b></em><b>! </b>Read through all of the tutorials here at Rust before you go head-first into map building. In fact, you may want to fire up the ol' printer and get some of this stuff in hardcopy so you have it in front of you while editing. Trust me, you'll save yourself a lot of time and frustration later on if you do this.<br><br>
        
        <li><b>Learn your editor!</b> One of the best things you can do is visit sites dedicated to your editor and learn what it can/can't do. It always amazes me the number of people who complain, &quot;My editor can't do this!&quot; when, in fact, it can. They just didn't take the time to read all the tutorials out there.<br><br>
        
        <li><b>Start small!</b> Don't try to do every single cool effect you've ever seen. A lot of this stuff was done by people who had done a lot more maps than you have, so don't assume that you can do the cool stuff that Id or anyone else did right away. The truth of the matter is that your first few maps probably aren't even &quot;playable&quot; maps, so don't even post them - in fact, expect this and realize that they are learning experiences, not &quot;playable&quot; levels.<br><br>
        
        <li><b>Keep rooms small too!</b> The Quake engine is very picky about size. The larger the room, the more the Quake engine has to do to display the room and all the stuff in it. <b>Don't</b> do large outdoor areas!!! Until you learn what the Quake 2 engine can handle, don't even try to create outdoor rooms. This is better left for when you've gotten some basic experimenting out of the way.<br><br>
        
        <li><b>Plan ahead.</b> Without question, the biggest mistake of the beginner. Quake is very sensitive to the number of brushes and entities in a single view. The more stuff the engine has to render, the slower the gameplay. Also, knowing what you want to do makes it easier to create a level that &quot;flows&quot; well from one room to another. Keep in mind a level isn't just a bunch of different rooms connected to each other. It's something that is designed to either complete an objective in Single Player mode or to create a fair, yet interesting battleground for DM mode. You have to plan ahead to keep from spending hours on a map that doesn't even play well or doesn't look good. <br><br>

        <li><b>Ask questions, but don't bug people.</b> Most editors are willing to help a beginner out, but don't abuse that willingness. When you have a question, post it on a discussion board, like the one here at Rust, or a public discussion area, such as a newsgroup. And don't assume the world revolves around you. You're question may sit a while before it's answered (and if it goes unanswered too long either your idea can't be done or you haven't exhausted the sources of information out there.) Be sure that you've read FAQs and tutorials about Quake 2 editing and your editor specifically before posting questions - otherwise, you may get the short reply of, &quot;Check the FAQ&quot; or some other less-than-happy reply. Additionally, don't assume that an author of a tutorial, FAQ, or reply wants a personal e-mail. (Especially in my case!) You should ask before you send questions whizzing through cyberspace using e-mail, or you may not like the reply (plus still not get your question answered by someone who could normally help.) <br><br>
             
        
        <li><b>Finally, have fun!</b> Editing is a long and tedious process, but the final result almost always makes it worthwhile!
</td></tr></table>

<p>
</ul><h1 id="266" name="266" class="book-h1">The BSP Process and Visibility</h1><ul><h2>The BSP Process and Visibility</h2>
<h3>By Geoffrey DeWan<h3>

<hr>

<center><B>**** Let this page load fully or the animated GIF's may not animate. ****</B></center>

<hr>
<br><a NAME=TOC></a><h3><b>TABLE OF CONTENTS</b></h3>

<ul>
<li>
<a href=/node/266#PDF#PDF Version</a></li>

<li>
<a href="/node/266#Introduction">Introduction</a></li>

<li>
<a href="/node/266#TheMap">The Map</a></li>

<li>
<a href="/node/266#TheBspProcess">The BSP Process</a></li>

<li>
<a href="/node/266#VisibilityNodes">Visibility Nodes</a></li>

<li>
<a href="/node/266#CheckingVisibility">Checking Visibility</a></li>

<li>
<a href="/node/266#HintBrushes">Hint Brushes</a></li>

<li>
<a href="/node/266#DetailBrushes">Detail Brushes</a></li>

<li>

<a href="/node/266#DetailHintBrushes">Detail Hint Brushes</a></li>

<li>
<a href="/node/266#Files">Files</a></li>

<li>
<a href="/node/266#End">Credits</a></li>
</ul>

<hr>
<br><a NAME=PDF></a>(<a href="/node/266#TOC">Table of Contents</a>)


<H3><b>PDF VERSION</b></H3>
A version of this tutorial exists as a PDF file.
<BR><BR>
<a href="http://www.gamedesign.net/miniwood/tutorials/files/bsp_pdf.zip">DOWNLOAD - bsp_pdf.zip</a>
<BR><BR>
The AVI's in this archive need to be extracted to the same directory as the .pdf file.

<p>
<hr>
<br><a NAME=Introduction></a>(<a href="/node/266#TOC">Table of Contents</a>)
<h3>
<b>INTRODUCTION</b></h3>
This tutorial is written for Quake II and to some extent Quake 3 Arena.&nbsp;
However, all Quake engine games work on a similar principle (though not
all have hint brushes or detail brushes).
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/warning.jpg" HSPACE=5 align=LEFT>This symbol
represent a very important warning or caution.
<br>&nbsp;
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/q3a.jpg" HSPACE=5 align=LEFT>These sections
to apply to Quake 3 Arena.
<br>&nbsp;
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/q3a.jpg" HSPACE=5 align=LEFT>In Quake 3
Arena,&nbsp; q3map handles all the functions that q3bsp, qvis3, and qrad3
handled for quake II.

<br>&nbsp;
<p>
<hr>
<br><a NAME=TheMap></a>(<a href="/node/266#TOC">Table of Contents</a>)
<h3>
<b>THE MAP</b></h3>
The examples in this tutorial are going to use the following map, which
consists of 4 walls, and 2 objects in the middle:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_quake2view.jpg" ></center>
<p>We will use the following overhead view for this tutorial:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_base.gif" ></center>
<p>This map is a 2 dimensional map.&nbsp; Lines in this map will correspond
to polygons in the&nbsp; 3 dimensional map.&nbsp; The polygons in this
2 dimensional map will correspond to brushes in the 3 dimensional map.

<p>
<hr>
<br><a NAME=TheBspProcess></a>(<a href="/node/266#TOC">Table of
Contents</a>)
<h3>
THE BSP PROCESS</h3>
There are 12 extraneous polygons on the outside walls of this map, so lets
simplify matters a bit by eliminating them (which will happen anyway during
the BSP process if there are no leaks):
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_start.gif" ></center>
<p>The gray area around the edge will represent the part of the world we
do not care about since it will be outside the play area.&nbsp; There will
be some additional bsp splits by the 12 eliminated surfaces out here but
nothing that will affect the interior of the map.&nbsp; White is the empty
area a player can move around in.&nbsp; The stone is solid.

<p>During the BSP process qbsp3 takes each polygon one by one and inserts
them into the bsp tree.&nbsp; The term tree describes the data structure
the bsp nodes are stored in (if the data structure is drawn graphically
on a piece of paper, it looks something like a tree or bush).&nbsp; As
each polygon is inserted, it will split space up into smaller and smaller
regions, but it will only split up the regions it is inserted into.&nbsp;
The process is shown graphically below (if this image is not animating,
reload the page and don't stop the loading of the page, or open image up
in a separate browser window):
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_process.gif"  height=190 width=380></center>
<p>As you can see, the order the polygons are inserted have an effect on
how the map is broken up.&nbsp; Adding, deleting,&nbsp; or changing a single
brush can cause qbsp3 to go into an entirely different direction and cause
significant performance changes (either better or worse).
<p>In reality, qbsp3 uses certain rules to select which order to insert
polygons.&nbsp; First it assigns a really high priority to axial polygons.&nbsp;

These are polygons whose X values are all the same, Y values are all the
same, or Z values are all the same (in the editor, in 2 of the 3 possible
2d views, the polygon will show as a simple line).&nbsp; After that, it
will look for polygons that will split up the remaining uninserted polygons
the least.&nbsp; The bsp animation with the darker gray border is the one
much more in line with what qbsp3 will actually do.&nbsp; However, for
this tutorial, I am going to use the one with the lighter gray border for
illustrative purposes.
<p>Both the thick blue and thin black lines lie on what are known as bsp
split planes.&nbsp; They break the map up into small (or sometimes, not
so small) regions.&nbsp; Each of these regions is a bsp node.&nbsp; You
will never find a world polygon in the middle of a bsp node.&nbsp; They
all lie on a bsp node edge/side.&nbsp; Moving objects, etc. are not part
of the bsp tree and are handled separately.

<p>The thick blue lines are your solid polygons.&nbsp; You can't move through
them.&nbsp; They are almost always visible.&nbsp; If it is not visible
for whatever reason, you will probably wind up with what is known as the
Hall Of Mirrors (HOM) effect or see other, further parts of your level
through it.
<p>The thin black lines are what become your portals.&nbsp; Portals separate
bsp nodes where there is no solid polygon.&nbsp; They are not visible,
but polygons generated with a mist-ed brush, or other non solid brush can
overlap them.&nbsp; They do not block movement.&nbsp; There are actually
2 between any 2 bsp nodes (where there is no solid polygon).&nbsp; Each
of those 2 portals is attached to its respective bsp node.&nbsp; See image
below (if this image is not animating, reload the page and don't stop the
loading of the page, or open image up in a separate browser window):

<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_twin_portals.gif"  height=190 width=380></center>
<p>The arrows indicate which way the portal faces.&nbsp; The shaded node
is the node the portal is attached to.
<p>When a polygon is inserted that is inside 2 or more bsp nodes, it gets
split into several pieces such that each piece is in a single node.&nbsp;
However, qbsp3 will later to try to merge faces with identical properties
together if possible (so you may have a single polygon attached to multiple
bsp nodes), so you often wont see evidence of this effect if you turn on
gl_showtris (see discussion of gl_showtris below).
<p>The following is a 3d representation of this map in Quake II:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_quake2view2.jpg" ></center>
<p>The thin semi-transparent windows represent the portals which you can't
normally see.
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/q3a.jpg" HSPACE=5 align=LEFT>Unlike qbsp3
which breaks up polygons to fit into polygon nodes, then tries to merge
them again later, q3map for Quake 3 Arena leaves polygons unbroken, and
makes no attempt to merge later.&nbsp; The ultimate effect is roughly the
same.&nbsp; The bsp tree itself is still built as normal.
<p>
<hr>

<br><a NAME=VisibilityNodes></a>(<a href="/node/266#TOC">Table of
Contents</a>)
<h3>
VISIBILITY NODES</h3>
Lets take the following possible final bsp arrangement (from one of the
example bsp-ings above):
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_final1.gif" ></center>
<p>As mentioned above, each of the white areas is a bsp node.&nbsp; These
bsp nodes are also used for visibility determination.&nbsp; Qvis3 goes
through and determines which nodes are visible from which nodes.&nbsp;
Lets take the following 2 points, one being an observer, another being
a point on a wall that is being looked at:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_view1.gif"></center>

<p>As you can see by the red line, the two points are not visible too each
other.&nbsp; However, with this bsp, qvis3 (and thus Quake II) will think
they are.&nbsp; Why is this?&nbsp; Because the nodes they are in are visible
to each other.&nbsp; Qvis3, when checking for visibility, checks each portal
against each other portal.&nbsp; If it finds 2 portals that can see each
other, then the 2 bsp nodes they are part of can see each other.&nbsp;
In the following image, the portals currently being looked at are marked
in yellow.
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_portal1.gif"></center>
<p>Since they can see each other (1 of the infinite number of possible
lines of sight is marked in a dashed red line), the bsp nodes the black
dots are in can see each other.&nbsp; This means that as far as qvis3 and
Quake II are concerned, the observer can see the point on the wall.

<p>This, by the way, is where the infamous "Leaf portals saw into leaf"
warning comes from.&nbsp; When this happens, it means it tried comparing
2 leaf portals that belongs to the same visibility node.&nbsp; There was
a nasty bug in the original qbsp3 (yes, qbsp3.&nbsp; It wrote out a bad
bsp that qvis3 had problems with) that resulted in seeing this error often.&nbsp;
Seeing it often meant that there were serious problems with the map.&nbsp;
However, a number of rewritten qbsp3's fixed this problem.&nbsp; In the
<a href="/node/266#Files">files</a>
section below is a link to my <a href="/node/266#Files">gddqbsp3</a> which has this
fix.&nbsp; Even with fixed qbsp3's, you may still see the warning.&nbsp;

Take a look at the following:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_leaferror.gif" height=190 width=380></center>
<p>The red and yellow portals were originally 1 portal that got split into
2.&nbsp; Normally, qvis3 takes steps to prevent unnecessary portals from
being checked against each other, but this can fail.&nbsp; Both the shown
portals should lie on the same plane, but due to limitations of floating
point numbers as they are represented in computers, they may be slightly
bent with respect towards each other (by a real small amount you could
never hope to see with the naked eye).&nbsp; If this happens, and they
bent in a concave fashion, you will get this error.&nbsp; The following
picture shows what this looks like (if this image is not animating, reload
the page and don't stop the loading of the page, or open image up in a
separate browser window):
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_leaferroranim.gif" height=190 width=380></center>
<p>The angles are highly exaggerated.&nbsp; The dashed line shows how the
node saw itself.&nbsp; In this situation, the warning is harmless.&nbsp;

There are several other similar situations where you might see this warning,
all the result of a computer's finite precision floating point math.&nbsp;
If you have a fixed qbsp3, do not worry about this warning.
<p>If the portal in question is axial, this should not happen.
<p>
<hr>
<br><a NAME=CheckingVisibility></a>(<a href="/node/266#TOC">Table
of Contents</a>)
<h3>
CHECKING VISIBILITY</h3>
So you have your map up and running and want to see how visibility worked
out where you have speed problems.&nbsp; The primary way of doing this
is using one of the OpenGL rendering modes, then setting gl_showtris 1.
Take the following view from base64 (deathmatch compilation of base1, base2,
and base3 from the single player game):
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/notris.jpg" ALT="gl_showtris 0"></center>

<p>And now with gl_showtris 1:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/tris.jpg" ALT="gl_showtris 1"></center>
<p>This shows us that Quake II believes that a lot of polygons are visible
when they really are not.&nbsp; It is showing all the polygons in all currently
visible nodes.&nbsp; In case you are wondering, I removed the player weapon
by typing "hand 2" at the console.
<p>The triangles are not part of the bsp.&nbsp; When polygons are rendered,
they get broken up into triangles in the engine.
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/warning.jpg" HSPACE=5 align=LEFT>In either
Quake II or Quake 3 Arena, it is possible to have polygons cross node boundaries.&nbsp;
Thus gl_showtris is not useful for showing where your portals are.
<br>&nbsp;
<br>&nbsp;
<h3>
3Dfx Cards</h3>

The 3dfx minidriver does not support gl_showtris.&nbsp; You can use the
default OpenGL drivers, but if you are using the software OpenGL (Microsoft's
or SGI's), it will be really slow, and possibly somewhat unstable.&nbsp;
You can also load the MesaGL driver for 3dfx cards.&nbsp; A link to these
drivers can be found in the <a href="/node/266#Files">files</a> section below.&nbsp;
Once you have the drivers, put it in your Quake II directory (DO NOT put
it into your system/system32 directory).&nbsp; Make sure it is named opengl32.dll
if it isn't already.&nbsp; Now when you use default opengl drivers, it
will use the Mesa drivers (which the above screenshot was taken with).
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/warning.jpg" HSPACE=5 align=LEFT>This data
was acquired in early 1999.&nbsp; Later versions of MesaGL may not support
gl_showtris.&nbsp; However later versions of 3dfx's drivers might.

<br>&nbsp;
<h3>
Still Not Seeing Triangles?</h3>
If you do not see triangles, you may need to issue the following commands
at the console:
<p>gl_ext_multitexture 0
<br>vid_restart
<p>As this may involve performance degradation, you will want to do the
following when done using gl_showtris:
<p>gl_ext_multitexture 1
<br>vid_restart
<p>
<hr>
<br><a NAME=HintBrushes></a>(<a href="/node/266#TOC">Table of Contents</a>)
<h3>

HINT BRUSHES</h3>
In the example bsp, there are only 4 pairs of bsp nodes that are not visible
to each other (shown marked below):
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_nonvis1.gif"></center>
<p>There are 21 possible pairs of bsp nodes, only 4 of which are hidden
from each other. This is not good.&nbsp; It will result in problems similar
to above in the base64 map.&nbsp; The base64 scene above is actually not
too bad but you can get more extreme examples where you may be drawing
the same part of the screen 3, 4, 5, or more times.&nbsp; In the original
Quake, mappers were forces to go through various games to keep visibility
reasonable.&nbsp; Fortunately, Quake II gives us a tool with which we can
control bsp-splits: the hint texture.&nbsp; What does the hint texture
do?&nbsp; The hint texture is a texture that forces a bsp split even though
the hint texture is not visible.&nbsp; Another feature of the hint texture
is that qbsp3 will not chose a polygon insertion order that will result
in a non-hint polygon splitting a hint polygon.

<p>The hint texture is typically used in conjunction with the skip texture.&nbsp;
The skip texture polygons are not inserted into the bsp-tree and thus,
not used by Quake II.&nbsp; The idea is to take a brush, apply the skip
texture, then apply to a single side of the brush the hint texture.&nbsp;
This will result in a single hint polygon inserted where the brush is,
which is generally all that is necessary.&nbsp; However, you can use an
entire hint brush, but this will make the bsp-splits a bit more complicated.
<p>When you lay out your hint planes, you have to place them such that
two areas you intend to keep hidden from each other don't have the hint
planes facing each other.&nbsp; For the example map, we will try a grid
as follows:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_myhints.gif"></center>
<p>In an editor (this particular shot came from Qeradiant), it will look
something like this (except for the inset):
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_quake2hint.jpg"></center>
<p>The inset shows the area at the base of the line from another angle.&nbsp;

These brushes all have 5 skip faces, and 1 hint face.&nbsp; The skip faces
are completely ignored, only the hint faces are processed.&nbsp; We could
reduce the number of hint/skip brushes down to as few as 3 by using more
than one hint face per brush but for this example, we will use 1 hint face
per brush (for one thing, by keeping the brushes thin, they don't clutter
up the view in the editor as much).
<p>The 2 points we used above are still going to be visible to each other
as the new nodes they will be in will still be visible to each other:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_portal2.gif"></center>
<p>However, there are more areas hidden from each other.&nbsp; None of
the areas marked with the same letter will be visible to each other. There
are additional areas not visible to each other (for example, the nodes
in each set of opposite corners) which would have made the diagram too
complex and confusing if completely listed.&nbsp; Visibility will never
be perfect. At any given point in your level, there will be parts of your
level that are not visible but will get drawn anyway (with a few exceptions
like facing an outside wall with nothing behind it).
<p>It will take some trial and error to get a feel for what works well.
Deciding where to place hint planes can be something of an art form.&nbsp;
One good use for hint brushes is in hallway bends as follows:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_hall1.gif"></center>
<p>You can keep people from seeing too far around the bend by laying a
hint brush across the corner like this:

<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_hall2.gif"></center>
<p>This way you make sure you can only see down both hallways at once if
you are in the corner.
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/warning.jpg" HSPACE=5 align=LEFT>One thing
you have to watch for is that the hint brush must make contact with all
edges.&nbsp; Otherwise, if qbsp3 puts a split plane between a surface and
your hint brush, you are not going to get the results you expect.&nbsp;
You may want to even extend them into the adjacent surfaces slightly.
<br>&nbsp;
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/warning.jpg" HSPACE=5 align=LEFT>It is
possible for portals lying on the same plane to cause problems.&nbsp; We
can trust that nodes of the same letter in the above example are not visible
to each other in spite of the fact they share portals on the same plane
because they are axial, but look at the following 2 nodes:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_nonvis2.gif"></center>
<p>The portals on the planes shared by both shaded nodes are not axial.&nbsp;
As a result, slight numerical errors due to the limits of the floating
point unit on your CPU may cause them to be visible to each other after
all as shown:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_unaligned.gif" height=190 width=380></center>
<p>The angle of error shown here is extremely exaggerated.&nbsp; When forcing
a split on a non-axial plane, a single hint plane may not be enough.&nbsp;

You may want to use a double sided hint brush about 8 or 16 units, with
the ideal portal running through the middle as follows:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_double.gif"></center>
<p>The red/yellow/black striped lines are the hint brushes.&nbsp; The 2
red parts on the edges would be the hint surfaces of the hint brush, the
rest of the surfaces of the hint brush would be marked as "skip".&nbsp;
The black line running down the center is where the original portal was.&nbsp;
This will trap any errors between the two planes.&nbsp; You can use either
2 hint brushes, or opposite sides of the same thin hint brush.&nbsp; This
is only necessary when you care about how 2 or more portals that lie on
the same plane interact with each other.
<p>In addition to placing hint brushes where you want portals, you can
place them in the void or in geometry to separate parts of the level from
each other.&nbsp; For example, if your map consists of 2 separate parts
connected only by teleporters, putting a huge hint brush (such that you
cannot connect any 2 points, one from each part, without going through
it) between the 2 parts will keep brushes in either part (except for other
hint brushes) from causing bsp splits, etc., in the other.
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/warning.jpg" HSPACE=5 align=LEFT>In reality,
due to either face merging in Quake II, or not being split in the first
place in Quake 3 Arena, the polygons on the perimeter would span multiple
nodes, and if a polygon is visible in any of the nodes, it is completely
visible.&nbsp; In this example, it would make hint brushes practically
useless.&nbsp; In a real map, with a much higher density of polygons per
major area you want to partition off, this is hardly a problem.

<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/warning.jpg" HSPACE=5 align=LEFT>It may
be tempting to break up your map into a bunch of real tiny areas with hint
brushes but while this will certain help visibility, this will greatly
increase the amount of time qvis3 takes to run, and you will probably run
afoul of the 1 megabyte limit for the map's visibility data (see section
on detail brushes below for more information on how to reduce visibility
complexity).&nbsp; You generally want to take steps only when you have
speed problems.&nbsp; Often the level geometry itself will be sufficient.
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/q3a.jpg" BORDER=0 align=LEFT><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/warning.jpg" HSPACE=5 align=LEFT>Quake
3 Arena has a skip texture, but it does not work.&nbsp; In fact, due to
the way q3map processes the map, this cannot be represented at all.&nbsp;
The entire brush will have to be a hint brush.
<br>&nbsp;
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/q3a.jpg" BORDER=0 align=LEFT><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/warning.jpg" HSPACE=5 align=LEFT>In
Quake 3 Arena, hint brushes do not get preferential treatment when being
inserted into the bsp tree.&nbsp; This means that hint brushes can only
be used to create portals,&nbsp; The tip above about separating map parts
will not work.
<p>

<hr>
<br><a NAME=DetailBrushes></a>(<a href="/node/266#TOC">Table of
Contents</a>)
<h3>
DETAIL BRUSHES</h3>
Lets take our previous map, and add a few small brushes.&nbsp; The final
bsp might look something like this:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_splits.gif"></center>
<p>As you can see, the number of bsp nodes has increased from 7 to 13.&nbsp;
The number of nodes to run bsp calculations has almost doubled and will
cause the size of the visibility information to nearly quadruple.&nbsp;
However, the new brushes do practically nothing to block visibility, making
the visibility information needlessly complex.&nbsp; In the original Quake,
this was a fact of life you pretty much had to live with.&nbsp; With Quake
II, like the hint texture above, we get a tool to help us out: the detail
brush.&nbsp; Unlike the hint texture, which is applied to individual brush
faces, detail is a property that applies to the entire brush.

<p>What happens with detail brushes, is that the polygons making it up
are inserted into the bsp tree last.&nbsp; Additionally, when detail brush
polygons are inserted, they do not create portals, and the bsp nodes they
cut up are treated as one single visibility node.&nbsp; Lets make the 3
triangular brushes detail brushes.&nbsp; Then we will end up with something
like:
<p><center><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/bsp_detail.gif"></center>
<p>The dashed lines are bsp splits, but do not contain portals.&nbsp; Qvis3
treats the entire shaded area as a single node for visibility calculations.&nbsp;
This greatly simplifies the qvis3 process and makes it a lot faster.&nbsp;
When deciding if a brush should be a detail brush or not, you should pick
those that look like that could be seen around easily.&nbsp; Good candidates
for this are things like beams, light fixtures, computer terminals, pretty
much anything small that doesn't do a good job of blocking visibility.&nbsp;

This can be tricky and will some take some trial and error to get a good
feel for.&nbsp; You will want to use gl_showtris mention above as an aid
to this process.
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/warning.jpg" HSPACE=5 align=LEFT>Make sure
all sides of your detail brush are either detail or structural.&nbsp;&nbsp;
If this is not the case, you will get mixed face contents warnings.&nbsp;
If your editor has an option to make a brush structural or detail, you
may want to use that instead of using the editor's surface properties dialog
box.
<p><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/q3a.jpg" align=LEFT><img SRC="http://www.gamedesign.net/miniwood/tutorials/images/warning.jpg" HSPACE=5 align=LEFT>Detail
brushes work differently in Quake 3 Arena then they do in Quake II.&nbsp;
They are still used in the same situations, but hidden sides are not removed
by CSG operations.&nbsp; This means that you will have to remove them manually
by applying the "caulk" texture to all hidden surfaces to keep unnecessary
drawing down.
<p>
<hr>
<br><a NAME=DetailHintBrushes></a>(<a href="/node/266#TOC">Table
of Contents</a>)

<h3>
DETAIL HINT BRUSHES</h3>
Detail hint brushes are not part of id's original compiling utilities.&nbsp;
If you are using those, you will not be able to use this feature.&nbsp;
In my <a href="#Files">gddqbsp3</a> (see <a href="#Files">files</a> section
below), they are implemented such they are hint brushes that only affect
detail brushes.&nbsp; They were primarily implemented as an aid to terrain
generators to keep detail brush based rolling terrain from cutting itself
up.&nbsp; <a href="#Files">Gensurf</a> (see <a href="#Files">files</a>

section below) is capable of using detail hint brushes (it also comes with
its own version of qbsp3 that also implements detail hint brushes).
<p>
<hr>
<br><a NAME=Files></a>(<a href="/node/266#TOC">Table of Contents)</a>
<h3>
FILES</h3>

<ul>
<li>
<a href="http://home.insightbb.com/~gryndehl/q2compile/quake2.html">gddqbsp3</a> along
with my other enhanced Quake II compile utilities.</li>

<li>
<a href="http://tarot.telefragged.com/gensurf/">Gensurf</a> by David Hyde.</li>

<li>
<a href="http://www.geocities.com/SiliconValley/Lakes/7220/mesa.html">MesaGL.</a></li>
</ul>

<hr>
<p><a NAME=End></a>(<a href="/node/266#TOC">Table of Contents</a>)
<h3>

CREDITS</h3>
Tutorial written by Geoffrey DeWan <a href="mailto:gdewan@prairienet.org">gdewan@prairienet.org</a>
<p>Many thanks to those who have helped proofread and give suggestions
for this tutorial:
<ul>
<li>
SmallPileofGibs</li>

<li>
bushboy (for the optimized images)</li>

<li>
some guy I know</li>

<li>
EutecTic</li>

<li>
Johnny Law</li>

<li>
XO (for pdf version)</li>
</ul></ul><h1 id="56" name="56" class="book-h1">Timing in Quake 2</h1><ul><h3>Quake 2</h3>
	<blockquote>
		Timing in Quake 2 - <a href="mailto:demolisherfx@usa.net">DemolisherFX</a>
	</blockquote>

<br><br><b>TECHNIQUE #1</b>: 

<p>I've played a few quake2 maps and haven't seen any timing implemented. People just use direct triggers in their maps. 

<p>I will tell you in this tutorial how to implement timing using two techniques that I have perfected. 

<p>First of all lets start of with the simple way. Now lets say you have a room with four lights in it and you want the second to turn on 1 second after the first, the third 1 second after the second, and so on. 

<p>On top of this you want them triggered with one switch. Now a trigger_relay has no delay build in so you have to use something else. Most of you probably don't know this but a trigger_multiple has a targetname for a reason. The obvious reason is that it can be triggers both when the player walks in or if it is triggered by another event. 

<p>As for the lights lets create a small room with four light. Give each light a different targetname: Light1 for the first, light2 for the second, and so on. 

<p>Now create a button or trigger that will turn on the light. Give the button or trigger a target of start. 

<p>Now create a very small brush, make it a trigger_multiple, and place it at the upper left corner of both the top and back view. The placement is not necessary but you want to have the triggers out of reach so the player doesn't trip them accidentally. 

<p>Now give the trigger_multiple a targetname of start and a target of light1. You can use the delay field to choose when you want the first light to turn on. 

<p>Create 3 more trigger_multiple for the rest of the lights and follow the step above. Just set different delays for them and then you got four independent lights turned on at different times.


<br><br><br><b>TECHNIQUE #2</b>: 

<p>This is not really necessary but this way is good if you don't expect to use the triggers twice. 

<p>The technique is almost the same. The first step is to create a room with 4 lights with different targetnames. Also create a button or trigger that will turn on the lights and give it a target of start. 

<p>The second step is to create a func_timer with a targetname of start and a target of start1. 

<p>The third step is to create a trigger_count with a targetname of start1 and a target that point to the first light. I don't think it matters where you put a func_timer. 

<p>Don't forget that the counters themselves don't have a delay but you can set a wait time for the func_timer. Lets say its 1. 

<p>Now follow the third step for the rest of the lights that need to be triggered. You have to give the trigger_count for the first light a count of 1 and for the second a count of 2, and so on for all the lights. 

<p>What this does that each light will be triggered every value of second that you put for the wait field in the func_timer. As for this func_timer there is a wait of 1, so the first light will tun on instantly. The second one in one second. The third in two and so on. 

<p>That should be it. I think this will broaden the range of effects that could be created in quake2. 

<p>If you find a better way for timing without coding anything please email me at DemolisherFX@usa.net or jmario1002@hotmail.com.

</font>

<p>
</ul><h1 id="57" name="57" class="book-h1">Turrets</h1><ul><!-- q2faq.htm - converted 21/08/01 from old rust documents -->
<h3>Quake 2</h3>
<blockquote>
		User Controlled Turrets - Fishman</a>
</blockquote>
<br><br>	

 <p><b>turret_breach</b>, <b>turret_base</b>, and <b>turret_driver</b> all must be 
	used together to create those cool gun turrets that are in 2 of the quake2 
	levels. These entities are by far the hardest I have come across to use in a 
	level and only advanced level editors should attempt this. I would of never of 
	figured it out if it wasn't for steve at the 
	<a href="http://www.planetquake.com/QuakeLab/QuakeLab2/"><b>quakelab</b></a> 
	telling me to specify an origin for the turret_breach and turret_base. We will 
	get to that though in due time.</p>

 <p>The first thing you need to do is to <b>create the gun</b>. This might take 
	awhile to make it look good. Here is a shot of the id one:</p>

<center>
	<img src="/content/quake2/tutorials/turret/gunpic1.JPG" width="250" height="143" border="0" alt="gunpic">
</center>

 <p>You must also make everything <b>orientated towards angle 0</b>(straight right 
	from a top view), The trick is to kind of <b>make it into 2 parts. The barrel 
	and the base.</b> the barrel is the part that is going to be the turret_breach 
	and the base is going to be the turret_base. Also take into consideration that 
	the creature driving the gun will be standing on the turret_breach so actually 
	<b>the turret_breach will include the barrel and the platform that the 
	turret_driver will be standing on.</b> Here is another visual example to show you
	what the hell I am talking about:</p>

<center>
	Here is the barrel which includes the barrel and the platform for the driver to 
	stand on(<b>turret_breach</b>):<br>
	<img src="/content/quake2/tutorials/turret/barrel.jpg" width="250" height="52" border="0" alt="barrel"><br>
	&nbsp;<br>
	Here is the base(<b>turret_base</b>):<br>
	<img src="/content/quake2/tutorials/turret/base.JPG" width="250" height="146" border="0" alt="turret_base"><br>
	&nbsp;<br>
	Here is the barrel(<b>turret_breach</b>) and the base(<b>turret_base</b>) 
	together:<br>
	<img src="/content/quake2/tutorials/turret/both.jpg" width="250" height="70" border="0" alt="turret_breach and turret_base">
</center>

 <p>Once you get these 2 parts made then you must <b>select the barrel and make it a 
	turret_breach, and select the base and make it a turret_base.</b> Now you must 
	<b>give the turret_breach a targetname</b>. So for this example lets give it a 
	targetname of breach. <b>targetname=breach</b>. The turret_breach and the 
	turret_base go together so <b>they must be teamed</b>. To do this give each of 
	these entities the key value pair <b>team</b> with the same value. For this 
	example lets give them a team name of gun. So on <b>both</b> the turret_breach 
	and the turret_base there should be a key value pair of <b>team gun</b> Now you 
	must decide which direction you want your gun to point in the game and <b>set the
	key value pair angle to what ever direction you want the gun to point.</b> 
	<b>BOTH</b> the turret_breach and the turret_base should have the same angle. For
	this example we will set the angle to be 180. <b>angle 180</b>.</p>

 <p>Next thing you must do is create the target that the gun will shoot at. To do 
	this you must <b>create an info_notnull entity and place it at the tip of the 
	barrel and give it a targetname.</b> For this example our info_notnull will have 
	a targetname of tip. <b>targetname tip</b>. Then <b>set the target of the 
	turret_breach to the info_notnull</b>. <b><b>target=tip</b></b>.</p>

 <p>Next thing you need to do is to <b>create the turret_driver and target it to the 
	turret_breach.</b> target=breach. Place the turret_drive where you want him to be
	standing(on the platform you made him on the turret_breach).</p>

 <p>Now to the part that I couldn't figure out but steve at the 
	<a href="http://www.planetquake.com/quakelab/quakelab2/">quakelab</a> helped me 
	out on. For the turret_breach and the turret_base <b>you must have a brush set as
	an origin brush</b>. These will keep gun from rotating all around the room and 
	looking really messed up. So the turret_breach <b>must</b> have an origin brush 
	and the turret_base <b>must</b> have an origin brush. To make a brush an origin 
	brush you must <b>change the surface property</b> of that brush and set the 
	origin flag. This is done differently for each editor. Check your manual. It is 
	better to select origin brushes that for breach and the base that are near each 
	other. Here is a diagram of what brushes i made into origin brushes.</p>

<center>
	<img src="/content/quake2/tutorials/turret/complete.JPG" width="400" height="168" border="0" alt="complete">
</center>

 <p>Thats about all there is too it. As you can see this is a <b>very</b> difficult 
	entity to use. Not very fun at all. I urge you to download my 
	<a href="/content/quake2/tutorials/turret/rust7.zip">example</a> map if you are going to try do this. If you still
	have problems post your question in the 
	<a href="http://forums.gamedesign.net/">Rust forums</a> and someone will give
	you a hand.</p>
</ul><h1 id="49" name="49" class="book-h1">Using Clip Brushes</h1><ul><h3>Quake 2</h3>
	<blockquote>
		Using Clip Brushes - <a href="mailto:dmm2editor@aol.com">Richard Neff</a> and <a href="mailto:rascal@magnolia.net">David Hyde</a>
	</blockquote>
	
<br><br>

<p>One of the signs of a quality map maker for any game is creating maps that do two things:

<ul>
<li>Create visually exciting areas for the player 
<li>Create a level that is interesting to play 
</ul>

<p>This tutorial is going to concentrate on the latter concept.  More precisely, the use of Clip brushes to help keep the player from being "snagged" on small brushes used to help with the first concept above.

<br><br><b>"Oh no! I'm stuck"</b>

<p>One of the things you'll notice if you fire up any of Id Software's original Quake 2 levels, is that there are a lot of columns and uneven surfaces running along walls.   This creates an exciting visual impact, however, you should notice that the player can run along those walls backwards and not stop until they reach another wall.

<p>To be more precise, let's look at the following screenshot from one of those levels, base1.bsp (the first level in single player.)

<p><div align="center"><img border="0" width="450"  src="/content/quake2/tutorials/clip/clip_img1.jpg"></div>

<p>Towards the end of the level, you'll see this wall near the stairs.  Note that there are both columns and light fixtures running along this wall.  Yet, if you press yourself against this wall and run all the way to the next wall, you don't get "snagged."  A <b>very</b> useful thing when you're being pursued by a Quake 2 monster, or worse yet, a real live Deathmatch opponent!

<br><br><b>So, how is this done?</b>

<p>Ok, the answer is pretty obvious given the title - It was done using Clip brushes.   But, in this tutorial we'll look at the two methods of using Clip brushes to keep players from being "snagged" while playing your levels.

<p>Clip brushes themselves are pretty easy to create.  Simply create a brush with the Clip texture on all sides of the brush.  It's totally invisible in the game and it won't have any effect on the poly count (r_speeds) of the level.   Essentially, they're like invisible "force fields" that prevent the player from getting to an area (useful for more than "snagging" problems also.) Some editors may require that you manually specify the Clip content property, but most will automatically create the Clip brush.  If you run your map and see the Clip texture, then you probably haven't applied that texture to all sides of the brush.

<br><br><b>The Two Techniques</b>

<p>Truthfully, none of this is rocket science - it's pretty straightforward.   However, there are two ways to handle not getting "snagged."   Consider the image above showing base1.bsp.  One way to help the player from getting snagged is to put an angled brush on both sides of the columns or lights.   For example, here's a screenshot in my editor of a light fixture that hangs on a wall:

<p><div align="center"><img border="0" width="450"  src="/content/quake2/tutorials/clip/clip_img2.jpg"></div>

<p>In this example, you'll notice that the clip brushes on each side are designed to gently let the player get around the protruding light fixture by forcing them along an angle between the wall and the fixture itself.  The slope of the angle is something you sometimes have to work with, but typically a 45 degree angle between perpendicular surfaces works well.

<p>So, what's the drawback to this method?  Two primary drawbacks come to mind.   One involves the player, the other often involves you, the editor.  First, if a player is running on the surface of a such a wall, their direction will change slightly.   For those players that like to run backwards against a wall while firing, this will affect those shots when the light fixture is hit.  And, as well all know, this could mean life or death in a deathmatch game!

<p>The next drawback is with editing.  If you wanted to do this along a wall with a lot of columns or light fixtures, you'd have to create 2 clip brushes for each object that protrudes from that wall.  Needless to say, this makes an already tedious process more painstaking!  So, this method is best used for any light fixtures or the like that you've created as a prefab in your editor.

<p>So, what's the easiest way to handle a wall like the base1.bsp figure that won't take a lot of time to create, yet still allow the player good movement along the wall?  The answer is actually quite simple -- make a Clip brush that covers all the protruding objects along that wall. (And what Id actually did in that particular area.)

<p>Here's some screenshots to help you out:

<p>In this figure, here's a room with some columns

<p><div align="center"><img src="/content/quake2/tutorials/clip/clip_img3.jpg"></div>

<p>If the player were to run along the wall on the right, they'd get snagged on every column and I'd need to make 6 total clip brushes using the first technique.

<p>However, if I make the Clip brush (the red box) like so:

<p><div align="center"><img src="/content/quake2/tutorials/clip/clip_img4.jpg"></div>

<p>Then, the player will run along the entire wall without getting snagged or being moved.   Plus, the added benefit to the level maker is that it is a much simpler job to create 1 rectangular brush than 6 triangular ones!

<p>So, why not use this method all the time?  Well, one word -- doors.  If we had a door on the right side we couldn't have the Clip brush covering the door, the player would never be able to pass through the door.  In this case, a combination of the above methods would need to be used.

<br><br><b>Pretty Simple Huh?</b>

<p>Well, that's pretty much the main points about Clip brushes.  See, that wasn't very hard, was it?  However, putting Clip brushes in your level will make a big difference for those people playing your maps (especially if you're designing DM or CTF maps.)  So, it's worth the extra time placing Clip brushes in your level.

<p>
</ul><h1 id="552" name="552" class="book-h1">Using Text Editors for Mapping</h1><ul><h2>Using Text Editors For Mapping</h2>

<blockquote>by Ricebug</blockquote>

<p>You've been working on this huge map and have just discovered
that about a thousand brushes need the <i>detail</i> property applied to them.
This job would be tedious in the best of
circumstances, not to mention the possibility of missing a few brushes.&nbsp; Or let's
say you need to change all the _focus values for a certain light entity. Those
mine lights are a bitch to select due to their size. Again, an exercise in
tedium.</p>

<p>Lucky for us, the standard .map format is nothing more than
simple ASCII---in other words, plain English. So opening it up in a text editor
provides us with the ability to use the <i>Search &amp; Replace</i> functions to
do sweeping changes in a map, thus removing the drudgery. Doing so requires some
preparation, however.</p>

<p align="left"><font face="Arial">1. Back up the map file! There's nothing worse than destroying a
map with the click of a mouse.</font></p>

<p align="left"><font face="Arial">2. Get a text editor. I'd recommend <a href="http://www.jgsoft.com/"><b>EditPad</b></a>.
It's free, it will do operations on multiple files, and will not contaminate the
map file with unnecessary (and fatal) characters. If you like more muscle, <a href="http://www.idmcomp.com/index.html"><b>UltraEdit32</b></a>
is also a good choice. Do not use Windows' <i>Notepad.</i> It has the nasty
habit of inserting or deleting carriage returns. Besides, it has a limited
filesize buffer. Same for any high-end word processor. Unless you really
understand the different .txt formats, (there are 4) it's safer to use EditPad.&nbsp;</font></p>

<p align="left"><font face="Arial">3. If you're using a map editor that saves its maps in a
proprietary format, such as WorldCraft or QOOLE, you'll have to export the map
as a <i>.map</i> file. Once the changes have been made, you can then re-load the
repaired map and press on.</font></p>

<div align="center">
  <center>
  <table border="1" width="450">
    <tr>
      <td bgcolor="#FFFFFF">
        <p align="center"><font face="Arial">WARNING</font></p>
  </center>
        <p align="center"><font face="Arial">If your editor supports&nbsp; brush
        grouping or some other hierarchical tactic,
        you will lose this information in the export process. See the caveat and
        recommendations mentioned at the end of this tutorial.</font></td>

    </tr>
  </table>
</div>
<hr>
<h3><font face="Arial">The Basic Brush</font></h3>
<div align="center">
  <center>
  <table border="0" width="450" bgcolor="#FFFFFF">
    <tr>
      <td width="711">

        <p align="left"><font face="Arial" size="2">{<br>
        ( 128 0 -64 ) ( 8 0 -64 ) ( 8 -128 -64 ) e1u1/c_met11_2 0 0 0 1 1 0 0 0<br>
        ( 8 -128 0 ) ( 8 0 0 ) ( 128 0 0 ) e1u1/c_met11_2 0 0 0 1 1 0 0 0<br>
        ( 8 -64 8 ) ( 128 -64 8 ) ( 128 -64 0 ) e1u1/c_met11_2 0 0 0 1 1 0 0 0<br>
        ( 64 -128 8 ) ( 64 0 8 ) ( 64 0 0 ) e1u1/c_met11_2 0 0 0 1 1 0 0 0<br>
        ( 128 0 8 ) ( 8 0 8 ) ( 8 0 0 ) e1u1/c_met11_2 0 0 0 1 1 0 0 0<br>

        ( 0 0 8 ) ( 0 -128 8 ) ( 0 -128 0 ) e1u1/c_met11_2 0 0 0 1 1 0 0 0<br>
        }</font></td>
    </tr>
  </table>
  </center>
</div>

<p align="left"><font face="Arial">This is all the info describing a 64<sup>3</sup> brush with the <b>c_met11_2</b>

texture applied to it. If you care to check, one corner of this brush sits at
the center of the world (0 0 0). Imagine having to construct an entire map using
a text editor! Believe it or not, the first CAD programs were done exactly in
this manner. Lucky for the users, they only had to worry about drawing a 2-dimensional world.</font></p>

<p align="left"><font face="Arial">What we're really interested in are the numbers following the
texture name. You'll see there are eight. Taken from the example above, the
first line would be <span style="background-color: #FFFFFF">0 0 0 1 1 0 0 0</span>.
These are all of the texture values and spawnflags. The fact that there are
mostly zeros means the texture has no surface or content flags set for it; it's
just a plain old texture. The two 1's are the texture's dimensions, which mean
that it has been applied with it's default size.&nbsp;</font></p>

<p align="center"><font face="Arial"><img border="0" src="content/quake2/tutorials/text_editing/texf_01.gif"></font></p>

<p align="center"><b><font color="#800000" size="2" face="Arial">A visual reference for the
texture property flags</font></b></p>

<p align="left"><font size="3" face="Arial">Even though you may use a different
editor, the flags still mean the same thing.</font></p>
<hr>
<h3 align="left"><font face="Arial">Texture Properties</font></h3>

<p align="left"><font face="Arial">Now that you know what the 8 data bits reference, you now need
to know what possible values can be used. Let's take the light value, which is
used typically for sky textures and light-emitting textures. Therefore, a string
of <font color="#000000"><span style="background-color: #FFFFFF">0 0 0 1 1 0 0
100</span></font> means that you've get a light value of 100. However, since the
light flag is normally set for a situation like this, it would read <span style="background-color: #FFFFFF"><font color="#000000">0
0 0 1 1 0 1 100.</font></span> Reason being, is that 'light' is the first item
in the surface property list, and therefore has a spawnflag value of '1'.
'Slick' is '2', sky is '4' and so on, following the numerical convention used
for spawnflags. Here's a handy reference showing all of the spawnflags:</font></p>
<div align="center">
  <center>
  <table border="1" width="450" bgcolor="#FFFFFF">
    <tr>
      <td align="center" bgcolor="#808080" colspan="2"><b><font face="Arial">Surface Property
        Spawnflags</font></b></td>

      <td align="center" bgcolor="#808080" colspan="2"><b><font face="Arial">Content Property
        Spawnflags</font></b></td>
    </tr>
    <tr>
      <td valign="top">	<font face="Arial">	Light<br>
	Slick&nbsp;<br>
	Sky Flag<br>

        Warp<br>
	Trans33&nbsp;<br>
	Trans66&nbsp;<br>
	Flowing&nbsp;<br>
	NoDraw&nbsp;<br>
	Hint<br>

        Skip<br>
        </font>
      </td>
      <td valign="top"><font face="Arial">1<br>
        2<br>
        4<br>
        8<br>

        16<br>
        32<br>
        64<br>
        128<br>
        256<br>
        512</font></td>

      <td><font face="Arial">Solid<br>
	Window<br>
	Aux<br>
	Lava<br>
	Slime<br>
	Water<br>

	Mist<br>
	PlayerClip<br>
	MonsterClip<br>
	Current_0<br>
	Current_90<br>
	Current_180<br>

	Current_270<br>
	Current_up<br>
	Current_dn<br>
	Origin<br>
	Monster<br>
	Corpse<br>

	Detail<br>
	Translucent<br>
	Ladder</font></td>
      <td><font face="Arial">1<br>
        2<br>
        4<br>

        8<br>
        16<br>
        32<br>
        64<br>
        65536<br>
        131072<br>

        262144<br>
        524288<br>
        1048576<br>
        2097152<br>
        4194304<br>
        8388608<br>

        16777216<br>
        33554432<br>
        67108864<br>
        134217728<br>
        268435456<br>
        536870912</font></td>

    </tr>
  </table>
  </center>
</div>
<p><font face="Arial">With this information you can now fix certain things in the blink of an eye.
Some suggestions:</font></p>
<p><font face="Arial">In some map editors, applying the ladder flag can be a tedious process.
Suppose your ladder is using a texture named <b>eggwhite</b>. Open the map in
EditPad, highlight and copy the text, paste it into the <i>Text to find</i>
field, paste it again into the <i>Replace with:</i> field and replace the <u>third
zero from the end</u> with the ladder spawnflag number.</font></p>

<p align="center"><font face="Arial"><img border="0" src="content/quake2/tutorials/text_editing/texf_02.gif"></font></p>
<p align="center"><b><small><font color="#800000" face="Arial">EditPad's Find &amp; Replace
dialog</font></small></b></p>
<p><font face="Arial">Or suppose you had a level with a lot of sky brushes and it needed the light
value jacked up. A real pain to do so within the editor, but a piece of cake
with a text editor.&nbsp;</font></p>
<p align="center"><span style="background-color: #FFFFFF"><font face="Arial">e1u1/sky1 0 0 0 50 50 0 133
50</font></span></p>
<p align="left"><font face="Arial">&nbsp;The '50 50' tells you that I've applied a vertical and
horizontal stretch value of 50 to the sky texture. The '133' is a surface
property spawnflag total of light (1) + sky (4) + nodraw (128). The '50' at the
end is the light value I applied to the sky texture. Since 100 would give me
better results, changing this last number via EditPad on all sky brushes would
be a piece of cake.</font></p>
<p align="left"><font face="Arial">I had a large warehouse whose ceiling used a light-emitting
texture that covered a host of various-sized brushes. As in the case of the sky,
the same method was used to correct the light value, A real time saver.</font></p>
<hr>
<h3 align="left"><font face="Arial">A Note Concerning Non-Radiant Editors</font></h3>
<p align="left"><font face="Arial">Mad Dog had some input on this issue which is relevant to
Worldcraft, QOOLE, and QuArk users. If you're thinking of replacing textures
globally with new properties using a text editor, do not export not the entire
map as a .map.&nbsp; Instead, first determine which groups are affected, and
then export each group<br>

individually as a separate .map. Then, after changing things, copy the contents
of each of those new &quot;maplets&quot; into your primary map, make each a new
group, and replace each old group with the new ones. That way the grouping is
preserved.</font></p>
<hr>
<p align="left"><font face="Arial">Map making should be fun and not tedious. Hopefully, I've
enlightened you on how to be more productive in your endeavors and put the fun
back into creating those worlds.&nbsp;</font></p>
<hr>
<div align="center">
  <center>
  <table border="0">
    <tr>
      <td width="50%"><a href="http://ricebug.qeradiant.com/"><font face="Arial"></font></a></td>

      <td width="50%"><a href="http://ricebug.qeradiant.com/menu1.shtml"><font face="Arial"></font></a></td>
    </tr>
  </table>
  </center>
</div>
<p align="center"><b><font face="Arial"><small>Copyright 2001, by Terry DeLaney. Permission is granted to
distribute this file as long as the author receives credit.</small></font></b></p>
</ul></body></html>